#
# Rules.make: common makefile rules for the dtn project.
#

PLATFORM = @PLATFORM@
exec_prefix = @EXEC_PREFIX@
BINDIR  = @BINDIR@
SBINDIR = @SBINDIR@
LIBDIR  = @LIBDIR@
MANDIR  = @MANDIR@
INCDIR  = @INCDIR@
LIBRPC  = @LIBRPC@

INCDIRS := -I$(SRCDIR) -I$(SRCDIR)/servlib

#
# Common settings extracted from the configure script
#
INCDIRS    += @INCDIRS@
LIBDIRS     = @LIBDIRS@
LIBS	    = @LIBS@
STATIC_LIBS = @STATIC_LIBS@
CC          = @CC@
CPP         = @CPP@
DEPFLAGS    = @DEPFLAGS@

#
# Targets are "native" and "arm"
# 
TARGET = @TARGET@

# native target
ifeq ($(TARGET),native)

STRIP       = strip
INSTALL     = install
RM          = rm
RPCGEN      = rpcgen
WHOLE_AR    := -Wl,-whole-archive
NO_WHOLE_AR := -Wl,-no-whole-archive

endif


# For cross-compiling to ARM, you will probably want to install your own
# ARM tool chain.  Here we assume it is in /usr/local/ARM
# This line can sometimes be used if you need to build the cross-compile environment:
#  CC=arm-linux-gcc ./configure --host=i686-linux --build=i686-linux --target=arm-linux --prefix=/usr/local/ARM
#
ifeq ($(TARGET),arm)
ARMDIR		= /opt/Embedix/tools/arm-linux
INCDIRS 	+= -I$(ARMDIR)/include
LIBDIRS 	+= -L$(ARMDIR)/lib
STRIP 		= -arm-linux-strip
RPCGEN		= rpcgen
INSTALL 	= cp
RM 		= rm
endif

#
# Cons up CFLAGS
#
DEBUG 		= @DEBUG@
OPTIMIZE	= @OPTIMIZE@
WARN  		= -Wall -Werror @OPTIMIZE_WARN@ @NOWARN@
CFLAGS		= $(INCDIRS) $(DEBUG) $(OPTIMIZE) $(DEPFLAGS) $(WARN)
LFLAGS		= $(LIBDIRS) @STATIC@

#
# To link with the servlib, use the following to make sure that all
# symbols are included (including static constructors in particular)
#
LINK_SERVLIB := $(WHOLE_AR) $(SRCDIR)/servlib/libdtnserv.a $(NO_WHOLE_AR)

#
# Add a phony rule to make sure this isn't created before the default
#
.PHONY: catchdefault
catchdefault:
	@echo "Rules.make should be included after the default rule is set"
	@exit 1

#
# Rule for generating a .o file from the corresponding .cc file;
# automatically creates dependencies via the -MMD flag.
#
%.o: %.cc
	@rm -f $@; mkdir -p $(@D)
	$(CPP) $(CFLAGS) -c $< -o $@

%.o: %.c
	@rm -f $@; mkdir -p $(@D)
	$(CC) $(CFLAGS) -c $< -o $@

#
# Generate cpp output in .E files.
#
%.E: %.cc
	@rm -f $@; mkdir -p $(@D)
	$(CPP) $(CFLAGS) -c $< -E -o $@

%.E: %.c
	@rm -f $@; mkdir -p $(@D)
	$(CPP) $(CFLAGS) -c $< -E -o $@

#
# Always include all the .d files that we can find, based on all the
# source files we can find.
#
ifeq ($(ALLSRCS),)
ALLSRCS := $(shell find . -name \*.cc -o -name \*.c)
endif
DEPFILES := $(ALLSRCS:%.cc=%.d)
DEPFILES := $(DEPFILES:%.c=%.d)
ifneq ($(DEPFILES),)
-include $(DEPFILES)
endif

echodep:
	@echo "allsrcs: $(ALLSRCS)"
	@echo "depfiles: $(DEPFILES)"

#
# Clean out all object files
#
clean: $(SUBDIRS) objclean depclean genclean binclean

.PHONY: $(SUBDIRS)
$(SUBDIRS):
	$(MAKE) -C $@ $(MAKECMDGOALS)

.PHONY: objclean
objclean:
	@echo "removing object files..."
	find . \( -name '*.[Eo]' \) -print0 | xargs -0 rm -f

.PHONY: depclean
depclean:
	@echo "removing dependency files..."
	find . \( -name '*.d' \) -print0 | xargs -0 rm -f

.PHONY: genclean
genclean:
	@echo "removing generated files: $(GENFILES)..."
	@test -z "$(GENFILES)" || rm -f $(GENFILES)

.PHONY: binclean
binclean:
	@echo "removing binary files: $(BINFILES)..."
	@test -z "$(BINFILES)" || rm -f $(BINFILES)

.PHONY: distclean
CFGFILES := Rules.make config.h
distclean: clean
	@echo "removing configure generated files: $(CFGFILES)..."
	@test -z "$(CFGFILES)" || rm -f $(CFGFILES)
