// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef ROUTER_H
#define ROUTER_H

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030000L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>
#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/namespace-infomap.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type<type> simple_type;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef integer non_positive_integer;
  typedef integer non_negative_integer;
  typedef integer positive_integer;
  typedef integer negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef long double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken> nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::day< char, simple_type > day;
  typedef ::xsd::cxx::tree::month< char, simple_type > month;
  typedef ::xsd::cxx::tree::month_day< char, simple_type > month_day;
  typedef ::xsd::cxx::tree::year< char, simple_type > year;
  typedef ::xsd::cxx::tree::year_month< char, simple_type > year_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::serialization< char > serialization;
  typedef ::xsd::cxx::tree::no_namespace_mapping< char > no_namespace_mapping;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::xsi_already_in_use< char > xsi_already_in_use;
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  // Parsing/serialization error.
  //
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::errors< char > errors;

  // Error handler interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // Namespace information. Used in serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info < char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap < char > namespace_infomap;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // DOM user data key for back pointers to tree nodes.
  //
#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA

  const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;

#endif
}

// Forward declarations.
//
namespace dtn
{
  namespace rtrmessage
  {
    class dtnStatusType;
    class bundlePriorityType;
    class eventSourceType;
    class bundleForwardActionType;
    class contactReasonType;
    class linkTypeType;
    class linkStateType;
    class eidTypeType;
    class failureActionType;
    class bundleLocationType;
    class eidType;
    class bundleType_base;
    class bundleType;
    class contactType_base;
    class contactType;
    class clInfoType;
    class linkType_base;
    class linkType;
    class routeEntryType_base;
    class routeEntryType;
    class registrationType_base;
    class registrationType;
    class bundle_received_event;
    class bundle_transmitted_event;
    class bundle_transmit_failed_event;
    class bundle_delivery_event;
    class bundle_expired_event;
    class contact_up_event;
    class contact_down_event;
    class link_created_event;
    class link_deleted_event;
    class link_available_event;
    class link_unavailable_event;
    class link_busy_event;
    class route_add_event;
    class route_delete_event;
    class custody_signal_event;
    class custody_timeout_event;
    class registration_added_event;
    class registration_removed_event;
    class registration_expired_event;
    class open_link_request;
    class send_bundle_request;
    class cancel_bundle_request;
    class inject_bundle_request;
    class link_report;
    class contact_report;
    class route_report;
    class bundle_report;
    class dtn;
  }
}


#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

namespace dtn
{
  namespace rtrmessage
  {
    class dtnStatusType: public ::xml_schema::string
    {
      public:
      enum _xsd_dtnStatusType
      {
        justBooted,
        shuttingDown
      };

      dtnStatusType ();

      dtnStatusType (_xsd_dtnStatusType);

      dtnStatusType (const ::xml_schema::string&);

      dtnStatusType (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      dtnStatusType (const ::xercesc::DOMAttr&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      dtnStatusType (const ::std::basic_string< char >&,
                     const ::xercesc::DOMElement*,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      dtnStatusType (const dtnStatusType&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual dtnStatusType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      dtnStatusType&
      operator= (_xsd_dtnStatusType);

      virtual
      operator _xsd_dtnStatusType () const
      {
        return _xsd_dtnStatusType_convert ();
      }

      protected:
      _xsd_dtnStatusType
      _xsd_dtnStatusType_convert () const;

      public:
      static const char* const _xsd_dtnStatusType_literals_[2];
      static const _xsd_dtnStatusType _xsd_dtnStatusType_indexes_[2];
    };

    class bundlePriorityType: public ::xml_schema::string
    {
      public:
      enum _xsd_bundlePriorityType
      {
        bulk,
        normal,
        expedited,
        _unknown_priority_
      };

      bundlePriorityType ();

      bundlePriorityType (_xsd_bundlePriorityType);

      bundlePriorityType (const ::xml_schema::string&);

      bundlePriorityType (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      bundlePriorityType (const ::xercesc::DOMAttr&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      bundlePriorityType (const ::std::basic_string< char >&,
                          const ::xercesc::DOMElement*,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      bundlePriorityType (const bundlePriorityType&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual bundlePriorityType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      bundlePriorityType&
      operator= (_xsd_bundlePriorityType);

      virtual
      operator _xsd_bundlePriorityType () const
      {
        return _xsd_bundlePriorityType_convert ();
      }

      protected:
      _xsd_bundlePriorityType
      _xsd_bundlePriorityType_convert () const;

      public:
      static const char* const _xsd_bundlePriorityType_literals_[4];
      static const _xsd_bundlePriorityType _xsd_bundlePriorityType_indexes_[4];
    };

    class eventSourceType: public ::xml_schema::string
    {
      public:
      enum _xsd_eventSourceType
      {
        peer,
        application,
        dataStore,
        admin,
        fragmentation
      };

      eventSourceType ();

      eventSourceType (_xsd_eventSourceType);

      eventSourceType (const ::xml_schema::string&);

      eventSourceType (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      eventSourceType (const ::xercesc::DOMAttr&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      eventSourceType (const ::std::basic_string< char >&,
                       const ::xercesc::DOMElement*,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      eventSourceType (const eventSourceType&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual eventSourceType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      eventSourceType&
      operator= (_xsd_eventSourceType);

      virtual
      operator _xsd_eventSourceType () const
      {
        return _xsd_eventSourceType_convert ();
      }

      protected:
      _xsd_eventSourceType
      _xsd_eventSourceType_convert () const;

      public:
      static const char* const _xsd_eventSourceType_literals_[5];
      static const _xsd_eventSourceType _xsd_eventSourceType_indexes_[5];
    };

    class bundleForwardActionType: public ::xml_schema::string
    {
      public:
      enum _xsd_bundleForwardActionType
      {
        forward,
        copy
      };

      bundleForwardActionType ();

      bundleForwardActionType (_xsd_bundleForwardActionType);

      bundleForwardActionType (const ::xml_schema::string&);

      bundleForwardActionType (const ::xercesc::DOMElement&,
                               ::xml_schema::flags = 0,
                               ::xml_schema::type* = 0);

      bundleForwardActionType (const ::xercesc::DOMAttr&,
                               ::xml_schema::flags = 0,
                               ::xml_schema::type* = 0);

      bundleForwardActionType (const ::std::basic_string< char >&,
                               const ::xercesc::DOMElement*,
                               ::xml_schema::flags = 0,
                               ::xml_schema::type* = 0);

      bundleForwardActionType (const bundleForwardActionType&,
                               ::xml_schema::flags = 0,
                               ::xml_schema::type* = 0);

      virtual bundleForwardActionType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      bundleForwardActionType&
      operator= (_xsd_bundleForwardActionType);

      virtual
      operator _xsd_bundleForwardActionType () const
      {
        return _xsd_bundleForwardActionType_convert ();
      }

      protected:
      _xsd_bundleForwardActionType
      _xsd_bundleForwardActionType_convert () const;

      public:
      static const char* const _xsd_bundleForwardActionType_literals_[2];
      static const _xsd_bundleForwardActionType _xsd_bundleForwardActionType_indexes_[2];
    };

    class contactReasonType: public ::xml_schema::string
    {
      public:
      enum _xsd_contactReasonType
      {
        no_info,
        user,
        broken,
        cl_error,
        cl_version,
        shutdown,
        reconnect,
        idle,
        timeout,
        blocked,
        unblocked
      };

      contactReasonType ();

      contactReasonType (_xsd_contactReasonType);

      contactReasonType (const ::xml_schema::string&);

      contactReasonType (const ::xercesc::DOMElement&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      contactReasonType (const ::xercesc::DOMAttr&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      contactReasonType (const ::std::basic_string< char >&,
                         const ::xercesc::DOMElement*,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      contactReasonType (const contactReasonType&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      virtual contactReasonType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      contactReasonType&
      operator= (_xsd_contactReasonType);

      virtual
      operator _xsd_contactReasonType () const
      {
        return _xsd_contactReasonType_convert ();
      }

      protected:
      _xsd_contactReasonType
      _xsd_contactReasonType_convert () const;

      public:
      static const char* const _xsd_contactReasonType_literals_[11];
      static const _xsd_contactReasonType _xsd_contactReasonType_indexes_[11];
    };

    class linkTypeType: public ::xml_schema::string
    {
      public:
      enum _xsd_linkTypeType
      {
        alwayson,
        ondemand,
        scheduled,
        opportunistic
      };

      linkTypeType ();

      linkTypeType (_xsd_linkTypeType);

      linkTypeType (const ::xml_schema::string&);

      linkTypeType (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      linkTypeType (const ::xercesc::DOMAttr&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      linkTypeType (const ::std::basic_string< char >&,
                    const ::xercesc::DOMElement*,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      linkTypeType (const linkTypeType&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      virtual linkTypeType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      linkTypeType&
      operator= (_xsd_linkTypeType);

      virtual
      operator _xsd_linkTypeType () const
      {
        return _xsd_linkTypeType_convert ();
      }

      protected:
      _xsd_linkTypeType
      _xsd_linkTypeType_convert () const;

      public:
      static const char* const _xsd_linkTypeType_literals_[4];
      static const _xsd_linkTypeType _xsd_linkTypeType_indexes_[4];
    };

    class linkStateType: public ::xml_schema::string
    {
      public:
      enum _xsd_linkStateType
      {
        unavailable,
        available,
        opening,
        open,
        busy
      };

      linkStateType ();

      linkStateType (_xsd_linkStateType);

      linkStateType (const ::xml_schema::string&);

      linkStateType (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      linkStateType (const ::xercesc::DOMAttr&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      linkStateType (const ::std::basic_string< char >&,
                     const ::xercesc::DOMElement*,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      linkStateType (const linkStateType&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual linkStateType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      linkStateType&
      operator= (_xsd_linkStateType);

      virtual
      operator _xsd_linkStateType () const
      {
        return _xsd_linkStateType_convert ();
      }

      protected:
      _xsd_linkStateType
      _xsd_linkStateType_convert () const;

      public:
      static const char* const _xsd_linkStateType_literals_[5];
      static const _xsd_linkStateType _xsd_linkStateType_indexes_[5];
    };

    class eidTypeType: public ::xml_schema::string
    {
      public:

      eidTypeType ();

      eidTypeType (const ::std::basic_string< char >&);

      eidTypeType (const ::xercesc::DOMElement&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      eidTypeType (const ::xercesc::DOMAttr&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      eidTypeType (const ::std::basic_string< char >&,
                   const ::xercesc::DOMElement*,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      eidTypeType (const eidTypeType&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      virtual eidTypeType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;
    };

    class failureActionType: public ::xml_schema::string
    {
      public:
      enum _xsd_failureActionType
      {
        drop,
        defer,
        exec
      };

      failureActionType ();

      failureActionType (_xsd_failureActionType);

      failureActionType (const ::xml_schema::string&);

      failureActionType (const ::xercesc::DOMElement&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      failureActionType (const ::xercesc::DOMAttr&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      failureActionType (const ::std::basic_string< char >&,
                         const ::xercesc::DOMElement*,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      failureActionType (const failureActionType&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      virtual failureActionType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      failureActionType&
      operator= (_xsd_failureActionType);

      virtual
      operator _xsd_failureActionType () const
      {
        return _xsd_failureActionType_convert ();
      }

      protected:
      _xsd_failureActionType
      _xsd_failureActionType_convert () const;

      public:
      static const char* const _xsd_failureActionType_literals_[3];
      static const _xsd_failureActionType _xsd_failureActionType_indexes_[3];
    };

    class bundleLocationType: public ::xml_schema::string
    {
      public:
      enum _xsd_bundleLocationType
      {
        memory,
        disk,
        nodata
      };

      bundleLocationType ();

      bundleLocationType (_xsd_bundleLocationType);

      bundleLocationType (const ::xml_schema::string&);

      bundleLocationType (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      bundleLocationType (const ::xercesc::DOMAttr&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      bundleLocationType (const ::std::basic_string< char >&,
                          const ::xercesc::DOMElement*,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      bundleLocationType (const bundleLocationType&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual bundleLocationType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      bundleLocationType&
      operator= (_xsd_bundleLocationType);

      virtual
      operator _xsd_bundleLocationType () const
      {
        return _xsd_bundleLocationType_convert ();
      }

      protected:
      _xsd_bundleLocationType
      _xsd_bundleLocationType_convert () const;

      public:
      static const char* const _xsd_bundleLocationType_literals_[3];
      static const _xsd_bundleLocationType _xsd_bundleLocationType_indexes_[3];
    };

    class eidType: public ::xml_schema::type
    {
      public:

      struct _xsd_eidType
      {
        typedef ::xml_schema::type base_;
      };

      // uri
      // 
      public:
      struct uri
      {
        typedef ::dtn::rtrmessage::eidTypeType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const uri::type&
      uri () const;

      uri::type&
      uri ();

      void
      uri (const uri::type&);

      void
      uri (::std::auto_ptr< uri::type >);

      // Constructors.
      //
      public:
      eidType ();

      eidType (const uri::type&);

      eidType (const ::xercesc::DOMElement&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

      eidType (const eidType&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

      virtual eidType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< uri::type > _xsd_uri_;
    };

    class bundleType_base: public ::xml_schema::type
    {
      public:

      struct _xsd_bundleType_base
      {
        typedef ::xml_schema::type base_;
      };

      // source
      // 
      public:
      struct source
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const source::type&
      source () const;

      source::type&
      source ();

      void
      source (const source::type&);

      void
      source (::std::auto_ptr< source::type >);

      // dest
      // 
      public:
      struct dest
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const dest::type&
      dest () const;

      dest::type&
      dest ();

      void
      dest (const dest::type&);

      void
      dest (::std::auto_ptr< dest::type >);

      // custodian
      // 
      public:
      struct custodian
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const custodian::type&
      custodian () const;

      custodian::type&
      custodian ();

      void
      custodian (const custodian::type&);

      void
      custodian (::std::auto_ptr< custodian::type >);

      // replyto
      // 
      public:
      struct replyto
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const replyto::type&
      replyto () const;

      replyto::type&
      replyto ();

      void
      replyto (const replyto::type&);

      void
      replyto (::std::auto_ptr< replyto::type >);

      // prevhop
      // 
      public:
      struct prevhop
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const prevhop::type&
      prevhop () const;

      prevhop::type&
      prevhop ();

      void
      prevhop (const prevhop::type&);

      void
      prevhop (::std::auto_ptr< prevhop::type >);

      // length
      // 
      public:
      struct length
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const length::type&
      length () const;

      length::type&
      length ();

      void
      length (const length::type&);

      // location
      // 
      public:
      struct location
      {
        typedef ::dtn::rtrmessage::bundleLocationType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const location::type&
      location () const;

      location::type&
      location ();

      void
      location (const location::type&);

      void
      location (::std::auto_ptr< location::type >);

      // payload
      // 
      public:
      struct payload
      {
        typedef ::xml_schema::base64_binary type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const payload::container&
      payload () const;

      payload::container&
      payload ();

      void
      payload (const payload::type&);

      void
      payload (const payload::container&);

      void
      payload (::std::auto_ptr< payload::type >);

      // recv_blocks
      // 
      public:
      struct recv_blocks
      {
        typedef ::xml_schema::base64_binary type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const recv_blocks::container&
      recv_blocks () const;

      recv_blocks::container&
      recv_blocks ();

      void
      recv_blocks (const recv_blocks::type&);

      void
      recv_blocks (const recv_blocks::container&);

      void
      recv_blocks (::std::auto_ptr< recv_blocks::type >);

      // api_blocks
      // 
      public:
      struct api_blocks
      {
        typedef ::xml_schema::base64_binary type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const api_blocks::container&
      api_blocks () const;

      api_blocks::container&
      api_blocks ();

      void
      api_blocks (const api_blocks::type&);

      void
      api_blocks (const api_blocks::container&);

      void
      api_blocks (::std::auto_ptr< api_blocks::type >);

      // bundleid
      // 
      public:
      struct bundleid
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundleid::type&
      bundleid () const;

      bundleid::type&
      bundleid ();

      void
      bundleid (const bundleid::type&);

      // is_fragment
      // 
      public:
      struct is_fragment
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const is_fragment::type&
      is_fragment () const;

      is_fragment::type&
      is_fragment ();

      void
      is_fragment (const is_fragment::type&);

      // is_admin
      // 
      public:
      struct is_admin
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const is_admin::type&
      is_admin () const;

      is_admin::type&
      is_admin ();

      void
      is_admin (const is_admin::type&);

      // do_not_fragment
      // 
      public:
      struct do_not_fragment
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const do_not_fragment::type&
      do_not_fragment () const;

      do_not_fragment::type&
      do_not_fragment ();

      void
      do_not_fragment (const do_not_fragment::type&);

      // priority
      // 
      public:
      struct priority
      {
        typedef ::dtn::rtrmessage::bundlePriorityType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const priority::type&
      priority () const;

      priority::type&
      priority ();

      void
      priority (const priority::type&);

      void
      priority (::std::auto_ptr< priority::type >);

      // custody_requested
      // 
      public:
      struct custody_requested
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const custody_requested::type&
      custody_requested () const;

      custody_requested::type&
      custody_requested ();

      void
      custody_requested (const custody_requested::type&);

      // local_custody
      // 
      public:
      struct local_custody
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const local_custody::type&
      local_custody () const;

      local_custody::type&
      local_custody ();

      void
      local_custody (const local_custody::type&);

      // singleton_dest
      // 
      public:
      struct singleton_dest
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const singleton_dest::type&
      singleton_dest () const;

      singleton_dest::type&
      singleton_dest ();

      void
      singleton_dest (const singleton_dest::type&);

      // custody_rcpt
      // 
      public:
      struct custody_rcpt
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const custody_rcpt::type&
      custody_rcpt () const;

      custody_rcpt::type&
      custody_rcpt ();

      void
      custody_rcpt (const custody_rcpt::type&);

      // receive_rcpt
      // 
      public:
      struct receive_rcpt
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const receive_rcpt::type&
      receive_rcpt () const;

      receive_rcpt::type&
      receive_rcpt ();

      void
      receive_rcpt (const receive_rcpt::type&);

      // forward_rcpt
      // 
      public:
      struct forward_rcpt
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const forward_rcpt::type&
      forward_rcpt () const;

      forward_rcpt::type&
      forward_rcpt ();

      void
      forward_rcpt (const forward_rcpt::type&);

      // delivery_rcpt
      // 
      public:
      struct delivery_rcpt
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const delivery_rcpt::type&
      delivery_rcpt () const;

      delivery_rcpt::type&
      delivery_rcpt ();

      void
      delivery_rcpt (const delivery_rcpt::type&);

      // deletion_rcpt
      // 
      public:
      struct deletion_rcpt
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const deletion_rcpt::type&
      deletion_rcpt () const;

      deletion_rcpt::type&
      deletion_rcpt ();

      void
      deletion_rcpt (const deletion_rcpt::type&);

      // app_acked_rcpt
      // 
      public:
      struct app_acked_rcpt
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const app_acked_rcpt::type&
      app_acked_rcpt () const;

      app_acked_rcpt::type&
      app_acked_rcpt ();

      void
      app_acked_rcpt (const app_acked_rcpt::type&);

      // creation_ts_seconds
      // 
      public:
      struct creation_ts_seconds
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const creation_ts_seconds::type&
      creation_ts_seconds () const;

      creation_ts_seconds::type&
      creation_ts_seconds ();

      void
      creation_ts_seconds (const creation_ts_seconds::type&);

      // creation_ts_seqno
      // 
      public:
      struct creation_ts_seqno
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const creation_ts_seqno::type&
      creation_ts_seqno () const;

      creation_ts_seqno::type&
      creation_ts_seqno ();

      void
      creation_ts_seqno (const creation_ts_seqno::type&);

      // expiration
      // 
      public:
      struct expiration
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const expiration::type&
      expiration () const;

      expiration::type&
      expiration ();

      void
      expiration (const expiration::type&);

      // orig_length
      // 
      public:
      struct orig_length
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const orig_length::type&
      orig_length () const;

      orig_length::type&
      orig_length ();

      void
      orig_length (const orig_length::type&);

      // frag_offset
      // 
      public:
      struct frag_offset
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const frag_offset::type&
      frag_offset () const;

      frag_offset::type&
      frag_offset ();

      void
      frag_offset (const frag_offset::type&);

      // owner
      // 
      public:
      struct owner
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const owner::type&
      owner () const;

      owner::type&
      owner ();

      void
      owner (const owner::type&);

      void
      owner (::std::auto_ptr< owner::type >);

      // Constructors.
      //
      public:
      bundleType_base ();

      bundleType_base (const source::type&,
                       const dest::type&,
                       const custodian::type&,
                       const replyto::type&,
                       const prevhop::type&,
                       const length::type&,
                       const location::type&,
                       const bundleid::type&,
                       const is_fragment::type&,
                       const is_admin::type&,
                       const do_not_fragment::type&,
                       const priority::type&,
                       const custody_requested::type&,
                       const local_custody::type&,
                       const singleton_dest::type&,
                       const custody_rcpt::type&,
                       const receive_rcpt::type&,
                       const forward_rcpt::type&,
                       const delivery_rcpt::type&,
                       const deletion_rcpt::type&,
                       const app_acked_rcpt::type&,
                       const creation_ts_seconds::type&,
                       const creation_ts_seqno::type&,
                       const expiration::type&,
                       const orig_length::type&,
                       const frag_offset::type&,
                       const owner::type&);

      bundleType_base (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      bundleType_base (const bundleType_base&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual bundleType_base*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< source::type > _xsd_source_;
      ::xsd::cxx::tree::one< dest::type > _xsd_dest_;
      ::xsd::cxx::tree::one< custodian::type > _xsd_custodian_;
      ::xsd::cxx::tree::one< replyto::type > _xsd_replyto_;
      ::xsd::cxx::tree::one< prevhop::type > _xsd_prevhop_;
      ::xsd::cxx::tree::one< length::type > _xsd_length_;
      ::xsd::cxx::tree::one< location::type > _xsd_location_;
      ::xsd::cxx::tree::optional< payload::type > _xsd_payload_;
      ::xsd::cxx::tree::optional< recv_blocks::type > _xsd_recv_blocks_;
      ::xsd::cxx::tree::optional< api_blocks::type > _xsd_api_blocks_;
      ::xsd::cxx::tree::one< bundleid::type > _xsd_bundleid_;
      ::xsd::cxx::tree::one< is_fragment::type > _xsd_is_fragment_;
      ::xsd::cxx::tree::one< is_admin::type > _xsd_is_admin_;
      ::xsd::cxx::tree::one< do_not_fragment::type > _xsd_do_not_fragment_;
      ::xsd::cxx::tree::one< priority::type > _xsd_priority_;
      ::xsd::cxx::tree::one< custody_requested::type > _xsd_custody_requested_;
      ::xsd::cxx::tree::one< local_custody::type > _xsd_local_custody_;
      ::xsd::cxx::tree::one< singleton_dest::type > _xsd_singleton_dest_;
      ::xsd::cxx::tree::one< custody_rcpt::type > _xsd_custody_rcpt_;
      ::xsd::cxx::tree::one< receive_rcpt::type > _xsd_receive_rcpt_;
      ::xsd::cxx::tree::one< forward_rcpt::type > _xsd_forward_rcpt_;
      ::xsd::cxx::tree::one< delivery_rcpt::type > _xsd_delivery_rcpt_;
      ::xsd::cxx::tree::one< deletion_rcpt::type > _xsd_deletion_rcpt_;
      ::xsd::cxx::tree::one< app_acked_rcpt::type > _xsd_app_acked_rcpt_;
      ::xsd::cxx::tree::one< creation_ts_seconds::type > _xsd_creation_ts_seconds_;
      ::xsd::cxx::tree::one< creation_ts_seqno::type > _xsd_creation_ts_seqno_;
      ::xsd::cxx::tree::one< expiration::type > _xsd_expiration_;
      ::xsd::cxx::tree::one< orig_length::type > _xsd_orig_length_;
      ::xsd::cxx::tree::one< frag_offset::type > _xsd_frag_offset_;
      ::xsd::cxx::tree::one< owner::type > _xsd_owner_;
    };

    class contactType_base: public ::xml_schema::type
    {
      public:

      struct _xsd_contactType_base
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // start_time_sec
      // 
      public:
      struct start_time_sec
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const start_time_sec::type&
      start_time_sec () const;

      start_time_sec::type&
      start_time_sec ();

      void
      start_time_sec (const start_time_sec::type&);

      // start_time_usec
      // 
      public:
      struct start_time_usec
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const start_time_usec::type&
      start_time_usec () const;

      start_time_usec::type&
      start_time_usec ();

      void
      start_time_usec (const start_time_usec::type&);

      // duration
      // 
      public:
      struct duration
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const duration::type&
      duration () const;

      duration::type&
      duration ();

      void
      duration (const duration::type&);

      // bps
      // 
      public:
      struct bps
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bps::type&
      bps () const;

      bps::type&
      bps ();

      void
      bps (const bps::type&);

      // latency
      // 
      public:
      struct latency
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const latency::type&
      latency () const;

      latency::type&
      latency ();

      void
      latency (const latency::type&);

      // Constructors.
      //
      public:
      contactType_base ();

      contactType_base (const link::type&,
                        const start_time_sec::type&,
                        const start_time_usec::type&,
                        const duration::type&,
                        const bps::type&,
                        const latency::type&);

      contactType_base (const ::xercesc::DOMElement&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

      contactType_base (const contactType_base&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

      virtual contactType_base*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::one< start_time_sec::type > _xsd_start_time_sec_;
      ::xsd::cxx::tree::one< start_time_usec::type > _xsd_start_time_usec_;
      ::xsd::cxx::tree::one< duration::type > _xsd_duration_;
      ::xsd::cxx::tree::one< bps::type > _xsd_bps_;
      ::xsd::cxx::tree::one< latency::type > _xsd_latency_;
    };

    class clInfoType: public ::xml_schema::type
    {
      public:

      struct _xsd_clInfoType
      {
        typedef ::xml_schema::type base_;
      };

      // local_addr
      // 
      public:
      struct local_addr
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const local_addr::container&
      local_addr () const;

      local_addr::container&
      local_addr ();

      void
      local_addr (const local_addr::type&);

      void
      local_addr (const local_addr::container&);

      void
      local_addr (::std::auto_ptr< local_addr::type >);

      // remote_addr
      // 
      public:
      struct remote_addr
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const remote_addr::container&
      remote_addr () const;

      remote_addr::container&
      remote_addr ();

      void
      remote_addr (const remote_addr::type&);

      void
      remote_addr (const remote_addr::container&);

      void
      remote_addr (::std::auto_ptr< remote_addr::type >);

      // local_port
      // 
      public:
      struct local_port
      {
        typedef ::xml_schema::unsigned_short type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const local_port::container&
      local_port () const;

      local_port::container&
      local_port ();

      void
      local_port (const local_port::type&);

      void
      local_port (const local_port::container&);

      // remote_port
      // 
      public:
      struct remote_port
      {
        typedef ::xml_schema::unsigned_short type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const remote_port::container&
      remote_port () const;

      remote_port::container&
      remote_port ();

      void
      remote_port (const remote_port::type&);

      void
      remote_port (const remote_port::container&);

      // segment_ack_enabled
      // 
      public:
      struct segment_ack_enabled
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const segment_ack_enabled::container&
      segment_ack_enabled () const;

      segment_ack_enabled::container&
      segment_ack_enabled ();

      void
      segment_ack_enabled (const segment_ack_enabled::type&);

      void
      segment_ack_enabled (const segment_ack_enabled::container&);

      // negative_ack_enabled
      // 
      public:
      struct negative_ack_enabled
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const negative_ack_enabled::container&
      negative_ack_enabled () const;

      negative_ack_enabled::container&
      negative_ack_enabled ();

      void
      negative_ack_enabled (const negative_ack_enabled::type&);

      void
      negative_ack_enabled (const negative_ack_enabled::container&);

      // keepalive_interval
      // 
      public:
      struct keepalive_interval
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const keepalive_interval::container&
      keepalive_interval () const;

      keepalive_interval::container&
      keepalive_interval ();

      void
      keepalive_interval (const keepalive_interval::type&);

      void
      keepalive_interval (const keepalive_interval::container&);

      // segment_length
      // 
      public:
      struct segment_length
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const segment_length::container&
      segment_length () const;

      segment_length::container&
      segment_length ();

      void
      segment_length (const segment_length::type&);

      void
      segment_length (const segment_length::container&);

      // busy_queue_depth
      // 
      public:
      struct busy_queue_depth
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const busy_queue_depth::container&
      busy_queue_depth () const;

      busy_queue_depth::container&
      busy_queue_depth ();

      void
      busy_queue_depth (const busy_queue_depth::type&);

      void
      busy_queue_depth (const busy_queue_depth::container&);

      // reactive_frag_enabled
      // 
      public:
      struct reactive_frag_enabled
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const reactive_frag_enabled::container&
      reactive_frag_enabled () const;

      reactive_frag_enabled::container&
      reactive_frag_enabled ();

      void
      reactive_frag_enabled (const reactive_frag_enabled::type&);

      void
      reactive_frag_enabled (const reactive_frag_enabled::container&);

      // sendbuf_length
      // 
      public:
      struct sendbuf_length
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const sendbuf_length::container&
      sendbuf_length () const;

      sendbuf_length::container&
      sendbuf_length ();

      void
      sendbuf_length (const sendbuf_length::type&);

      void
      sendbuf_length (const sendbuf_length::container&);

      // recvbuf_length
      // 
      public:
      struct recvbuf_length
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const recvbuf_length::container&
      recvbuf_length () const;

      recvbuf_length::container&
      recvbuf_length ();

      void
      recvbuf_length (const recvbuf_length::type&);

      void
      recvbuf_length (const recvbuf_length::container&);

      // data_timeout
      // 
      public:
      struct data_timeout
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const data_timeout::container&
      data_timeout () const;

      data_timeout::container&
      data_timeout ();

      void
      data_timeout (const data_timeout::type&);

      void
      data_timeout (const data_timeout::container&);

      // rate
      // 
      public:
      struct rate
      {
        typedef ::xml_schema::unsigned_byte type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const rate::container&
      rate () const;

      rate::container&
      rate ();

      void
      rate (const rate::type&);

      void
      rate (const rate::container&);

      // bucket_depth
      // 
      public:
      struct bucket_depth
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bucket_depth::container&
      bucket_depth () const;

      bucket_depth::container&
      bucket_depth ();

      void
      bucket_depth (const bucket_depth::type&);

      void
      bucket_depth (const bucket_depth::container&);

      // channel
      // 
      public:
      struct channel
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const channel::container&
      channel () const;

      channel::container&
      channel ();

      void
      channel (const channel::type&);

      void
      channel (const channel::container&);

      // Constructors.
      //
      public:
      clInfoType ();

      clInfoType (const ::xercesc::DOMElement&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

      clInfoType (const clInfoType&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

      virtual clInfoType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< local_addr::type > _xsd_local_addr_;
      ::xsd::cxx::tree::optional< remote_addr::type > _xsd_remote_addr_;
      ::xsd::cxx::tree::optional< local_port::type > _xsd_local_port_;
      ::xsd::cxx::tree::optional< remote_port::type > _xsd_remote_port_;
      ::xsd::cxx::tree::optional< segment_ack_enabled::type > _xsd_segment_ack_enabled_;
      ::xsd::cxx::tree::optional< negative_ack_enabled::type > _xsd_negative_ack_enabled_;
      ::xsd::cxx::tree::optional< keepalive_interval::type > _xsd_keepalive_interval_;
      ::xsd::cxx::tree::optional< segment_length::type > _xsd_segment_length_;
      ::xsd::cxx::tree::optional< busy_queue_depth::type > _xsd_busy_queue_depth_;
      ::xsd::cxx::tree::optional< reactive_frag_enabled::type > _xsd_reactive_frag_enabled_;
      ::xsd::cxx::tree::optional< sendbuf_length::type > _xsd_sendbuf_length_;
      ::xsd::cxx::tree::optional< recvbuf_length::type > _xsd_recvbuf_length_;
      ::xsd::cxx::tree::optional< data_timeout::type > _xsd_data_timeout_;
      ::xsd::cxx::tree::optional< rate::type > _xsd_rate_;
      ::xsd::cxx::tree::optional< bucket_depth::type > _xsd_bucket_depth_;
      ::xsd::cxx::tree::optional< channel::type > _xsd_channel_;
    };

    class linkType_base: public ::xml_schema::type
    {
      public:

      struct _xsd_linkType_base
      {
        typedef ::xml_schema::type base_;
      };

      // Workaround for g++ bug# 23206.
      //
      public:
      struct type;

      // clinfo
      // 
      public:
      struct clinfo
      {
        typedef ::dtn::rtrmessage::clInfoType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const clinfo::container&
      clinfo () const;

      clinfo::container&
      clinfo ();

      void
      clinfo (const clinfo::type&);

      void
      clinfo (const clinfo::container&);

      void
      clinfo (::std::auto_ptr< clinfo::type >);

      // remote_eid
      // 
      public:
      struct remote_eid
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const remote_eid::type&
      remote_eid () const;

      remote_eid::type&
      remote_eid ();

      void
      remote_eid (const remote_eid::type&);

      void
      remote_eid (::std::auto_ptr< remote_eid::type >);

      // type
      // 
      public:
      struct type
      {
        typedef ::dtn::rtrmessage::linkTypeType type_;
        typedef ::xsd::cxx::tree::traits< type_, char > traits;
      };

      const type::type_&
      type () const;

      type::type_&
      type ();

      void
      type (const type::type_&);

      void
      type (::std::auto_ptr< type::type_ >);

      // nexthop
      // 
      public:
      struct nexthop
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const nexthop::type&
      nexthop () const;

      nexthop::type&
      nexthop ();

      void
      nexthop (const nexthop::type&);

      void
      nexthop (::std::auto_ptr< nexthop::type >);

      // name
      // 
      public:
      struct name
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const name::type&
      name () const;

      name::type&
      name ();

      void
      name (const name::type&);

      void
      name (::std::auto_ptr< name::type >);

      // state
      // 
      public:
      struct state
      {
        typedef ::dtn::rtrmessage::linkStateType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const state::type&
      state () const;

      state::type&
      state ();

      void
      state (const state::type&);

      void
      state (::std::auto_ptr< state::type >);

      // reliable
      // 
      public:
      struct reliable
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reliable::type&
      reliable () const;

      reliable::type&
      reliable ();

      void
      reliable (const reliable::type&);

      // clayer
      // 
      public:
      struct clayer
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const clayer::type&
      clayer () const;

      clayer::type&
      clayer ();

      void
      clayer (const clayer::type&);

      void
      clayer (::std::auto_ptr< clayer::type >);

      // min_retry_interval
      // 
      public:
      struct min_retry_interval
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const min_retry_interval::type&
      min_retry_interval () const;

      min_retry_interval::type&
      min_retry_interval ();

      void
      min_retry_interval (const min_retry_interval::type&);

      // max_retry_interval
      // 
      public:
      struct max_retry_interval
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const max_retry_interval::type&
      max_retry_interval () const;

      max_retry_interval::type&
      max_retry_interval ();

      void
      max_retry_interval (const max_retry_interval::type&);

      // idle_close_time
      // 
      public:
      struct idle_close_time
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const idle_close_time::type&
      idle_close_time () const;

      idle_close_time::type&
      idle_close_time ();

      void
      idle_close_time (const idle_close_time::type&);

      // Constructors.
      //
      public:
      linkType_base ();

      linkType_base (const remote_eid::type&,
                     const type::type_&,
                     const nexthop::type&,
                     const name::type&,
                     const state::type&,
                     const reliable::type&,
                     const clayer::type&,
                     const min_retry_interval::type&,
                     const max_retry_interval::type&,
                     const idle_close_time::type&);

      linkType_base (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      linkType_base (const linkType_base&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual linkType_base*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< clinfo::type > _xsd_clinfo_;
      ::xsd::cxx::tree::one< remote_eid::type > _xsd_remote_eid_;
      ::xsd::cxx::tree::one< type::type_ > _xsd_type_;
      ::xsd::cxx::tree::one< nexthop::type > _xsd_nexthop_;
      ::xsd::cxx::tree::one< name::type > _xsd_name_;
      ::xsd::cxx::tree::one< state::type > _xsd_state_;
      ::xsd::cxx::tree::one< reliable::type > _xsd_reliable_;
      ::xsd::cxx::tree::one< clayer::type > _xsd_clayer_;
      ::xsd::cxx::tree::one< min_retry_interval::type > _xsd_min_retry_interval_;
      ::xsd::cxx::tree::one< max_retry_interval::type > _xsd_max_retry_interval_;
      ::xsd::cxx::tree::one< idle_close_time::type > _xsd_idle_close_time_;
    };

    class routeEntryType_base: public ::xml_schema::type
    {
      public:

      struct _xsd_routeEntryType_base
      {
        typedef ::xml_schema::type base_;
      };

      // dest_pattern
      // 
      public:
      struct dest_pattern
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const dest_pattern::type&
      dest_pattern () const;

      dest_pattern::type&
      dest_pattern ();

      void
      dest_pattern (const dest_pattern::type&);

      void
      dest_pattern (::std::auto_ptr< dest_pattern::type >);

      // source_pattern
      // 
      public:
      struct source_pattern
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const source_pattern::type&
      source_pattern () const;

      source_pattern::type&
      source_pattern ();

      void
      source_pattern (const source_pattern::type&);

      void
      source_pattern (::std::auto_ptr< source_pattern::type >);

      // route_priority
      // 
      public:
      struct route_priority
      {
        typedef ::xml_schema::integer type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const route_priority::type&
      route_priority () const;

      route_priority::type&
      route_priority ();

      void
      route_priority (const route_priority::type&);

      // action
      // 
      public:
      struct action
      {
        typedef ::dtn::rtrmessage::bundleForwardActionType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const action::type&
      action () const;

      action::type&
      action ();

      void
      action (const action::type&);

      void
      action (::std::auto_ptr< action::type >);

      // link
      // 
      public:
      struct link
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // Constructors.
      //
      public:
      routeEntryType_base ();

      routeEntryType_base (const dest_pattern::type&,
                           const source_pattern::type&,
                           const route_priority::type&,
                           const action::type&,
                           const link::type&);

      routeEntryType_base (const ::xercesc::DOMElement&,
                           ::xml_schema::flags = 0,
                           ::xml_schema::type* = 0);

      routeEntryType_base (const routeEntryType_base&,
                           ::xml_schema::flags = 0,
                           ::xml_schema::type* = 0);

      virtual routeEntryType_base*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< dest_pattern::type > _xsd_dest_pattern_;
      ::xsd::cxx::tree::one< source_pattern::type > _xsd_source_pattern_;
      ::xsd::cxx::tree::one< route_priority::type > _xsd_route_priority_;
      ::xsd::cxx::tree::one< action::type > _xsd_action_;
      ::xsd::cxx::tree::one< link::type > _xsd_link_;
    };

    class registrationType_base: public ::xml_schema::type
    {
      public:

      struct _xsd_registrationType_base
      {
        typedef ::xml_schema::type base_;
      };

      // endpoint
      // 
      public:
      struct endpoint
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const endpoint::type&
      endpoint () const;

      endpoint::type&
      endpoint ();

      void
      endpoint (const endpoint::type&);

      void
      endpoint (::std::auto_ptr< endpoint::type >);

      // regid
      // 
      public:
      struct regid
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const regid::type&
      regid () const;

      regid::type&
      regid ();

      void
      regid (const regid::type&);

      // action
      // 
      public:
      struct action
      {
        typedef ::dtn::rtrmessage::failureActionType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const action::type&
      action () const;

      action::type&
      action ();

      void
      action (const action::type&);

      void
      action (::std::auto_ptr< action::type >);

      // script
      // 
      public:
      struct script
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const script::type&
      script () const;

      script::type&
      script ();

      void
      script (const script::type&);

      void
      script (::std::auto_ptr< script::type >);

      // expiration
      // 
      public:
      struct expiration
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const expiration::type&
      expiration () const;

      expiration::type&
      expiration ();

      void
      expiration (const expiration::type&);

      // Constructors.
      //
      public:
      registrationType_base ();

      registrationType_base (const endpoint::type&,
                             const regid::type&,
                             const action::type&,
                             const script::type&,
                             const expiration::type&);

      registrationType_base (const ::xercesc::DOMElement&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      registrationType_base (const registrationType_base&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      virtual registrationType_base*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< endpoint::type > _xsd_endpoint_;
      ::xsd::cxx::tree::one< regid::type > _xsd_regid_;
      ::xsd::cxx::tree::one< action::type > _xsd_action_;
      ::xsd::cxx::tree::one< script::type > _xsd_script_;
      ::xsd::cxx::tree::one< expiration::type > _xsd_expiration_;
    };

    class bundle_received_event: public ::xml_schema::type
    {
      public:

      struct _xsd_bundle_received_event
      {
        typedef ::xml_schema::type base_;
      };

      // bundle
      // 
      public:
      struct bundle
      {
        typedef ::dtn::rtrmessage::bundleType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundle::type&
      bundle () const;

      bundle::type&
      bundle ();

      void
      bundle (const bundle::type&);

      void
      bundle (::std::auto_ptr< bundle::type >);

      // source
      // 
      public:
      struct source
      {
        typedef ::dtn::rtrmessage::eventSourceType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const source::type&
      source () const;

      source::type&
      source ();

      void
      source (const source::type&);

      void
      source (::std::auto_ptr< source::type >);

      // bytes_received
      // 
      public:
      struct bytes_received
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bytes_received::type&
      bytes_received () const;

      bytes_received::type&
      bytes_received ();

      void
      bytes_received (const bytes_received::type&);

      // Constructors.
      //
      public:
      bundle_received_event ();

      bundle_received_event (const bundle::type&,
                             const source::type&,
                             const bytes_received::type&);

      bundle_received_event (const ::xercesc::DOMElement&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      bundle_received_event (const bundle_received_event&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      virtual bundle_received_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundle::type > _xsd_bundle_;
      ::xsd::cxx::tree::one< source::type > _xsd_source_;
      ::xsd::cxx::tree::one< bytes_received::type > _xsd_bytes_received_;
    };

    class bundle_transmitted_event: public ::xml_schema::type
    {
      public:

      struct _xsd_bundle_transmitted_event
      {
        typedef ::xml_schema::type base_;
      };

      // bundle
      // 
      public:
      struct bundle
      {
        typedef ::dtn::rtrmessage::bundleType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundle::type&
      bundle () const;

      bundle::type&
      bundle ();

      void
      bundle (const bundle::type&);

      void
      bundle (::std::auto_ptr< bundle::type >);

      // contact
      // 
      public:
      struct contact
      {
        typedef ::dtn::rtrmessage::contactType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const contact::type&
      contact () const;

      contact::type&
      contact ();

      void
      contact (const contact::type&);

      void
      contact (::std::auto_ptr< contact::type >);

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // bytes_sent
      // 
      public:
      struct bytes_sent
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bytes_sent::type&
      bytes_sent () const;

      bytes_sent::type&
      bytes_sent ();

      void
      bytes_sent (const bytes_sent::type&);

      // reliably_sent
      // 
      public:
      struct reliably_sent
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reliably_sent::type&
      reliably_sent () const;

      reliably_sent::type&
      reliably_sent ();

      void
      reliably_sent (const reliably_sent::type&);

      // Constructors.
      //
      public:
      bundle_transmitted_event ();

      bundle_transmitted_event (const bundle::type&,
                                const contact::type&,
                                const link::type&,
                                const bytes_sent::type&,
                                const reliably_sent::type&);

      bundle_transmitted_event (const ::xercesc::DOMElement&,
                                ::xml_schema::flags = 0,
                                ::xml_schema::type* = 0);

      bundle_transmitted_event (const bundle_transmitted_event&,
                                ::xml_schema::flags = 0,
                                ::xml_schema::type* = 0);

      virtual bundle_transmitted_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundle::type > _xsd_bundle_;
      ::xsd::cxx::tree::one< contact::type > _xsd_contact_;
      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::one< bytes_sent::type > _xsd_bytes_sent_;
      ::xsd::cxx::tree::one< reliably_sent::type > _xsd_reliably_sent_;
    };

    class bundle_transmit_failed_event: public ::xml_schema::type
    {
      public:

      struct _xsd_bundle_transmit_failed_event
      {
        typedef ::xml_schema::type base_;
      };

      // bundle
      // 
      public:
      struct bundle
      {
        typedef ::dtn::rtrmessage::bundleType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundle::type&
      bundle () const;

      bundle::type&
      bundle ();

      void
      bundle (const bundle::type&);

      void
      bundle (::std::auto_ptr< bundle::type >);

      // contact
      // 
      public:
      struct contact
      {
        typedef ::dtn::rtrmessage::contactType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const contact::type&
      contact () const;

      contact::type&
      contact ();

      void
      contact (const contact::type&);

      void
      contact (::std::auto_ptr< contact::type >);

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // Constructors.
      //
      public:
      bundle_transmit_failed_event ();

      bundle_transmit_failed_event (const bundle::type&,
                                    const contact::type&,
                                    const link::type&);

      bundle_transmit_failed_event (const ::xercesc::DOMElement&,
                                    ::xml_schema::flags = 0,
                                    ::xml_schema::type* = 0);

      bundle_transmit_failed_event (const bundle_transmit_failed_event&,
                                    ::xml_schema::flags = 0,
                                    ::xml_schema::type* = 0);

      virtual bundle_transmit_failed_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundle::type > _xsd_bundle_;
      ::xsd::cxx::tree::one< contact::type > _xsd_contact_;
      ::xsd::cxx::tree::one< link::type > _xsd_link_;
    };

    class bundle_delivery_event: public ::xml_schema::type
    {
      public:

      struct _xsd_bundle_delivery_event
      {
        typedef ::xml_schema::type base_;
      };

      // bundle
      // 
      public:
      struct bundle
      {
        typedef ::dtn::rtrmessage::bundleType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundle::type&
      bundle () const;

      bundle::type&
      bundle ();

      void
      bundle (const bundle::type&);

      void
      bundle (::std::auto_ptr< bundle::type >);

      // source
      // 
      public:
      struct source
      {
        typedef ::dtn::rtrmessage::eventSourceType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const source::type&
      source () const;

      source::type&
      source ();

      void
      source (const source::type&);

      void
      source (::std::auto_ptr< source::type >);

      // Constructors.
      //
      public:
      bundle_delivery_event ();

      bundle_delivery_event (const bundle::type&,
                             const source::type&);

      bundle_delivery_event (const ::xercesc::DOMElement&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      bundle_delivery_event (const bundle_delivery_event&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      virtual bundle_delivery_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundle::type > _xsd_bundle_;
      ::xsd::cxx::tree::one< source::type > _xsd_source_;
    };

    class bundle_expired_event: public ::xml_schema::type
    {
      public:

      struct _xsd_bundle_expired_event
      {
        typedef ::xml_schema::type base_;
      };

      // bundle
      // 
      public:
      struct bundle
      {
        typedef ::dtn::rtrmessage::bundleType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundle::type&
      bundle () const;

      bundle::type&
      bundle ();

      void
      bundle (const bundle::type&);

      void
      bundle (::std::auto_ptr< bundle::type >);

      // Constructors.
      //
      public:
      bundle_expired_event ();

      bundle_expired_event (const bundle::type&);

      bundle_expired_event (const ::xercesc::DOMElement&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

      bundle_expired_event (const bundle_expired_event&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

      virtual bundle_expired_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundle::type > _xsd_bundle_;
    };

    class contact_up_event: public ::xml_schema::type
    {
      public:

      struct _xsd_contact_up_event
      {
        typedef ::xml_schema::type base_;
      };

      // contact
      // 
      public:
      struct contact
      {
        typedef ::dtn::rtrmessage::contactType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const contact::type&
      contact () const;

      contact::type&
      contact ();

      void
      contact (const contact::type&);

      void
      contact (::std::auto_ptr< contact::type >);

      // Constructors.
      //
      public:
      contact_up_event ();

      contact_up_event (const contact::type&);

      contact_up_event (const ::xercesc::DOMElement&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

      contact_up_event (const contact_up_event&,
                        ::xml_schema::flags = 0,
                        ::xml_schema::type* = 0);

      virtual contact_up_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< contact::type > _xsd_contact_;
    };

    class contact_down_event: public ::xml_schema::type
    {
      public:

      struct _xsd_contact_down_event
      {
        typedef ::xml_schema::type base_;
      };

      // contact
      // 
      public:
      struct contact
      {
        typedef ::dtn::rtrmessage::contactType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const contact::type&
      contact () const;

      contact::type&
      contact ();

      void
      contact (const contact::type&);

      void
      contact (::std::auto_ptr< contact::type >);

      // reason
      // 
      public:
      struct reason
      {
        typedef ::dtn::rtrmessage::contactReasonType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reason::type&
      reason () const;

      reason::type&
      reason ();

      void
      reason (const reason::type&);

      void
      reason (::std::auto_ptr< reason::type >);

      // Constructors.
      //
      public:
      contact_down_event ();

      contact_down_event (const contact::type&,
                          const reason::type&);

      contact_down_event (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      contact_down_event (const contact_down_event&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual contact_down_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< contact::type > _xsd_contact_;
      ::xsd::cxx::tree::one< reason::type > _xsd_reason_;
    };

    class link_created_event: public ::xml_schema::type
    {
      public:

      struct _xsd_link_created_event
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // reason
      // 
      public:
      struct reason
      {
        typedef ::dtn::rtrmessage::contactReasonType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reason::type&
      reason () const;

      reason::type&
      reason ();

      void
      reason (const reason::type&);

      void
      reason (::std::auto_ptr< reason::type >);

      // Constructors.
      //
      public:
      link_created_event ();

      link_created_event (const link::type&,
                          const reason::type&);

      link_created_event (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      link_created_event (const link_created_event&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual link_created_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::one< reason::type > _xsd_reason_;
    };

    class link_deleted_event: public ::xml_schema::type
    {
      public:

      struct _xsd_link_deleted_event
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // reason
      // 
      public:
      struct reason
      {
        typedef ::dtn::rtrmessage::contactReasonType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reason::type&
      reason () const;

      reason::type&
      reason ();

      void
      reason (const reason::type&);

      void
      reason (::std::auto_ptr< reason::type >);

      // Constructors.
      //
      public:
      link_deleted_event ();

      link_deleted_event (const link::type&,
                          const reason::type&);

      link_deleted_event (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      link_deleted_event (const link_deleted_event&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual link_deleted_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::one< reason::type > _xsd_reason_;
    };

    class link_available_event: public ::xml_schema::type
    {
      public:

      struct _xsd_link_available_event
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // reason
      // 
      public:
      struct reason
      {
        typedef ::dtn::rtrmessage::contactReasonType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reason::type&
      reason () const;

      reason::type&
      reason ();

      void
      reason (const reason::type&);

      void
      reason (::std::auto_ptr< reason::type >);

      // Constructors.
      //
      public:
      link_available_event ();

      link_available_event (const link::type&,
                            const reason::type&);

      link_available_event (const ::xercesc::DOMElement&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

      link_available_event (const link_available_event&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

      virtual link_available_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::one< reason::type > _xsd_reason_;
    };

    class link_unavailable_event: public ::xml_schema::type
    {
      public:

      struct _xsd_link_unavailable_event
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // reason
      // 
      public:
      struct reason
      {
        typedef ::dtn::rtrmessage::contactReasonType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reason::type&
      reason () const;

      reason::type&
      reason ();

      void
      reason (const reason::type&);

      void
      reason (::std::auto_ptr< reason::type >);

      // Constructors.
      //
      public:
      link_unavailable_event ();

      link_unavailable_event (const link::type&,
                              const reason::type&);

      link_unavailable_event (const ::xercesc::DOMElement&,
                              ::xml_schema::flags = 0,
                              ::xml_schema::type* = 0);

      link_unavailable_event (const link_unavailable_event&,
                              ::xml_schema::flags = 0,
                              ::xml_schema::type* = 0);

      virtual link_unavailable_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::one< reason::type > _xsd_reason_;
    };

    class link_busy_event: public ::xml_schema::type
    {
      public:

      struct _xsd_link_busy_event
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // Constructors.
      //
      public:
      link_busy_event ();

      link_busy_event (const link::type&);

      link_busy_event (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      link_busy_event (const link_busy_event&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual link_busy_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< link::type > _xsd_link_;
    };

    class route_add_event: public ::xml_schema::type
    {
      public:

      struct _xsd_route_add_event
      {
        typedef ::xml_schema::type base_;
      };

      // route_entry
      // 
      public:
      struct route_entry
      {
        typedef ::dtn::rtrmessage::routeEntryType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const route_entry::type&
      route_entry () const;

      route_entry::type&
      route_entry ();

      void
      route_entry (const route_entry::type&);

      void
      route_entry (::std::auto_ptr< route_entry::type >);

      // Constructors.
      //
      public:
      route_add_event ();

      route_add_event (const route_entry::type&);

      route_add_event (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      route_add_event (const route_add_event&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual route_add_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< route_entry::type > _xsd_route_entry_;
    };

    class route_delete_event: public ::xml_schema::type
    {
      public:

      struct _xsd_route_delete_event
      {
        typedef ::xml_schema::type base_;
      };

      // dest
      // 
      public:
      struct dest
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const dest::type&
      dest () const;

      dest::type&
      dest ();

      void
      dest (const dest::type&);

      void
      dest (::std::auto_ptr< dest::type >);

      // Constructors.
      //
      public:
      route_delete_event ();

      route_delete_event (const dest::type&);

      route_delete_event (const ::xercesc::DOMElement&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      route_delete_event (const route_delete_event&,
                          ::xml_schema::flags = 0,
                          ::xml_schema::type* = 0);

      virtual route_delete_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< dest::type > _xsd_dest_;
    };

    class custody_signal_event: public ::xml_schema::type
    {
      public:

      struct _xsd_custody_signal_event
      {
        typedef ::xml_schema::type base_;
      };

      // orig_source_eid
      // 
      public:
      struct orig_source_eid
      {
        typedef ::dtn::rtrmessage::eidType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const orig_source_eid::type&
      orig_source_eid () const;

      orig_source_eid::type&
      orig_source_eid ();

      void
      orig_source_eid (const orig_source_eid::type&);

      void
      orig_source_eid (::std::auto_ptr< orig_source_eid::type >);

      // admin_type
      // 
      public:
      struct admin_type
      {
        typedef ::xml_schema::unsigned_byte type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const admin_type::type&
      admin_type () const;

      admin_type::type&
      admin_type ();

      void
      admin_type (const admin_type::type&);

      // admin_flags
      // 
      public:
      struct admin_flags
      {
        typedef ::xml_schema::unsigned_byte type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const admin_flags::type&
      admin_flags () const;

      admin_flags::type&
      admin_flags ();

      void
      admin_flags (const admin_flags::type&);

      // succeeded
      // 
      public:
      struct succeeded
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const succeeded::type&
      succeeded () const;

      succeeded::type&
      succeeded ();

      void
      succeeded (const succeeded::type&);

      // reason
      // 
      public:
      struct reason
      {
        typedef ::xml_schema::unsigned_byte type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const reason::type&
      reason () const;

      reason::type&
      reason ();

      void
      reason (const reason::type&);

      // orig_frag_offset
      // 
      public:
      struct orig_frag_offset
      {
        typedef ::xml_schema::unsigned_long type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const orig_frag_offset::type&
      orig_frag_offset () const;

      orig_frag_offset::type&
      orig_frag_offset ();

      void
      orig_frag_offset (const orig_frag_offset::type&);

      // orig_frag_length
      // 
      public:
      struct orig_frag_length
      {
        typedef ::xml_schema::unsigned_long type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const orig_frag_length::type&
      orig_frag_length () const;

      orig_frag_length::type&
      orig_frag_length ();

      void
      orig_frag_length (const orig_frag_length::type&);

      // custody_signal_seconds
      // 
      public:
      struct custody_signal_seconds
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const custody_signal_seconds::type&
      custody_signal_seconds () const;

      custody_signal_seconds::type&
      custody_signal_seconds ();

      void
      custody_signal_seconds (const custody_signal_seconds::type&);

      // custody_signal_seqno
      // 
      public:
      struct custody_signal_seqno
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const custody_signal_seqno::type&
      custody_signal_seqno () const;

      custody_signal_seqno::type&
      custody_signal_seqno ();

      void
      custody_signal_seqno (const custody_signal_seqno::type&);

      // orig_creation_seconds
      // 
      public:
      struct orig_creation_seconds
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const orig_creation_seconds::type&
      orig_creation_seconds () const;

      orig_creation_seconds::type&
      orig_creation_seconds ();

      void
      orig_creation_seconds (const orig_creation_seconds::type&);

      // orig_creation_seqno
      // 
      public:
      struct orig_creation_seqno
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const orig_creation_seqno::type&
      orig_creation_seqno () const;

      orig_creation_seqno::type&
      orig_creation_seqno ();

      void
      orig_creation_seqno (const orig_creation_seqno::type&);

      // Constructors.
      //
      public:
      custody_signal_event ();

      custody_signal_event (const orig_source_eid::type&,
                            const admin_type::type&,
                            const admin_flags::type&,
                            const succeeded::type&,
                            const reason::type&,
                            const orig_frag_offset::type&,
                            const orig_frag_length::type&,
                            const custody_signal_seconds::type&,
                            const custody_signal_seqno::type&,
                            const orig_creation_seconds::type&,
                            const orig_creation_seqno::type&);

      custody_signal_event (const ::xercesc::DOMElement&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

      custody_signal_event (const custody_signal_event&,
                            ::xml_schema::flags = 0,
                            ::xml_schema::type* = 0);

      virtual custody_signal_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< orig_source_eid::type > _xsd_orig_source_eid_;
      ::xsd::cxx::tree::one< admin_type::type > _xsd_admin_type_;
      ::xsd::cxx::tree::one< admin_flags::type > _xsd_admin_flags_;
      ::xsd::cxx::tree::one< succeeded::type > _xsd_succeeded_;
      ::xsd::cxx::tree::one< reason::type > _xsd_reason_;
      ::xsd::cxx::tree::one< orig_frag_offset::type > _xsd_orig_frag_offset_;
      ::xsd::cxx::tree::one< orig_frag_length::type > _xsd_orig_frag_length_;
      ::xsd::cxx::tree::one< custody_signal_seconds::type > _xsd_custody_signal_seconds_;
      ::xsd::cxx::tree::one< custody_signal_seqno::type > _xsd_custody_signal_seqno_;
      ::xsd::cxx::tree::one< orig_creation_seconds::type > _xsd_orig_creation_seconds_;
      ::xsd::cxx::tree::one< orig_creation_seqno::type > _xsd_orig_creation_seqno_;
    };

    class custody_timeout_event: public ::xml_schema::type
    {
      public:

      struct _xsd_custody_timeout_event
      {
        typedef ::xml_schema::type base_;
      };

      // bundle
      // 
      public:
      struct bundle
      {
        typedef ::dtn::rtrmessage::bundleType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundle::type&
      bundle () const;

      bundle::type&
      bundle ();

      void
      bundle (const bundle::type&);

      void
      bundle (::std::auto_ptr< bundle::type >);

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // Constructors.
      //
      public:
      custody_timeout_event ();

      custody_timeout_event (const bundle::type&,
                             const link::type&);

      custody_timeout_event (const ::xercesc::DOMElement&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      custody_timeout_event (const custody_timeout_event&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      virtual custody_timeout_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundle::type > _xsd_bundle_;
      ::xsd::cxx::tree::one< link::type > _xsd_link_;
    };

    class registration_added_event: public ::xml_schema::type
    {
      public:

      struct _xsd_registration_added_event
      {
        typedef ::xml_schema::type base_;
      };

      // registration
      // 
      public:
      struct registration
      {
        typedef ::dtn::rtrmessage::registrationType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const registration::type&
      registration () const;

      registration::type&
      registration ();

      void
      registration (const registration::type&);

      void
      registration (::std::auto_ptr< registration::type >);

      // source
      // 
      public:
      struct source
      {
        typedef ::dtn::rtrmessage::eventSourceType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const source::type&
      source () const;

      source::type&
      source ();

      void
      source (const source::type&);

      void
      source (::std::auto_ptr< source::type >);

      // Constructors.
      //
      public:
      registration_added_event ();

      registration_added_event (const registration::type&,
                                const source::type&);

      registration_added_event (const ::xercesc::DOMElement&,
                                ::xml_schema::flags = 0,
                                ::xml_schema::type* = 0);

      registration_added_event (const registration_added_event&,
                                ::xml_schema::flags = 0,
                                ::xml_schema::type* = 0);

      virtual registration_added_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< registration::type > _xsd_registration_;
      ::xsd::cxx::tree::one< source::type > _xsd_source_;
    };

    class registration_removed_event: public ::xml_schema::type
    {
      public:

      struct _xsd_registration_removed_event
      {
        typedef ::xml_schema::type base_;
      };

      // registration
      // 
      public:
      struct registration
      {
        typedef ::dtn::rtrmessage::registrationType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const registration::type&
      registration () const;

      registration::type&
      registration ();

      void
      registration (const registration::type&);

      void
      registration (::std::auto_ptr< registration::type >);

      // Constructors.
      //
      public:
      registration_removed_event ();

      registration_removed_event (const registration::type&);

      registration_removed_event (const ::xercesc::DOMElement&,
                                  ::xml_schema::flags = 0,
                                  ::xml_schema::type* = 0);

      registration_removed_event (const registration_removed_event&,
                                  ::xml_schema::flags = 0,
                                  ::xml_schema::type* = 0);

      virtual registration_removed_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< registration::type > _xsd_registration_;
    };

    class registration_expired_event: public ::xml_schema::type
    {
      public:

      struct _xsd_registration_expired_event
      {
        typedef ::xml_schema::type base_;
      };

      // regid
      // 
      public:
      struct regid
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const regid::type&
      regid () const;

      regid::type&
      regid ();

      void
      regid (const regid::type&);

      // Constructors.
      //
      public:
      registration_expired_event ();

      registration_expired_event (const regid::type&);

      registration_expired_event (const ::xercesc::DOMElement&,
                                  ::xml_schema::flags = 0,
                                  ::xml_schema::type* = 0);

      registration_expired_event (const registration_expired_event&,
                                  ::xml_schema::flags = 0,
                                  ::xml_schema::type* = 0);

      virtual registration_expired_event*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< regid::type > _xsd_regid_;
    };

    class open_link_request: public ::xml_schema::type
    {
      public:

      struct _xsd_open_link_request
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // Constructors.
      //
      public:
      open_link_request ();

      open_link_request (const link::type&);

      open_link_request (const ::xercesc::DOMElement&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      open_link_request (const open_link_request&,
                         ::xml_schema::flags = 0,
                         ::xml_schema::type* = 0);

      virtual open_link_request*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< link::type > _xsd_link_;
    };

    class send_bundle_request: public ::xml_schema::type
    {
      public:

      struct _xsd_send_bundle_request
      {
        typedef ::xml_schema::type base_;
      };

      // bundleid
      // 
      public:
      struct bundleid
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundleid::type&
      bundleid () const;

      bundleid::type&
      bundleid ();

      void
      bundleid (const bundleid::type&);

      // link
      // 
      public:
      struct link
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // fwd_action
      // 
      public:
      struct fwd_action
      {
        typedef ::dtn::rtrmessage::bundleForwardActionType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const fwd_action::type&
      fwd_action () const;

      fwd_action::type&
      fwd_action ();

      void
      fwd_action (const fwd_action::type&);

      void
      fwd_action (::std::auto_ptr< fwd_action::type >);

      // Constructors.
      //
      public:
      send_bundle_request ();

      send_bundle_request (const bundleid::type&,
                           const link::type&,
                           const fwd_action::type&);

      send_bundle_request (const ::xercesc::DOMElement&,
                           ::xml_schema::flags = 0,
                           ::xml_schema::type* = 0);

      send_bundle_request (const send_bundle_request&,
                           ::xml_schema::flags = 0,
                           ::xml_schema::type* = 0);

      virtual send_bundle_request*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundleid::type > _xsd_bundleid_;
      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::one< fwd_action::type > _xsd_fwd_action_;
    };

    class cancel_bundle_request: public ::xml_schema::type
    {
      public:

      struct _xsd_cancel_bundle_request
      {
        typedef ::xml_schema::type base_;
      };

      // bundleid
      // 
      public:
      struct bundleid
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const bundleid::type&
      bundleid () const;

      bundleid::type&
      bundleid ();

      void
      bundleid (const bundleid::type&);

      // link
      // 
      public:
      struct link
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // Constructors.
      //
      public:
      cancel_bundle_request ();

      cancel_bundle_request (const bundleid::type&,
                             const link::type&);

      cancel_bundle_request (const ::xercesc::DOMElement&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      cancel_bundle_request (const cancel_bundle_request&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      virtual cancel_bundle_request*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< bundleid::type > _xsd_bundleid_;
      ::xsd::cxx::tree::one< link::type > _xsd_link_;
    };

    class inject_bundle_request: public ::xml_schema::type
    {
      public:

      struct _xsd_inject_bundle_request
      {
        typedef ::xml_schema::type base_;
      };

      // source
      // 
      public:
      struct source
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const source::type&
      source () const;

      source::type&
      source ();

      void
      source (const source::type&);

      void
      source (::std::auto_ptr< source::type >);

      // dest
      // 
      public:
      struct dest
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const dest::type&
      dest () const;

      dest::type&
      dest ();

      void
      dest (const dest::type&);

      void
      dest (::std::auto_ptr< dest::type >);

      // replyto
      // 
      public:
      struct replyto
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const replyto::container&
      replyto () const;

      replyto::container&
      replyto ();

      void
      replyto (const replyto::type&);

      void
      replyto (const replyto::container&);

      void
      replyto (::std::auto_ptr< replyto::type >);

      // custodian
      // 
      public:
      struct custodian
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const custodian::container&
      custodian () const;

      custodian::container&
      custodian ();

      void
      custodian (const custodian::type&);

      void
      custodian (const custodian::container&);

      void
      custodian (::std::auto_ptr< custodian::type >);

      // link
      // 
      public:
      struct link
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const link::type&
      link () const;

      link::type&
      link ();

      void
      link (const link::type&);

      void
      link (::std::auto_ptr< link::type >);

      // fwd_action
      // 
      public:
      struct fwd_action
      {
        typedef ::dtn::rtrmessage::bundleForwardActionType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const fwd_action::container&
      fwd_action () const;

      fwd_action::container&
      fwd_action ();

      void
      fwd_action (const fwd_action::type&);

      void
      fwd_action (const fwd_action::container&);

      void
      fwd_action (::std::auto_ptr< fwd_action::type >);

      // priority
      // 
      public:
      struct priority
      {
        typedef ::dtn::rtrmessage::bundlePriorityType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const priority::container&
      priority () const;

      priority::container&
      priority ();

      void
      priority (const priority::type&);

      void
      priority (const priority::container&);

      void
      priority (::std::auto_ptr< priority::type >);

      // expiration
      // 
      public:
      struct expiration
      {
        typedef ::xml_schema::unsigned_int type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const expiration::container&
      expiration () const;

      expiration::container&
      expiration ();

      void
      expiration (const expiration::type&);

      void
      expiration (const expiration::container&);

      // payload
      // 
      public:
      struct payload
      {
        typedef ::xml_schema::base64_binary type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
      };

      const payload::type&
      payload () const;

      payload::type&
      payload ();

      void
      payload (const payload::type&);

      void
      payload (::std::auto_ptr< payload::type >);

      // Constructors.
      //
      public:
      inject_bundle_request ();

      inject_bundle_request (const source::type&,
                             const dest::type&,
                             const link::type&,
                             const payload::type&);

      inject_bundle_request (const ::xercesc::DOMElement&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      inject_bundle_request (const inject_bundle_request&,
                             ::xml_schema::flags = 0,
                             ::xml_schema::type* = 0);

      virtual inject_bundle_request*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< source::type > _xsd_source_;
      ::xsd::cxx::tree::one< dest::type > _xsd_dest_;
      ::xsd::cxx::tree::optional< replyto::type > _xsd_replyto_;
      ::xsd::cxx::tree::optional< custodian::type > _xsd_custodian_;
      ::xsd::cxx::tree::one< link::type > _xsd_link_;
      ::xsd::cxx::tree::optional< fwd_action::type > _xsd_fwd_action_;
      ::xsd::cxx::tree::optional< priority::type > _xsd_priority_;
      ::xsd::cxx::tree::optional< expiration::type > _xsd_expiration_;
      ::xsd::cxx::tree::one< payload::type > _xsd_payload_;
    };

    class link_report: public ::xml_schema::type
    {
      public:

      struct _xsd_link_report
      {
        typedef ::xml_schema::type base_;
      };

      // link
      // 
      public:
      struct link
      {
        typedef ::dtn::rtrmessage::linkType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const link::container&
      link () const;

      link::container&
      link ();

      void
      link (const link::container&);

      // Constructors.
      //
      public:
      link_report ();

      link_report (const ::xercesc::DOMElement&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      link_report (const link_report&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      virtual link_report*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< link::type > _xsd_link_;
    };

    class contact_report: public ::xml_schema::type
    {
      public:

      struct _xsd_contact_report
      {
        typedef ::xml_schema::type base_;
      };

      // contact
      // 
      public:
      struct contact
      {
        typedef ::dtn::rtrmessage::contactType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const contact::container&
      contact () const;

      contact::container&
      contact ();

      void
      contact (const contact::container&);

      // Constructors.
      //
      public:
      contact_report ();

      contact_report (const ::xercesc::DOMElement&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      contact_report (const contact_report&,
                      ::xml_schema::flags = 0,
                      ::xml_schema::type* = 0);

      virtual contact_report*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< contact::type > _xsd_contact_;
    };

    class route_report: public ::xml_schema::type
    {
      public:

      struct _xsd_route_report
      {
        typedef ::xml_schema::type base_;
      };

      // route_entry
      // 
      public:
      struct route_entry
      {
        typedef ::dtn::rtrmessage::routeEntryType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const route_entry::container&
      route_entry () const;

      route_entry::container&
      route_entry ();

      void
      route_entry (const route_entry::container&);

      // Constructors.
      //
      public:
      route_report ();

      route_report (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      route_report (const route_report&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      virtual route_report*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< route_entry::type > _xsd_route_entry_;
    };

    class bundle_report: public ::xml_schema::type
    {
      public:

      struct _xsd_bundle_report
      {
        typedef ::xml_schema::type base_;
      };

      // bundle
      // 
      public:
      struct bundle
      {
        typedef ::dtn::rtrmessage::bundleType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const bundle::container&
      bundle () const;

      bundle::container&
      bundle ();

      void
      bundle (const bundle::container&);

      // Constructors.
      //
      public:
      bundle_report ();

      bundle_report (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      bundle_report (const bundle_report&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual bundle_report*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< bundle::type > _xsd_bundle_;
    };

    class dtn: public ::xml_schema::type
    {
      public:

      struct _xsd_dtn
      {
        typedef ::xml_schema::type base_;
      };

      // bundle_received_event
      // 
      public:
      struct bundle_received_event
      {
        typedef ::dtn::rtrmessage::bundle_received_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bundle_received_event::container&
      bundle_received_event () const;

      bundle_received_event::container&
      bundle_received_event ();

      void
      bundle_received_event (const bundle_received_event::type&);

      void
      bundle_received_event (const bundle_received_event::container&);

      void
      bundle_received_event (::std::auto_ptr< bundle_received_event::type >);

      // bundle_transmitted_event
      // 
      public:
      struct bundle_transmitted_event
      {
        typedef ::dtn::rtrmessage::bundle_transmitted_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bundle_transmitted_event::container&
      bundle_transmitted_event () const;

      bundle_transmitted_event::container&
      bundle_transmitted_event ();

      void
      bundle_transmitted_event (const bundle_transmitted_event::type&);

      void
      bundle_transmitted_event (const bundle_transmitted_event::container&);

      void
      bundle_transmitted_event (::std::auto_ptr< bundle_transmitted_event::type >);

      // bundle_transmit_failed_event
      // 
      public:
      struct bundle_transmit_failed_event
      {
        typedef ::dtn::rtrmessage::bundle_transmit_failed_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bundle_transmit_failed_event::container&
      bundle_transmit_failed_event () const;

      bundle_transmit_failed_event::container&
      bundle_transmit_failed_event ();

      void
      bundle_transmit_failed_event (const bundle_transmit_failed_event::type&);

      void
      bundle_transmit_failed_event (const bundle_transmit_failed_event::container&);

      void
      bundle_transmit_failed_event (::std::auto_ptr< bundle_transmit_failed_event::type >);

      // bundle_delivery_event
      // 
      public:
      struct bundle_delivery_event
      {
        typedef ::dtn::rtrmessage::bundle_delivery_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bundle_delivery_event::container&
      bundle_delivery_event () const;

      bundle_delivery_event::container&
      bundle_delivery_event ();

      void
      bundle_delivery_event (const bundle_delivery_event::type&);

      void
      bundle_delivery_event (const bundle_delivery_event::container&);

      void
      bundle_delivery_event (::std::auto_ptr< bundle_delivery_event::type >);

      // bundle_expired_event
      // 
      public:
      struct bundle_expired_event
      {
        typedef ::dtn::rtrmessage::bundle_expired_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bundle_expired_event::container&
      bundle_expired_event () const;

      bundle_expired_event::container&
      bundle_expired_event ();

      void
      bundle_expired_event (const bundle_expired_event::type&);

      void
      bundle_expired_event (const bundle_expired_event::container&);

      void
      bundle_expired_event (::std::auto_ptr< bundle_expired_event::type >);

      // contact_up_event
      // 
      public:
      struct contact_up_event
      {
        typedef ::dtn::rtrmessage::contact_up_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const contact_up_event::container&
      contact_up_event () const;

      contact_up_event::container&
      contact_up_event ();

      void
      contact_up_event (const contact_up_event::type&);

      void
      contact_up_event (const contact_up_event::container&);

      void
      contact_up_event (::std::auto_ptr< contact_up_event::type >);

      // contact_down_event
      // 
      public:
      struct contact_down_event
      {
        typedef ::dtn::rtrmessage::contact_down_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const contact_down_event::container&
      contact_down_event () const;

      contact_down_event::container&
      contact_down_event ();

      void
      contact_down_event (const contact_down_event::type&);

      void
      contact_down_event (const contact_down_event::container&);

      void
      contact_down_event (::std::auto_ptr< contact_down_event::type >);

      // link_created_event
      // 
      public:
      struct link_created_event
      {
        typedef ::dtn::rtrmessage::link_created_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const link_created_event::container&
      link_created_event () const;

      link_created_event::container&
      link_created_event ();

      void
      link_created_event (const link_created_event::type&);

      void
      link_created_event (const link_created_event::container&);

      void
      link_created_event (::std::auto_ptr< link_created_event::type >);

      // link_deleted_event
      // 
      public:
      struct link_deleted_event
      {
        typedef ::dtn::rtrmessage::link_deleted_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const link_deleted_event::container&
      link_deleted_event () const;

      link_deleted_event::container&
      link_deleted_event ();

      void
      link_deleted_event (const link_deleted_event::type&);

      void
      link_deleted_event (const link_deleted_event::container&);

      void
      link_deleted_event (::std::auto_ptr< link_deleted_event::type >);

      // link_available_event
      // 
      public:
      struct link_available_event
      {
        typedef ::dtn::rtrmessage::link_available_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const link_available_event::container&
      link_available_event () const;

      link_available_event::container&
      link_available_event ();

      void
      link_available_event (const link_available_event::type&);

      void
      link_available_event (const link_available_event::container&);

      void
      link_available_event (::std::auto_ptr< link_available_event::type >);

      // link_unavailable_event
      // 
      public:
      struct link_unavailable_event
      {
        typedef ::dtn::rtrmessage::link_unavailable_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const link_unavailable_event::container&
      link_unavailable_event () const;

      link_unavailable_event::container&
      link_unavailable_event ();

      void
      link_unavailable_event (const link_unavailable_event::type&);

      void
      link_unavailable_event (const link_unavailable_event::container&);

      void
      link_unavailable_event (::std::auto_ptr< link_unavailable_event::type >);

      // link_busy_event
      // 
      public:
      struct link_busy_event
      {
        typedef ::dtn::rtrmessage::link_busy_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const link_busy_event::container&
      link_busy_event () const;

      link_busy_event::container&
      link_busy_event ();

      void
      link_busy_event (const link_busy_event::type&);

      void
      link_busy_event (const link_busy_event::container&);

      void
      link_busy_event (::std::auto_ptr< link_busy_event::type >);

      // route_add_event
      // 
      public:
      struct route_add_event
      {
        typedef ::dtn::rtrmessage::route_add_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const route_add_event::container&
      route_add_event () const;

      route_add_event::container&
      route_add_event ();

      void
      route_add_event (const route_add_event::type&);

      void
      route_add_event (const route_add_event::container&);

      void
      route_add_event (::std::auto_ptr< route_add_event::type >);

      // route_delete_event
      // 
      public:
      struct route_delete_event
      {
        typedef ::dtn::rtrmessage::route_delete_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const route_delete_event::container&
      route_delete_event () const;

      route_delete_event::container&
      route_delete_event ();

      void
      route_delete_event (const route_delete_event::type&);

      void
      route_delete_event (const route_delete_event::container&);

      void
      route_delete_event (::std::auto_ptr< route_delete_event::type >);

      // custody_signal_event
      // 
      public:
      struct custody_signal_event
      {
        typedef ::dtn::rtrmessage::custody_signal_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const custody_signal_event::container&
      custody_signal_event () const;

      custody_signal_event::container&
      custody_signal_event ();

      void
      custody_signal_event (const custody_signal_event::type&);

      void
      custody_signal_event (const custody_signal_event::container&);

      void
      custody_signal_event (::std::auto_ptr< custody_signal_event::type >);

      // custody_timeout_event
      // 
      public:
      struct custody_timeout_event
      {
        typedef ::dtn::rtrmessage::custody_timeout_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const custody_timeout_event::container&
      custody_timeout_event () const;

      custody_timeout_event::container&
      custody_timeout_event ();

      void
      custody_timeout_event (const custody_timeout_event::type&);

      void
      custody_timeout_event (const custody_timeout_event::container&);

      void
      custody_timeout_event (::std::auto_ptr< custody_timeout_event::type >);

      // registration_added_event
      // 
      public:
      struct registration_added_event
      {
        typedef ::dtn::rtrmessage::registration_added_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const registration_added_event::container&
      registration_added_event () const;

      registration_added_event::container&
      registration_added_event ();

      void
      registration_added_event (const registration_added_event::type&);

      void
      registration_added_event (const registration_added_event::container&);

      void
      registration_added_event (::std::auto_ptr< registration_added_event::type >);

      // registration_removed_event
      // 
      public:
      struct registration_removed_event
      {
        typedef ::dtn::rtrmessage::registration_removed_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const registration_removed_event::container&
      registration_removed_event () const;

      registration_removed_event::container&
      registration_removed_event ();

      void
      registration_removed_event (const registration_removed_event::type&);

      void
      registration_removed_event (const registration_removed_event::container&);

      void
      registration_removed_event (::std::auto_ptr< registration_removed_event::type >);

      // registration_expired_event
      // 
      public:
      struct registration_expired_event
      {
        typedef ::dtn::rtrmessage::registration_expired_event type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const registration_expired_event::container&
      registration_expired_event () const;

      registration_expired_event::container&
      registration_expired_event ();

      void
      registration_expired_event (const registration_expired_event::type&);

      void
      registration_expired_event (const registration_expired_event::container&);

      void
      registration_expired_event (::std::auto_ptr< registration_expired_event::type >);

      // open_link_request
      // 
      public:
      struct open_link_request
      {
        typedef ::dtn::rtrmessage::open_link_request type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const open_link_request::container&
      open_link_request () const;

      open_link_request::container&
      open_link_request ();

      void
      open_link_request (const open_link_request::type&);

      void
      open_link_request (const open_link_request::container&);

      void
      open_link_request (::std::auto_ptr< open_link_request::type >);

      // send_bundle_request
      // 
      public:
      struct send_bundle_request
      {
        typedef ::dtn::rtrmessage::send_bundle_request type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const send_bundle_request::container&
      send_bundle_request () const;

      send_bundle_request::container&
      send_bundle_request ();

      void
      send_bundle_request (const send_bundle_request::type&);

      void
      send_bundle_request (const send_bundle_request::container&);

      void
      send_bundle_request (::std::auto_ptr< send_bundle_request::type >);

      // cancel_bundle_request
      // 
      public:
      struct cancel_bundle_request
      {
        typedef ::dtn::rtrmessage::cancel_bundle_request type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const cancel_bundle_request::container&
      cancel_bundle_request () const;

      cancel_bundle_request::container&
      cancel_bundle_request ();

      void
      cancel_bundle_request (const cancel_bundle_request::type&);

      void
      cancel_bundle_request (const cancel_bundle_request::container&);

      void
      cancel_bundle_request (::std::auto_ptr< cancel_bundle_request::type >);

      // inject_bundle_request
      // 
      public:
      struct inject_bundle_request
      {
        typedef ::dtn::rtrmessage::inject_bundle_request type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const inject_bundle_request::container&
      inject_bundle_request () const;

      inject_bundle_request::container&
      inject_bundle_request ();

      void
      inject_bundle_request (const inject_bundle_request::type&);

      void
      inject_bundle_request (const inject_bundle_request::container&);

      void
      inject_bundle_request (::std::auto_ptr< inject_bundle_request::type >);

      // link_query
      // 
      public:
      struct link_query
      {
        typedef ::xml_schema::type type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const link_query::container&
      link_query () const;

      link_query::container&
      link_query ();

      void
      link_query (const link_query::type&);

      void
      link_query (const link_query::container&);

      void
      link_query (::std::auto_ptr< link_query::type >);

      // link_report
      // 
      public:
      struct link_report
      {
        typedef ::dtn::rtrmessage::link_report type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const link_report::container&
      link_report () const;

      link_report::container&
      link_report ();

      void
      link_report (const link_report::type&);

      void
      link_report (const link_report::container&);

      void
      link_report (::std::auto_ptr< link_report::type >);

      // contact_query
      // 
      public:
      struct contact_query
      {
        typedef ::xml_schema::type type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const contact_query::container&
      contact_query () const;

      contact_query::container&
      contact_query ();

      void
      contact_query (const contact_query::type&);

      void
      contact_query (const contact_query::container&);

      void
      contact_query (::std::auto_ptr< contact_query::type >);

      // contact_report
      // 
      public:
      struct contact_report
      {
        typedef ::dtn::rtrmessage::contact_report type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const contact_report::container&
      contact_report () const;

      contact_report::container&
      contact_report ();

      void
      contact_report (const contact_report::type&);

      void
      contact_report (const contact_report::container&);

      void
      contact_report (::std::auto_ptr< contact_report::type >);

      // route_query
      // 
      public:
      struct route_query
      {
        typedef ::xml_schema::type type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const route_query::container&
      route_query () const;

      route_query::container&
      route_query ();

      void
      route_query (const route_query::type&);

      void
      route_query (const route_query::container&);

      void
      route_query (::std::auto_ptr< route_query::type >);

      // route_report
      // 
      public:
      struct route_report
      {
        typedef ::dtn::rtrmessage::route_report type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const route_report::container&
      route_report () const;

      route_report::container&
      route_report ();

      void
      route_report (const route_report::type&);

      void
      route_report (const route_report::container&);

      void
      route_report (::std::auto_ptr< route_report::type >);

      // bundle_query
      // 
      public:
      struct bundle_query
      {
        typedef ::xml_schema::type type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bundle_query::container&
      bundle_query () const;

      bundle_query::container&
      bundle_query ();

      void
      bundle_query (const bundle_query::type&);

      void
      bundle_query (const bundle_query::container&);

      void
      bundle_query (::std::auto_ptr< bundle_query::type >);

      // bundle_report
      // 
      public:
      struct bundle_report
      {
        typedef ::dtn::rtrmessage::bundle_report type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const bundle_report::container&
      bundle_report () const;

      bundle_report::container&
      bundle_report ();

      void
      bundle_report (const bundle_report::type&);

      void
      bundle_report (const bundle_report::container&);

      void
      bundle_report (::std::auto_ptr< bundle_report::type >);

      // eid
      // 
      public:
      struct eid
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const eid::container&
      eid () const;

      eid::container&
      eid ();

      void
      eid (const eid::type&);

      void
      eid (const eid::container&);

      void
      eid (::std::auto_ptr< eid::type >);

      // hello_interval
      // 
      public:
      struct hello_interval
      {
        typedef ::xml_schema::unsigned_short type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const hello_interval::container&
      hello_interval () const;

      hello_interval::container&
      hello_interval ();

      void
      hello_interval (const hello_interval::type&);

      void
      hello_interval (const hello_interval::container&);

      // alert
      // 
      public:
      struct alert
      {
        typedef ::dtn::rtrmessage::dtnStatusType type;
        typedef ::xsd::cxx::tree::traits< type, char > traits;
        typedef ::xsd::cxx::tree::optional< type > container;
      };

      const alert::container&
      alert () const;

      alert::container&
      alert ();

      void
      alert (const alert::type&);

      void
      alert (const alert::container&);

      void
      alert (::std::auto_ptr< alert::type >);

      // Constructors.
      //
      public:
      dtn ();

      dtn (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

      dtn (const dtn&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

      virtual dtn*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::optional< bundle_received_event::type > _xsd_bundle_received_event_;
      ::xsd::cxx::tree::optional< bundle_transmitted_event::type > _xsd_bundle_transmitted_event_;
      ::xsd::cxx::tree::optional< bundle_transmit_failed_event::type > _xsd_bundle_transmit_failed_event_;
      ::xsd::cxx::tree::optional< bundle_delivery_event::type > _xsd_bundle_delivery_event_;
      ::xsd::cxx::tree::optional< bundle_expired_event::type > _xsd_bundle_expired_event_;
      ::xsd::cxx::tree::optional< contact_up_event::type > _xsd_contact_up_event_;
      ::xsd::cxx::tree::optional< contact_down_event::type > _xsd_contact_down_event_;
      ::xsd::cxx::tree::optional< link_created_event::type > _xsd_link_created_event_;
      ::xsd::cxx::tree::optional< link_deleted_event::type > _xsd_link_deleted_event_;
      ::xsd::cxx::tree::optional< link_available_event::type > _xsd_link_available_event_;
      ::xsd::cxx::tree::optional< link_unavailable_event::type > _xsd_link_unavailable_event_;
      ::xsd::cxx::tree::optional< link_busy_event::type > _xsd_link_busy_event_;
      ::xsd::cxx::tree::optional< route_add_event::type > _xsd_route_add_event_;
      ::xsd::cxx::tree::optional< route_delete_event::type > _xsd_route_delete_event_;
      ::xsd::cxx::tree::optional< custody_signal_event::type > _xsd_custody_signal_event_;
      ::xsd::cxx::tree::optional< custody_timeout_event::type > _xsd_custody_timeout_event_;
      ::xsd::cxx::tree::optional< registration_added_event::type > _xsd_registration_added_event_;
      ::xsd::cxx::tree::optional< registration_removed_event::type > _xsd_registration_removed_event_;
      ::xsd::cxx::tree::optional< registration_expired_event::type > _xsd_registration_expired_event_;
      ::xsd::cxx::tree::optional< open_link_request::type > _xsd_open_link_request_;
      ::xsd::cxx::tree::optional< send_bundle_request::type > _xsd_send_bundle_request_;
      ::xsd::cxx::tree::optional< cancel_bundle_request::type > _xsd_cancel_bundle_request_;
      ::xsd::cxx::tree::optional< inject_bundle_request::type > _xsd_inject_bundle_request_;
      ::xsd::cxx::tree::optional< link_query::type > _xsd_link_query_;
      ::xsd::cxx::tree::optional< link_report::type > _xsd_link_report_;
      ::xsd::cxx::tree::optional< contact_query::type > _xsd_contact_query_;
      ::xsd::cxx::tree::optional< contact_report::type > _xsd_contact_report_;
      ::xsd::cxx::tree::optional< route_query::type > _xsd_route_query_;
      ::xsd::cxx::tree::optional< route_report::type > _xsd_route_report_;
      ::xsd::cxx::tree::optional< bundle_query::type > _xsd_bundle_query_;
      ::xsd::cxx::tree::optional< bundle_report::type > _xsd_bundle_report_;
      ::xsd::cxx::tree::optional< eid::type > _xsd_eid_;
      ::xsd::cxx::tree::optional< hello_interval::type > _xsd_hello_interval_;
      ::xsd::cxx::tree::optional< alert::type > _xsd_alert_;
    };
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <xsd/cxx/tree/parsing.hxx>

namespace dtn
{
  namespace rtrmessage
  {
    // Read from a URI or a local file.
    //

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::std::basic_string< char >&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::std::basic_string< char >&,
          ::xsd::cxx::xml::error_handler< char >&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::std::basic_string< char >&,
          ::xercesc::DOMErrorHandler&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from std::istream.
    //

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream&,
          ::xsd::cxx::xml::error_handler< char >&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream&,
          ::xercesc::DOMErrorHandler&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream&,
          const ::std::basic_string< char >& id,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream&,
          const ::std::basic_string< char >& id,
          ::xsd::cxx::xml::error_handler< char >&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream&,
          const ::std::basic_string< char >& id,
          ::xercesc::DOMErrorHandler&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from InputSource.
    //

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMInputSource&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMInputSource&,
          ::xsd::cxx::xml::error_handler< char >&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMInputSource&,
          ::xercesc::DOMErrorHandler&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


    // Read from DOM.
    //

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMDocument&,
          ::xml_schema::flags = 0,
          const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());
  }
}

#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/tree/serialization.hxx>

namespace dtn
{
  namespace rtrmessage
  {
    void
    operator<< (::xercesc::DOMElement&,
                dtnStatusType);

    void
    operator<< (::xercesc::DOMAttr&,
                dtnStatusType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                dtnStatusType);

    void
    operator<< (::xercesc::DOMElement&,
                bundlePriorityType);

    void
    operator<< (::xercesc::DOMAttr&,
                bundlePriorityType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                bundlePriorityType);

    void
    operator<< (::xercesc::DOMElement&,
                eventSourceType);

    void
    operator<< (::xercesc::DOMAttr&,
                eventSourceType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                eventSourceType);

    void
    operator<< (::xercesc::DOMElement&,
                bundleForwardActionType);

    void
    operator<< (::xercesc::DOMAttr&,
                bundleForwardActionType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                bundleForwardActionType);

    void
    operator<< (::xercesc::DOMElement&,
                contactReasonType);

    void
    operator<< (::xercesc::DOMAttr&,
                contactReasonType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                contactReasonType);

    void
    operator<< (::xercesc::DOMElement&,
                linkTypeType);

    void
    operator<< (::xercesc::DOMAttr&,
                linkTypeType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                linkTypeType);

    void
    operator<< (::xercesc::DOMElement&,
                linkStateType);

    void
    operator<< (::xercesc::DOMAttr&,
                linkStateType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                linkStateType);

    void
    operator<< (::xercesc::DOMElement&,
                const eidTypeType&);

    void
    operator<< (::xercesc::DOMAttr&,
                const eidTypeType&);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                const eidTypeType&);

    void
    operator<< (::xercesc::DOMElement&,
                failureActionType);

    void
    operator<< (::xercesc::DOMAttr&,
                failureActionType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                failureActionType);

    void
    operator<< (::xercesc::DOMElement&,
                bundleLocationType);

    void
    operator<< (::xercesc::DOMAttr&,
                bundleLocationType);

    void
    operator<< (::xsd::cxx::tree::list_stream< char >&,
                bundleLocationType);

    void
    operator<< (::xercesc::DOMElement&,
                const eidType&);

    void
    operator<< (::xercesc::DOMElement&,
                const bundleType&);

    void
    operator<< (::xercesc::DOMElement&,
                const contactType&);

    void
    operator<< (::xercesc::DOMElement&,
                const clInfoType&);

    void
    operator<< (::xercesc::DOMElement&,
                const linkType&);

    void
    operator<< (::xercesc::DOMElement&,
                const routeEntryType&);

    void
    operator<< (::xercesc::DOMElement&,
                const registrationType&);

    // Serialize to an existing DOM instance.
    //
    void
    dtn_ (::xercesc::DOMDocument&,
          const ::dtn::rtrmessage::dtn&,
          ::xml_schema::flags = 0);


    // Serialize to a new DOM instance.
    //
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    dtn_ (const ::dtn::rtrmessage::dtn&, 
          const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
          ::xml_schema::flags = 0);


    // Serialize to XMLFormatTarget.
    //
    void
    dtn_ (::xercesc::XMLFormatTarget&,
          const ::dtn::rtrmessage::dtn&, 
          const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
          const ::std::basic_string< char >& = "UTF-8",
          ::xml_schema::flags = 0);


    void
    dtn_ (::xercesc::XMLFormatTarget&,
          const ::dtn::rtrmessage::dtn&, 
          const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
          ::xsd::cxx::xml::error_handler< char >&,
          const ::std::basic_string< char >& = "UTF-8",
          ::xml_schema::flags = 0);

    void
    dtn_ (::xercesc::XMLFormatTarget&,
          const ::dtn::rtrmessage::dtn&, 
          const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
          ::xercesc::DOMErrorHandler&,
          const ::std::basic_string< char >& = "UTF-8",
          ::xml_schema::flags = 0);


    // Serialize to std::ostream.
    //
    void
    dtn_ (::std::ostream&,
          const ::dtn::rtrmessage::dtn&, 
          const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
          const ::std::basic_string< char >& = "UTF-8",
          ::xml_schema::flags = 0);


    void
    dtn_ (::std::ostream&,
          const ::dtn::rtrmessage::dtn&, 
          const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
          ::xsd::cxx::xml::error_handler< char >&,
          const ::std::basic_string< char >& = "UTF-8",
          ::xml_schema::flags = 0);

    void
    dtn_ (::std::ostream&,
          const ::dtn::rtrmessage::dtn&, 
          const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
          ::xercesc::DOMErrorHandler&,
          const ::std::basic_string< char >& = "UTF-8",
          ::xml_schema::flags = 0);


    void
    operator<< (::xercesc::DOMElement&,
                const bundle_received_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const bundle_transmitted_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const bundle_transmit_failed_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const bundle_delivery_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const bundle_expired_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const contact_up_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const contact_down_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const link_created_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const link_deleted_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const link_available_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const link_unavailable_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const link_busy_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const route_add_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const route_delete_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const custody_signal_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const custody_timeout_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const registration_added_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const registration_removed_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const registration_expired_event&);

    void
    operator<< (::xercesc::DOMElement&,
                const open_link_request&);

    void
    operator<< (::xercesc::DOMElement&,
                const send_bundle_request&);

    void
    operator<< (::xercesc::DOMElement&,
                const cancel_bundle_request&);

    void
    operator<< (::xercesc::DOMElement&,
                const inject_bundle_request&);

    void
    operator<< (::xercesc::DOMElement&,
                const link_report&);

    void
    operator<< (::xercesc::DOMElement&,
                const contact_report&);

    void
    operator<< (::xercesc::DOMElement&,
                const route_report&);

    void
    operator<< (::xercesc::DOMElement&,
                const bundle_report&);

    void
    operator<< (::xercesc::DOMElement&,
                const dtn&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
#include "router-custom.h"
//
// End epilogue.

#endif // ROUTER_H
