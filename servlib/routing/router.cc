// Copyright (C) 2005-2006 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// In addition, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include <config.h>
#ifdef XERCES_C_ENABLED
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "router.h"

namespace dtn
{
  namespace rtrmessage
  {
    // dtnStatusType
    // 

    dtnStatusType::
    dtnStatusType ()
    : ::xml_schema::string ()
    {
    }

    dtnStatusType::
    dtnStatusType (_xsd_dtnStatusType v)
    : ::xml_schema::string (_xsd_dtnStatusType_literals_[v])
    {
    }

    dtnStatusType::
    dtnStatusType (const ::xml_schema::string& _xsd_dtnStatusType)
    : ::xml_schema::string (_xsd_dtnStatusType)
    {
    }

    dtnStatusType::
    dtnStatusType (const dtnStatusType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    dtnStatusType& dtnStatusType::
    operator= (_xsd_dtnStatusType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_dtnStatusType_literals_[v]);

      return *this;
    }


    // bundlePriorityType
    // 

    bundlePriorityType::
    bundlePriorityType ()
    : ::xml_schema::string ()
    {
    }

    bundlePriorityType::
    bundlePriorityType (_xsd_bundlePriorityType v)
    : ::xml_schema::string (_xsd_bundlePriorityType_literals_[v])
    {
    }

    bundlePriorityType::
    bundlePriorityType (const ::xml_schema::string& _xsd_bundlePriorityType)
    : ::xml_schema::string (_xsd_bundlePriorityType)
    {
    }

    bundlePriorityType::
    bundlePriorityType (const bundlePriorityType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    bundlePriorityType& bundlePriorityType::
    operator= (_xsd_bundlePriorityType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_bundlePriorityType_literals_[v]);

      return *this;
    }


    // eventSourceType
    // 

    eventSourceType::
    eventSourceType ()
    : ::xml_schema::string ()
    {
    }

    eventSourceType::
    eventSourceType (_xsd_eventSourceType v)
    : ::xml_schema::string (_xsd_eventSourceType_literals_[v])
    {
    }

    eventSourceType::
    eventSourceType (const ::xml_schema::string& _xsd_eventSourceType)
    : ::xml_schema::string (_xsd_eventSourceType)
    {
    }

    eventSourceType::
    eventSourceType (const eventSourceType& v,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    eventSourceType& eventSourceType::
    operator= (_xsd_eventSourceType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_eventSourceType_literals_[v]);

      return *this;
    }


    // bundleForwardActionType
    // 

    bundleForwardActionType::
    bundleForwardActionType ()
    : ::xml_schema::string ()
    {
    }

    bundleForwardActionType::
    bundleForwardActionType (_xsd_bundleForwardActionType v)
    : ::xml_schema::string (_xsd_bundleForwardActionType_literals_[v])
    {
    }

    bundleForwardActionType::
    bundleForwardActionType (const ::xml_schema::string& _xsd_bundleForwardActionType)
    : ::xml_schema::string (_xsd_bundleForwardActionType)
    {
    }

    bundleForwardActionType::
    bundleForwardActionType (const bundleForwardActionType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    bundleForwardActionType& bundleForwardActionType::
    operator= (_xsd_bundleForwardActionType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_bundleForwardActionType_literals_[v]);

      return *this;
    }


    // contactReasonType
    // 

    contactReasonType::
    contactReasonType ()
    : ::xml_schema::string ()
    {
    }

    contactReasonType::
    contactReasonType (_xsd_contactReasonType v)
    : ::xml_schema::string (_xsd_contactReasonType_literals_[v])
    {
    }

    contactReasonType::
    contactReasonType (const ::xml_schema::string& _xsd_contactReasonType)
    : ::xml_schema::string (_xsd_contactReasonType)
    {
    }

    contactReasonType::
    contactReasonType (const contactReasonType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    contactReasonType& contactReasonType::
    operator= (_xsd_contactReasonType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_contactReasonType_literals_[v]);

      return *this;
    }


    // linkTypeType
    // 

    linkTypeType::
    linkTypeType ()
    : ::xml_schema::string ()
    {
    }

    linkTypeType::
    linkTypeType (_xsd_linkTypeType v)
    : ::xml_schema::string (_xsd_linkTypeType_literals_[v])
    {
    }

    linkTypeType::
    linkTypeType (const ::xml_schema::string& _xsd_linkTypeType)
    : ::xml_schema::string (_xsd_linkTypeType)
    {
    }

    linkTypeType::
    linkTypeType (const linkTypeType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    linkTypeType& linkTypeType::
    operator= (_xsd_linkTypeType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_linkTypeType_literals_[v]);

      return *this;
    }


    // linkStateType
    // 

    linkStateType::
    linkStateType ()
    : ::xml_schema::string ()
    {
    }

    linkStateType::
    linkStateType (_xsd_linkStateType v)
    : ::xml_schema::string (_xsd_linkStateType_literals_[v])
    {
    }

    linkStateType::
    linkStateType (const ::xml_schema::string& _xsd_linkStateType)
    : ::xml_schema::string (_xsd_linkStateType)
    {
    }

    linkStateType::
    linkStateType (const linkStateType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    linkStateType& linkStateType::
    operator= (_xsd_linkStateType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_linkStateType_literals_[v]);

      return *this;
    }


    // eidTypeType
    //

    eidTypeType::
    eidTypeType ()
    : ::xml_schema::string ()
    {
    }

    eidTypeType::
    eidTypeType (const ::std::basic_string< char >& s)
    : ::xml_schema::string (s)
    {
    }

    eidTypeType::
    eidTypeType (const eidTypeType& o,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::string (o, f, c)
    {
    }

    // failureActionType
    // 

    failureActionType::
    failureActionType ()
    : ::xml_schema::string ()
    {
    }

    failureActionType::
    failureActionType (_xsd_failureActionType v)
    : ::xml_schema::string (_xsd_failureActionType_literals_[v])
    {
    }

    failureActionType::
    failureActionType (const ::xml_schema::string& _xsd_failureActionType)
    : ::xml_schema::string (_xsd_failureActionType)
    {
    }

    failureActionType::
    failureActionType (const failureActionType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    failureActionType& failureActionType::
    operator= (_xsd_failureActionType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_failureActionType_literals_[v]);

      return *this;
    }


    // bundleLocationType
    // 

    bundleLocationType::
    bundleLocationType ()
    : ::xml_schema::string ()
    {
    }

    bundleLocationType::
    bundleLocationType (_xsd_bundleLocationType v)
    : ::xml_schema::string (_xsd_bundleLocationType_literals_[v])
    {
    }

    bundleLocationType::
    bundleLocationType (const ::xml_schema::string& _xsd_bundleLocationType)
    : ::xml_schema::string (_xsd_bundleLocationType)
    {
    }

    bundleLocationType::
    bundleLocationType (const bundleLocationType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    bundleLocationType& bundleLocationType::
    operator= (_xsd_bundleLocationType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_bundleLocationType_literals_[v]);

      return *this;
    }


    // eidType
    // 

    const eidType::uri::type& eidType::
    uri () const
    {
      return this->_xsd_uri_.get ();
    }

    eidType::uri::type& eidType::
    uri ()
    {
      return this->_xsd_uri_.get ();
    }

    void eidType::
    uri (const uri::type& uri)
    {
      this->_xsd_uri_.set (uri);
    }

    void eidType::
    uri (::std::auto_ptr< uri::type > uri)
    {
      this->_xsd_uri_.set (uri);
    }


    // bundleType_base
    // 

    const bundleType_base::source::type& bundleType_base::
    source () const
    {
      return this->_xsd_source_.get ();
    }

    bundleType_base::source::type& bundleType_base::
    source ()
    {
      return this->_xsd_source_.get ();
    }

    void bundleType_base::
    source (const source::type& source)
    {
      this->_xsd_source_.set (source);
    }

    void bundleType_base::
    source (::std::auto_ptr< source::type > source)
    {
      this->_xsd_source_.set (source);
    }

    const bundleType_base::dest::type& bundleType_base::
    dest () const
    {
      return this->_xsd_dest_.get ();
    }

    bundleType_base::dest::type& bundleType_base::
    dest ()
    {
      return this->_xsd_dest_.get ();
    }

    void bundleType_base::
    dest (const dest::type& dest)
    {
      this->_xsd_dest_.set (dest);
    }

    void bundleType_base::
    dest (::std::auto_ptr< dest::type > dest)
    {
      this->_xsd_dest_.set (dest);
    }

    const bundleType_base::custodian::type& bundleType_base::
    custodian () const
    {
      return this->_xsd_custodian_.get ();
    }

    bundleType_base::custodian::type& bundleType_base::
    custodian ()
    {
      return this->_xsd_custodian_.get ();
    }

    void bundleType_base::
    custodian (const custodian::type& custodian)
    {
      this->_xsd_custodian_.set (custodian);
    }

    void bundleType_base::
    custodian (::std::auto_ptr< custodian::type > custodian)
    {
      this->_xsd_custodian_.set (custodian);
    }

    const bundleType_base::replyto::type& bundleType_base::
    replyto () const
    {
      return this->_xsd_replyto_.get ();
    }

    bundleType_base::replyto::type& bundleType_base::
    replyto ()
    {
      return this->_xsd_replyto_.get ();
    }

    void bundleType_base::
    replyto (const replyto::type& replyto)
    {
      this->_xsd_replyto_.set (replyto);
    }

    void bundleType_base::
    replyto (::std::auto_ptr< replyto::type > replyto)
    {
      this->_xsd_replyto_.set (replyto);
    }

    const bundleType_base::prevhop::type& bundleType_base::
    prevhop () const
    {
      return this->_xsd_prevhop_.get ();
    }

    bundleType_base::prevhop::type& bundleType_base::
    prevhop ()
    {
      return this->_xsd_prevhop_.get ();
    }

    void bundleType_base::
    prevhop (const prevhop::type& prevhop)
    {
      this->_xsd_prevhop_.set (prevhop);
    }

    void bundleType_base::
    prevhop (::std::auto_ptr< prevhop::type > prevhop)
    {
      this->_xsd_prevhop_.set (prevhop);
    }

    const bundleType_base::length::type& bundleType_base::
    length () const
    {
      return this->_xsd_length_.get ();
    }

    bundleType_base::length::type& bundleType_base::
    length ()
    {
      return this->_xsd_length_.get ();
    }

    void bundleType_base::
    length (const length::type& length)
    {
      this->_xsd_length_.set (length);
    }

    const bundleType_base::location::type& bundleType_base::
    location () const
    {
      return this->_xsd_location_.get ();
    }

    bundleType_base::location::type& bundleType_base::
    location ()
    {
      return this->_xsd_location_.get ();
    }

    void bundleType_base::
    location (const location::type& location)
    {
      this->_xsd_location_.set (location);
    }

    void bundleType_base::
    location (::std::auto_ptr< location::type > location)
    {
      this->_xsd_location_.set (location);
    }

    const bundleType_base::payload::container& bundleType_base::
    payload () const
    {
      return this->_xsd_payload_;
    }

    bundleType_base::payload::container& bundleType_base::
    payload ()
    {
      return this->_xsd_payload_;
    }

    void bundleType_base::
    payload (const payload::type& payload)
    {
      this->_xsd_payload_.set (payload);
    }

    void bundleType_base::
    payload (const payload::container& payload)
    {
      this->_xsd_payload_ = payload;
    }

    void bundleType_base::
    payload (::std::auto_ptr< payload::type > payload)
    {
      this->_xsd_payload_.set (payload);
    }

    const bundleType_base::recv_blocks::container& bundleType_base::
    recv_blocks () const
    {
      return this->_xsd_recv_blocks_;
    }

    bundleType_base::recv_blocks::container& bundleType_base::
    recv_blocks ()
    {
      return this->_xsd_recv_blocks_;
    }

    void bundleType_base::
    recv_blocks (const recv_blocks::type& recv_blocks)
    {
      this->_xsd_recv_blocks_.set (recv_blocks);
    }

    void bundleType_base::
    recv_blocks (const recv_blocks::container& recv_blocks)
    {
      this->_xsd_recv_blocks_ = recv_blocks;
    }

    void bundleType_base::
    recv_blocks (::std::auto_ptr< recv_blocks::type > recv_blocks)
    {
      this->_xsd_recv_blocks_.set (recv_blocks);
    }

    const bundleType_base::api_blocks::container& bundleType_base::
    api_blocks () const
    {
      return this->_xsd_api_blocks_;
    }

    bundleType_base::api_blocks::container& bundleType_base::
    api_blocks ()
    {
      return this->_xsd_api_blocks_;
    }

    void bundleType_base::
    api_blocks (const api_blocks::type& api_blocks)
    {
      this->_xsd_api_blocks_.set (api_blocks);
    }

    void bundleType_base::
    api_blocks (const api_blocks::container& api_blocks)
    {
      this->_xsd_api_blocks_ = api_blocks;
    }

    void bundleType_base::
    api_blocks (::std::auto_ptr< api_blocks::type > api_blocks)
    {
      this->_xsd_api_blocks_.set (api_blocks);
    }

    const bundleType_base::bundleid::type& bundleType_base::
    bundleid () const
    {
      return this->_xsd_bundleid_.get ();
    }

    bundleType_base::bundleid::type& bundleType_base::
    bundleid ()
    {
      return this->_xsd_bundleid_.get ();
    }

    void bundleType_base::
    bundleid (const bundleid::type& bundleid)
    {
      this->_xsd_bundleid_.set (bundleid);
    }

    const bundleType_base::is_fragment::type& bundleType_base::
    is_fragment () const
    {
      return this->_xsd_is_fragment_.get ();
    }

    bundleType_base::is_fragment::type& bundleType_base::
    is_fragment ()
    {
      return this->_xsd_is_fragment_.get ();
    }

    void bundleType_base::
    is_fragment (const is_fragment::type& is_fragment)
    {
      this->_xsd_is_fragment_.set (is_fragment);
    }

    const bundleType_base::is_admin::type& bundleType_base::
    is_admin () const
    {
      return this->_xsd_is_admin_.get ();
    }

    bundleType_base::is_admin::type& bundleType_base::
    is_admin ()
    {
      return this->_xsd_is_admin_.get ();
    }

    void bundleType_base::
    is_admin (const is_admin::type& is_admin)
    {
      this->_xsd_is_admin_.set (is_admin);
    }

    const bundleType_base::do_not_fragment::type& bundleType_base::
    do_not_fragment () const
    {
      return this->_xsd_do_not_fragment_.get ();
    }

    bundleType_base::do_not_fragment::type& bundleType_base::
    do_not_fragment ()
    {
      return this->_xsd_do_not_fragment_.get ();
    }

    void bundleType_base::
    do_not_fragment (const do_not_fragment::type& do_not_fragment)
    {
      this->_xsd_do_not_fragment_.set (do_not_fragment);
    }

    const bundleType_base::priority::type& bundleType_base::
    priority () const
    {
      return this->_xsd_priority_.get ();
    }

    bundleType_base::priority::type& bundleType_base::
    priority ()
    {
      return this->_xsd_priority_.get ();
    }

    void bundleType_base::
    priority (const priority::type& priority)
    {
      this->_xsd_priority_.set (priority);
    }

    void bundleType_base::
    priority (::std::auto_ptr< priority::type > priority)
    {
      this->_xsd_priority_.set (priority);
    }

    const bundleType_base::custody_requested::type& bundleType_base::
    custody_requested () const
    {
      return this->_xsd_custody_requested_.get ();
    }

    bundleType_base::custody_requested::type& bundleType_base::
    custody_requested ()
    {
      return this->_xsd_custody_requested_.get ();
    }

    void bundleType_base::
    custody_requested (const custody_requested::type& custody_requested)
    {
      this->_xsd_custody_requested_.set (custody_requested);
    }

    const bundleType_base::local_custody::type& bundleType_base::
    local_custody () const
    {
      return this->_xsd_local_custody_.get ();
    }

    bundleType_base::local_custody::type& bundleType_base::
    local_custody ()
    {
      return this->_xsd_local_custody_.get ();
    }

    void bundleType_base::
    local_custody (const local_custody::type& local_custody)
    {
      this->_xsd_local_custody_.set (local_custody);
    }

    const bundleType_base::singleton_dest::type& bundleType_base::
    singleton_dest () const
    {
      return this->_xsd_singleton_dest_.get ();
    }

    bundleType_base::singleton_dest::type& bundleType_base::
    singleton_dest ()
    {
      return this->_xsd_singleton_dest_.get ();
    }

    void bundleType_base::
    singleton_dest (const singleton_dest::type& singleton_dest)
    {
      this->_xsd_singleton_dest_.set (singleton_dest);
    }

    const bundleType_base::custody_rcpt::type& bundleType_base::
    custody_rcpt () const
    {
      return this->_xsd_custody_rcpt_.get ();
    }

    bundleType_base::custody_rcpt::type& bundleType_base::
    custody_rcpt ()
    {
      return this->_xsd_custody_rcpt_.get ();
    }

    void bundleType_base::
    custody_rcpt (const custody_rcpt::type& custody_rcpt)
    {
      this->_xsd_custody_rcpt_.set (custody_rcpt);
    }

    const bundleType_base::receive_rcpt::type& bundleType_base::
    receive_rcpt () const
    {
      return this->_xsd_receive_rcpt_.get ();
    }

    bundleType_base::receive_rcpt::type& bundleType_base::
    receive_rcpt ()
    {
      return this->_xsd_receive_rcpt_.get ();
    }

    void bundleType_base::
    receive_rcpt (const receive_rcpt::type& receive_rcpt)
    {
      this->_xsd_receive_rcpt_.set (receive_rcpt);
    }

    const bundleType_base::forward_rcpt::type& bundleType_base::
    forward_rcpt () const
    {
      return this->_xsd_forward_rcpt_.get ();
    }

    bundleType_base::forward_rcpt::type& bundleType_base::
    forward_rcpt ()
    {
      return this->_xsd_forward_rcpt_.get ();
    }

    void bundleType_base::
    forward_rcpt (const forward_rcpt::type& forward_rcpt)
    {
      this->_xsd_forward_rcpt_.set (forward_rcpt);
    }

    const bundleType_base::delivery_rcpt::type& bundleType_base::
    delivery_rcpt () const
    {
      return this->_xsd_delivery_rcpt_.get ();
    }

    bundleType_base::delivery_rcpt::type& bundleType_base::
    delivery_rcpt ()
    {
      return this->_xsd_delivery_rcpt_.get ();
    }

    void bundleType_base::
    delivery_rcpt (const delivery_rcpt::type& delivery_rcpt)
    {
      this->_xsd_delivery_rcpt_.set (delivery_rcpt);
    }

    const bundleType_base::deletion_rcpt::type& bundleType_base::
    deletion_rcpt () const
    {
      return this->_xsd_deletion_rcpt_.get ();
    }

    bundleType_base::deletion_rcpt::type& bundleType_base::
    deletion_rcpt ()
    {
      return this->_xsd_deletion_rcpt_.get ();
    }

    void bundleType_base::
    deletion_rcpt (const deletion_rcpt::type& deletion_rcpt)
    {
      this->_xsd_deletion_rcpt_.set (deletion_rcpt);
    }

    const bundleType_base::app_acked_rcpt::type& bundleType_base::
    app_acked_rcpt () const
    {
      return this->_xsd_app_acked_rcpt_.get ();
    }

    bundleType_base::app_acked_rcpt::type& bundleType_base::
    app_acked_rcpt ()
    {
      return this->_xsd_app_acked_rcpt_.get ();
    }

    void bundleType_base::
    app_acked_rcpt (const app_acked_rcpt::type& app_acked_rcpt)
    {
      this->_xsd_app_acked_rcpt_.set (app_acked_rcpt);
    }

    const bundleType_base::creation_ts_seconds::type& bundleType_base::
    creation_ts_seconds () const
    {
      return this->_xsd_creation_ts_seconds_.get ();
    }

    bundleType_base::creation_ts_seconds::type& bundleType_base::
    creation_ts_seconds ()
    {
      return this->_xsd_creation_ts_seconds_.get ();
    }

    void bundleType_base::
    creation_ts_seconds (const creation_ts_seconds::type& creation_ts_seconds)
    {
      this->_xsd_creation_ts_seconds_.set (creation_ts_seconds);
    }

    const bundleType_base::creation_ts_seqno::type& bundleType_base::
    creation_ts_seqno () const
    {
      return this->_xsd_creation_ts_seqno_.get ();
    }

    bundleType_base::creation_ts_seqno::type& bundleType_base::
    creation_ts_seqno ()
    {
      return this->_xsd_creation_ts_seqno_.get ();
    }

    void bundleType_base::
    creation_ts_seqno (const creation_ts_seqno::type& creation_ts_seqno)
    {
      this->_xsd_creation_ts_seqno_.set (creation_ts_seqno);
    }

    const bundleType_base::expiration::type& bundleType_base::
    expiration () const
    {
      return this->_xsd_expiration_.get ();
    }

    bundleType_base::expiration::type& bundleType_base::
    expiration ()
    {
      return this->_xsd_expiration_.get ();
    }

    void bundleType_base::
    expiration (const expiration::type& expiration)
    {
      this->_xsd_expiration_.set (expiration);
    }

    const bundleType_base::orig_length::type& bundleType_base::
    orig_length () const
    {
      return this->_xsd_orig_length_.get ();
    }

    bundleType_base::orig_length::type& bundleType_base::
    orig_length ()
    {
      return this->_xsd_orig_length_.get ();
    }

    void bundleType_base::
    orig_length (const orig_length::type& orig_length)
    {
      this->_xsd_orig_length_.set (orig_length);
    }

    const bundleType_base::frag_offset::type& bundleType_base::
    frag_offset () const
    {
      return this->_xsd_frag_offset_.get ();
    }

    bundleType_base::frag_offset::type& bundleType_base::
    frag_offset ()
    {
      return this->_xsd_frag_offset_.get ();
    }

    void bundleType_base::
    frag_offset (const frag_offset::type& frag_offset)
    {
      this->_xsd_frag_offset_.set (frag_offset);
    }

    const bundleType_base::owner::type& bundleType_base::
    owner () const
    {
      return this->_xsd_owner_.get ();
    }

    bundleType_base::owner::type& bundleType_base::
    owner ()
    {
      return this->_xsd_owner_.get ();
    }

    void bundleType_base::
    owner (const owner::type& owner)
    {
      this->_xsd_owner_.set (owner);
    }

    void bundleType_base::
    owner (::std::auto_ptr< owner::type > owner)
    {
      this->_xsd_owner_.set (owner);
    }


    // contactType_base
    // 

    const contactType_base::link::type& contactType_base::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    contactType_base::link::type& contactType_base::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void contactType_base::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void contactType_base::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const contactType_base::start_time_sec::type& contactType_base::
    start_time_sec () const
    {
      return this->_xsd_start_time_sec_.get ();
    }

    contactType_base::start_time_sec::type& contactType_base::
    start_time_sec ()
    {
      return this->_xsd_start_time_sec_.get ();
    }

    void contactType_base::
    start_time_sec (const start_time_sec::type& start_time_sec)
    {
      this->_xsd_start_time_sec_.set (start_time_sec);
    }

    const contactType_base::start_time_usec::type& contactType_base::
    start_time_usec () const
    {
      return this->_xsd_start_time_usec_.get ();
    }

    contactType_base::start_time_usec::type& contactType_base::
    start_time_usec ()
    {
      return this->_xsd_start_time_usec_.get ();
    }

    void contactType_base::
    start_time_usec (const start_time_usec::type& start_time_usec)
    {
      this->_xsd_start_time_usec_.set (start_time_usec);
    }

    const contactType_base::duration::type& contactType_base::
    duration () const
    {
      return this->_xsd_duration_.get ();
    }

    contactType_base::duration::type& contactType_base::
    duration ()
    {
      return this->_xsd_duration_.get ();
    }

    void contactType_base::
    duration (const duration::type& duration)
    {
      this->_xsd_duration_.set (duration);
    }

    const contactType_base::bps::type& contactType_base::
    bps () const
    {
      return this->_xsd_bps_.get ();
    }

    contactType_base::bps::type& contactType_base::
    bps ()
    {
      return this->_xsd_bps_.get ();
    }

    void contactType_base::
    bps (const bps::type& bps)
    {
      this->_xsd_bps_.set (bps);
    }

    const contactType_base::latency::type& contactType_base::
    latency () const
    {
      return this->_xsd_latency_.get ();
    }

    contactType_base::latency::type& contactType_base::
    latency ()
    {
      return this->_xsd_latency_.get ();
    }

    void contactType_base::
    latency (const latency::type& latency)
    {
      this->_xsd_latency_.set (latency);
    }


    // clInfoType
    // 

    const clInfoType::local_addr::container& clInfoType::
    local_addr () const
    {
      return this->_xsd_local_addr_;
    }

    clInfoType::local_addr::container& clInfoType::
    local_addr ()
    {
      return this->_xsd_local_addr_;
    }

    void clInfoType::
    local_addr (const local_addr::type& local_addr)
    {
      this->_xsd_local_addr_.set (local_addr);
    }

    void clInfoType::
    local_addr (const local_addr::container& local_addr)
    {
      this->_xsd_local_addr_ = local_addr;
    }

    void clInfoType::
    local_addr (::std::auto_ptr< local_addr::type > local_addr)
    {
      this->_xsd_local_addr_.set (local_addr);
    }

    const clInfoType::remote_addr::container& clInfoType::
    remote_addr () const
    {
      return this->_xsd_remote_addr_;
    }

    clInfoType::remote_addr::container& clInfoType::
    remote_addr ()
    {
      return this->_xsd_remote_addr_;
    }

    void clInfoType::
    remote_addr (const remote_addr::type& remote_addr)
    {
      this->_xsd_remote_addr_.set (remote_addr);
    }

    void clInfoType::
    remote_addr (const remote_addr::container& remote_addr)
    {
      this->_xsd_remote_addr_ = remote_addr;
    }

    void clInfoType::
    remote_addr (::std::auto_ptr< remote_addr::type > remote_addr)
    {
      this->_xsd_remote_addr_.set (remote_addr);
    }

    const clInfoType::local_port::container& clInfoType::
    local_port () const
    {
      return this->_xsd_local_port_;
    }

    clInfoType::local_port::container& clInfoType::
    local_port ()
    {
      return this->_xsd_local_port_;
    }

    void clInfoType::
    local_port (const local_port::type& local_port)
    {
      this->_xsd_local_port_.set (local_port);
    }

    void clInfoType::
    local_port (const local_port::container& local_port)
    {
      this->_xsd_local_port_ = local_port;
    }

    const clInfoType::remote_port::container& clInfoType::
    remote_port () const
    {
      return this->_xsd_remote_port_;
    }

    clInfoType::remote_port::container& clInfoType::
    remote_port ()
    {
      return this->_xsd_remote_port_;
    }

    void clInfoType::
    remote_port (const remote_port::type& remote_port)
    {
      this->_xsd_remote_port_.set (remote_port);
    }

    void clInfoType::
    remote_port (const remote_port::container& remote_port)
    {
      this->_xsd_remote_port_ = remote_port;
    }

    const clInfoType::segment_ack_enabled::container& clInfoType::
    segment_ack_enabled () const
    {
      return this->_xsd_segment_ack_enabled_;
    }

    clInfoType::segment_ack_enabled::container& clInfoType::
    segment_ack_enabled ()
    {
      return this->_xsd_segment_ack_enabled_;
    }

    void clInfoType::
    segment_ack_enabled (const segment_ack_enabled::type& segment_ack_enabled)
    {
      this->_xsd_segment_ack_enabled_.set (segment_ack_enabled);
    }

    void clInfoType::
    segment_ack_enabled (const segment_ack_enabled::container& segment_ack_enabled)
    {
      this->_xsd_segment_ack_enabled_ = segment_ack_enabled;
    }

    const clInfoType::negative_ack_enabled::container& clInfoType::
    negative_ack_enabled () const
    {
      return this->_xsd_negative_ack_enabled_;
    }

    clInfoType::negative_ack_enabled::container& clInfoType::
    negative_ack_enabled ()
    {
      return this->_xsd_negative_ack_enabled_;
    }

    void clInfoType::
    negative_ack_enabled (const negative_ack_enabled::type& negative_ack_enabled)
    {
      this->_xsd_negative_ack_enabled_.set (negative_ack_enabled);
    }

    void clInfoType::
    negative_ack_enabled (const negative_ack_enabled::container& negative_ack_enabled)
    {
      this->_xsd_negative_ack_enabled_ = negative_ack_enabled;
    }

    const clInfoType::keepalive_interval::container& clInfoType::
    keepalive_interval () const
    {
      return this->_xsd_keepalive_interval_;
    }

    clInfoType::keepalive_interval::container& clInfoType::
    keepalive_interval ()
    {
      return this->_xsd_keepalive_interval_;
    }

    void clInfoType::
    keepalive_interval (const keepalive_interval::type& keepalive_interval)
    {
      this->_xsd_keepalive_interval_.set (keepalive_interval);
    }

    void clInfoType::
    keepalive_interval (const keepalive_interval::container& keepalive_interval)
    {
      this->_xsd_keepalive_interval_ = keepalive_interval;
    }

    const clInfoType::segment_length::container& clInfoType::
    segment_length () const
    {
      return this->_xsd_segment_length_;
    }

    clInfoType::segment_length::container& clInfoType::
    segment_length ()
    {
      return this->_xsd_segment_length_;
    }

    void clInfoType::
    segment_length (const segment_length::type& segment_length)
    {
      this->_xsd_segment_length_.set (segment_length);
    }

    void clInfoType::
    segment_length (const segment_length::container& segment_length)
    {
      this->_xsd_segment_length_ = segment_length;
    }

    const clInfoType::busy_queue_depth::container& clInfoType::
    busy_queue_depth () const
    {
      return this->_xsd_busy_queue_depth_;
    }

    clInfoType::busy_queue_depth::container& clInfoType::
    busy_queue_depth ()
    {
      return this->_xsd_busy_queue_depth_;
    }

    void clInfoType::
    busy_queue_depth (const busy_queue_depth::type& busy_queue_depth)
    {
      this->_xsd_busy_queue_depth_.set (busy_queue_depth);
    }

    void clInfoType::
    busy_queue_depth (const busy_queue_depth::container& busy_queue_depth)
    {
      this->_xsd_busy_queue_depth_ = busy_queue_depth;
    }

    const clInfoType::reactive_frag_enabled::container& clInfoType::
    reactive_frag_enabled () const
    {
      return this->_xsd_reactive_frag_enabled_;
    }

    clInfoType::reactive_frag_enabled::container& clInfoType::
    reactive_frag_enabled ()
    {
      return this->_xsd_reactive_frag_enabled_;
    }

    void clInfoType::
    reactive_frag_enabled (const reactive_frag_enabled::type& reactive_frag_enabled)
    {
      this->_xsd_reactive_frag_enabled_.set (reactive_frag_enabled);
    }

    void clInfoType::
    reactive_frag_enabled (const reactive_frag_enabled::container& reactive_frag_enabled)
    {
      this->_xsd_reactive_frag_enabled_ = reactive_frag_enabled;
    }

    const clInfoType::sendbuf_length::container& clInfoType::
    sendbuf_length () const
    {
      return this->_xsd_sendbuf_length_;
    }

    clInfoType::sendbuf_length::container& clInfoType::
    sendbuf_length ()
    {
      return this->_xsd_sendbuf_length_;
    }

    void clInfoType::
    sendbuf_length (const sendbuf_length::type& sendbuf_length)
    {
      this->_xsd_sendbuf_length_.set (sendbuf_length);
    }

    void clInfoType::
    sendbuf_length (const sendbuf_length::container& sendbuf_length)
    {
      this->_xsd_sendbuf_length_ = sendbuf_length;
    }

    const clInfoType::recvbuf_length::container& clInfoType::
    recvbuf_length () const
    {
      return this->_xsd_recvbuf_length_;
    }

    clInfoType::recvbuf_length::container& clInfoType::
    recvbuf_length ()
    {
      return this->_xsd_recvbuf_length_;
    }

    void clInfoType::
    recvbuf_length (const recvbuf_length::type& recvbuf_length)
    {
      this->_xsd_recvbuf_length_.set (recvbuf_length);
    }

    void clInfoType::
    recvbuf_length (const recvbuf_length::container& recvbuf_length)
    {
      this->_xsd_recvbuf_length_ = recvbuf_length;
    }

    const clInfoType::data_timeout::container& clInfoType::
    data_timeout () const
    {
      return this->_xsd_data_timeout_;
    }

    clInfoType::data_timeout::container& clInfoType::
    data_timeout ()
    {
      return this->_xsd_data_timeout_;
    }

    void clInfoType::
    data_timeout (const data_timeout::type& data_timeout)
    {
      this->_xsd_data_timeout_.set (data_timeout);
    }

    void clInfoType::
    data_timeout (const data_timeout::container& data_timeout)
    {
      this->_xsd_data_timeout_ = data_timeout;
    }

    const clInfoType::rate::container& clInfoType::
    rate () const
    {
      return this->_xsd_rate_;
    }

    clInfoType::rate::container& clInfoType::
    rate ()
    {
      return this->_xsd_rate_;
    }

    void clInfoType::
    rate (const rate::type& rate)
    {
      this->_xsd_rate_.set (rate);
    }

    void clInfoType::
    rate (const rate::container& rate)
    {
      this->_xsd_rate_ = rate;
    }

    const clInfoType::bucket_depth::container& clInfoType::
    bucket_depth () const
    {
      return this->_xsd_bucket_depth_;
    }

    clInfoType::bucket_depth::container& clInfoType::
    bucket_depth ()
    {
      return this->_xsd_bucket_depth_;
    }

    void clInfoType::
    bucket_depth (const bucket_depth::type& bucket_depth)
    {
      this->_xsd_bucket_depth_.set (bucket_depth);
    }

    void clInfoType::
    bucket_depth (const bucket_depth::container& bucket_depth)
    {
      this->_xsd_bucket_depth_ = bucket_depth;
    }

    const clInfoType::channel::container& clInfoType::
    channel () const
    {
      return this->_xsd_channel_;
    }

    clInfoType::channel::container& clInfoType::
    channel ()
    {
      return this->_xsd_channel_;
    }

    void clInfoType::
    channel (const channel::type& channel)
    {
      this->_xsd_channel_.set (channel);
    }

    void clInfoType::
    channel (const channel::container& channel)
    {
      this->_xsd_channel_ = channel;
    }


    // linkType_base
    // 

    const linkType_base::clinfo::container& linkType_base::
    clinfo () const
    {
      return this->_xsd_clinfo_;
    }

    linkType_base::clinfo::container& linkType_base::
    clinfo ()
    {
      return this->_xsd_clinfo_;
    }

    void linkType_base::
    clinfo (const clinfo::type& clinfo)
    {
      this->_xsd_clinfo_.set (clinfo);
    }

    void linkType_base::
    clinfo (const clinfo::container& clinfo)
    {
      this->_xsd_clinfo_ = clinfo;
    }

    void linkType_base::
    clinfo (::std::auto_ptr< clinfo::type > clinfo)
    {
      this->_xsd_clinfo_.set (clinfo);
    }

    const linkType_base::remote_eid::type& linkType_base::
    remote_eid () const
    {
      return this->_xsd_remote_eid_.get ();
    }

    linkType_base::remote_eid::type& linkType_base::
    remote_eid ()
    {
      return this->_xsd_remote_eid_.get ();
    }

    void linkType_base::
    remote_eid (const remote_eid::type& remote_eid)
    {
      this->_xsd_remote_eid_.set (remote_eid);
    }

    void linkType_base::
    remote_eid (::std::auto_ptr< remote_eid::type > remote_eid)
    {
      this->_xsd_remote_eid_.set (remote_eid);
    }

    const linkType_base::type::type_& linkType_base::
    type () const
    {
      return this->_xsd_type_.get ();
    }

    linkType_base::type::type_& linkType_base::
    type ()
    {
      return this->_xsd_type_.get ();
    }

    void linkType_base::
    type (const type::type_& type)
    {
      this->_xsd_type_.set (type);
    }

    void linkType_base::
    type (::std::auto_ptr< type::type_ > type)
    {
      this->_xsd_type_.set (type);
    }

    const linkType_base::nexthop::type& linkType_base::
    nexthop () const
    {
      return this->_xsd_nexthop_.get ();
    }

    linkType_base::nexthop::type& linkType_base::
    nexthop ()
    {
      return this->_xsd_nexthop_.get ();
    }

    void linkType_base::
    nexthop (const nexthop::type& nexthop)
    {
      this->_xsd_nexthop_.set (nexthop);
    }

    void linkType_base::
    nexthop (::std::auto_ptr< nexthop::type > nexthop)
    {
      this->_xsd_nexthop_.set (nexthop);
    }

    const linkType_base::name::type& linkType_base::
    name () const
    {
      return this->_xsd_name_.get ();
    }

    linkType_base::name::type& linkType_base::
    name ()
    {
      return this->_xsd_name_.get ();
    }

    void linkType_base::
    name (const name::type& name)
    {
      this->_xsd_name_.set (name);
    }

    void linkType_base::
    name (::std::auto_ptr< name::type > name)
    {
      this->_xsd_name_.set (name);
    }

    const linkType_base::state::type& linkType_base::
    state () const
    {
      return this->_xsd_state_.get ();
    }

    linkType_base::state::type& linkType_base::
    state ()
    {
      return this->_xsd_state_.get ();
    }

    void linkType_base::
    state (const state::type& state)
    {
      this->_xsd_state_.set (state);
    }

    void linkType_base::
    state (::std::auto_ptr< state::type > state)
    {
      this->_xsd_state_.set (state);
    }

    const linkType_base::reliable::type& linkType_base::
    reliable () const
    {
      return this->_xsd_reliable_.get ();
    }

    linkType_base::reliable::type& linkType_base::
    reliable ()
    {
      return this->_xsd_reliable_.get ();
    }

    void linkType_base::
    reliable (const reliable::type& reliable)
    {
      this->_xsd_reliable_.set (reliable);
    }

    const linkType_base::clayer::type& linkType_base::
    clayer () const
    {
      return this->_xsd_clayer_.get ();
    }

    linkType_base::clayer::type& linkType_base::
    clayer ()
    {
      return this->_xsd_clayer_.get ();
    }

    void linkType_base::
    clayer (const clayer::type& clayer)
    {
      this->_xsd_clayer_.set (clayer);
    }

    void linkType_base::
    clayer (::std::auto_ptr< clayer::type > clayer)
    {
      this->_xsd_clayer_.set (clayer);
    }

    const linkType_base::min_retry_interval::type& linkType_base::
    min_retry_interval () const
    {
      return this->_xsd_min_retry_interval_.get ();
    }

    linkType_base::min_retry_interval::type& linkType_base::
    min_retry_interval ()
    {
      return this->_xsd_min_retry_interval_.get ();
    }

    void linkType_base::
    min_retry_interval (const min_retry_interval::type& min_retry_interval)
    {
      this->_xsd_min_retry_interval_.set (min_retry_interval);
    }

    const linkType_base::max_retry_interval::type& linkType_base::
    max_retry_interval () const
    {
      return this->_xsd_max_retry_interval_.get ();
    }

    linkType_base::max_retry_interval::type& linkType_base::
    max_retry_interval ()
    {
      return this->_xsd_max_retry_interval_.get ();
    }

    void linkType_base::
    max_retry_interval (const max_retry_interval::type& max_retry_interval)
    {
      this->_xsd_max_retry_interval_.set (max_retry_interval);
    }

    const linkType_base::idle_close_time::type& linkType_base::
    idle_close_time () const
    {
      return this->_xsd_idle_close_time_.get ();
    }

    linkType_base::idle_close_time::type& linkType_base::
    idle_close_time ()
    {
      return this->_xsd_idle_close_time_.get ();
    }

    void linkType_base::
    idle_close_time (const idle_close_time::type& idle_close_time)
    {
      this->_xsd_idle_close_time_.set (idle_close_time);
    }


    // routeEntryType_base
    // 

    const routeEntryType_base::dest_pattern::type& routeEntryType_base::
    dest_pattern () const
    {
      return this->_xsd_dest_pattern_.get ();
    }

    routeEntryType_base::dest_pattern::type& routeEntryType_base::
    dest_pattern ()
    {
      return this->_xsd_dest_pattern_.get ();
    }

    void routeEntryType_base::
    dest_pattern (const dest_pattern::type& dest_pattern)
    {
      this->_xsd_dest_pattern_.set (dest_pattern);
    }

    void routeEntryType_base::
    dest_pattern (::std::auto_ptr< dest_pattern::type > dest_pattern)
    {
      this->_xsd_dest_pattern_.set (dest_pattern);
    }

    const routeEntryType_base::source_pattern::type& routeEntryType_base::
    source_pattern () const
    {
      return this->_xsd_source_pattern_.get ();
    }

    routeEntryType_base::source_pattern::type& routeEntryType_base::
    source_pattern ()
    {
      return this->_xsd_source_pattern_.get ();
    }

    void routeEntryType_base::
    source_pattern (const source_pattern::type& source_pattern)
    {
      this->_xsd_source_pattern_.set (source_pattern);
    }

    void routeEntryType_base::
    source_pattern (::std::auto_ptr< source_pattern::type > source_pattern)
    {
      this->_xsd_source_pattern_.set (source_pattern);
    }

    const routeEntryType_base::route_priority::type& routeEntryType_base::
    route_priority () const
    {
      return this->_xsd_route_priority_.get ();
    }

    routeEntryType_base::route_priority::type& routeEntryType_base::
    route_priority ()
    {
      return this->_xsd_route_priority_.get ();
    }

    void routeEntryType_base::
    route_priority (const route_priority::type& route_priority)
    {
      this->_xsd_route_priority_.set (route_priority);
    }

    const routeEntryType_base::action::type& routeEntryType_base::
    action () const
    {
      return this->_xsd_action_.get ();
    }

    routeEntryType_base::action::type& routeEntryType_base::
    action ()
    {
      return this->_xsd_action_.get ();
    }

    void routeEntryType_base::
    action (const action::type& action)
    {
      this->_xsd_action_.set (action);
    }

    void routeEntryType_base::
    action (::std::auto_ptr< action::type > action)
    {
      this->_xsd_action_.set (action);
    }

    const routeEntryType_base::link::type& routeEntryType_base::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    routeEntryType_base::link::type& routeEntryType_base::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void routeEntryType_base::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void routeEntryType_base::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }


    // registrationType_base
    // 

    const registrationType_base::endpoint::type& registrationType_base::
    endpoint () const
    {
      return this->_xsd_endpoint_.get ();
    }

    registrationType_base::endpoint::type& registrationType_base::
    endpoint ()
    {
      return this->_xsd_endpoint_.get ();
    }

    void registrationType_base::
    endpoint (const endpoint::type& endpoint)
    {
      this->_xsd_endpoint_.set (endpoint);
    }

    void registrationType_base::
    endpoint (::std::auto_ptr< endpoint::type > endpoint)
    {
      this->_xsd_endpoint_.set (endpoint);
    }

    const registrationType_base::regid::type& registrationType_base::
    regid () const
    {
      return this->_xsd_regid_.get ();
    }

    registrationType_base::regid::type& registrationType_base::
    regid ()
    {
      return this->_xsd_regid_.get ();
    }

    void registrationType_base::
    regid (const regid::type& regid)
    {
      this->_xsd_regid_.set (regid);
    }

    const registrationType_base::action::type& registrationType_base::
    action () const
    {
      return this->_xsd_action_.get ();
    }

    registrationType_base::action::type& registrationType_base::
    action ()
    {
      return this->_xsd_action_.get ();
    }

    void registrationType_base::
    action (const action::type& action)
    {
      this->_xsd_action_.set (action);
    }

    void registrationType_base::
    action (::std::auto_ptr< action::type > action)
    {
      this->_xsd_action_.set (action);
    }

    const registrationType_base::script::type& registrationType_base::
    script () const
    {
      return this->_xsd_script_.get ();
    }

    registrationType_base::script::type& registrationType_base::
    script ()
    {
      return this->_xsd_script_.get ();
    }

    void registrationType_base::
    script (const script::type& script)
    {
      this->_xsd_script_.set (script);
    }

    void registrationType_base::
    script (::std::auto_ptr< script::type > script)
    {
      this->_xsd_script_.set (script);
    }

    const registrationType_base::expiration::type& registrationType_base::
    expiration () const
    {
      return this->_xsd_expiration_.get ();
    }

    registrationType_base::expiration::type& registrationType_base::
    expiration ()
    {
      return this->_xsd_expiration_.get ();
    }

    void registrationType_base::
    expiration (const expiration::type& expiration)
    {
      this->_xsd_expiration_.set (expiration);
    }


    // bundle_received_event
    // 

    const bundle_received_event::bundle::type& bundle_received_event::
    bundle () const
    {
      return this->_xsd_bundle_.get ();
    }

    bundle_received_event::bundle::type& bundle_received_event::
    bundle ()
    {
      return this->_xsd_bundle_.get ();
    }

    void bundle_received_event::
    bundle (const bundle::type& bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    void bundle_received_event::
    bundle (::std::auto_ptr< bundle::type > bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    const bundle_received_event::source::type& bundle_received_event::
    source () const
    {
      return this->_xsd_source_.get ();
    }

    bundle_received_event::source::type& bundle_received_event::
    source ()
    {
      return this->_xsd_source_.get ();
    }

    void bundle_received_event::
    source (const source::type& source)
    {
      this->_xsd_source_.set (source);
    }

    void bundle_received_event::
    source (::std::auto_ptr< source::type > source)
    {
      this->_xsd_source_.set (source);
    }

    const bundle_received_event::bytes_received::type& bundle_received_event::
    bytes_received () const
    {
      return this->_xsd_bytes_received_.get ();
    }

    bundle_received_event::bytes_received::type& bundle_received_event::
    bytes_received ()
    {
      return this->_xsd_bytes_received_.get ();
    }

    void bundle_received_event::
    bytes_received (const bytes_received::type& bytes_received)
    {
      this->_xsd_bytes_received_.set (bytes_received);
    }


    // bundle_transmitted_event
    // 

    const bundle_transmitted_event::bundle::type& bundle_transmitted_event::
    bundle () const
    {
      return this->_xsd_bundle_.get ();
    }

    bundle_transmitted_event::bundle::type& bundle_transmitted_event::
    bundle ()
    {
      return this->_xsd_bundle_.get ();
    }

    void bundle_transmitted_event::
    bundle (const bundle::type& bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    void bundle_transmitted_event::
    bundle (::std::auto_ptr< bundle::type > bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    const bundle_transmitted_event::contact::type& bundle_transmitted_event::
    contact () const
    {
      return this->_xsd_contact_.get ();
    }

    bundle_transmitted_event::contact::type& bundle_transmitted_event::
    contact ()
    {
      return this->_xsd_contact_.get ();
    }

    void bundle_transmitted_event::
    contact (const contact::type& contact)
    {
      this->_xsd_contact_.set (contact);
    }

    void bundle_transmitted_event::
    contact (::std::auto_ptr< contact::type > contact)
    {
      this->_xsd_contact_.set (contact);
    }

    const bundle_transmitted_event::link::type& bundle_transmitted_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    bundle_transmitted_event::link::type& bundle_transmitted_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void bundle_transmitted_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void bundle_transmitted_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const bundle_transmitted_event::bytes_sent::type& bundle_transmitted_event::
    bytes_sent () const
    {
      return this->_xsd_bytes_sent_.get ();
    }

    bundle_transmitted_event::bytes_sent::type& bundle_transmitted_event::
    bytes_sent ()
    {
      return this->_xsd_bytes_sent_.get ();
    }

    void bundle_transmitted_event::
    bytes_sent (const bytes_sent::type& bytes_sent)
    {
      this->_xsd_bytes_sent_.set (bytes_sent);
    }

    const bundle_transmitted_event::reliably_sent::type& bundle_transmitted_event::
    reliably_sent () const
    {
      return this->_xsd_reliably_sent_.get ();
    }

    bundle_transmitted_event::reliably_sent::type& bundle_transmitted_event::
    reliably_sent ()
    {
      return this->_xsd_reliably_sent_.get ();
    }

    void bundle_transmitted_event::
    reliably_sent (const reliably_sent::type& reliably_sent)
    {
      this->_xsd_reliably_sent_.set (reliably_sent);
    }


    // bundle_transmit_failed_event
    // 

    const bundle_transmit_failed_event::bundle::type& bundle_transmit_failed_event::
    bundle () const
    {
      return this->_xsd_bundle_.get ();
    }

    bundle_transmit_failed_event::bundle::type& bundle_transmit_failed_event::
    bundle ()
    {
      return this->_xsd_bundle_.get ();
    }

    void bundle_transmit_failed_event::
    bundle (const bundle::type& bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    void bundle_transmit_failed_event::
    bundle (::std::auto_ptr< bundle::type > bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    const bundle_transmit_failed_event::contact::type& bundle_transmit_failed_event::
    contact () const
    {
      return this->_xsd_contact_.get ();
    }

    bundle_transmit_failed_event::contact::type& bundle_transmit_failed_event::
    contact ()
    {
      return this->_xsd_contact_.get ();
    }

    void bundle_transmit_failed_event::
    contact (const contact::type& contact)
    {
      this->_xsd_contact_.set (contact);
    }

    void bundle_transmit_failed_event::
    contact (::std::auto_ptr< contact::type > contact)
    {
      this->_xsd_contact_.set (contact);
    }

    const bundle_transmit_failed_event::link::type& bundle_transmit_failed_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    bundle_transmit_failed_event::link::type& bundle_transmit_failed_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void bundle_transmit_failed_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void bundle_transmit_failed_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }


    // bundle_delivery_event
    // 

    const bundle_delivery_event::bundle::type& bundle_delivery_event::
    bundle () const
    {
      return this->_xsd_bundle_.get ();
    }

    bundle_delivery_event::bundle::type& bundle_delivery_event::
    bundle ()
    {
      return this->_xsd_bundle_.get ();
    }

    void bundle_delivery_event::
    bundle (const bundle::type& bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    void bundle_delivery_event::
    bundle (::std::auto_ptr< bundle::type > bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    const bundle_delivery_event::source::type& bundle_delivery_event::
    source () const
    {
      return this->_xsd_source_.get ();
    }

    bundle_delivery_event::source::type& bundle_delivery_event::
    source ()
    {
      return this->_xsd_source_.get ();
    }

    void bundle_delivery_event::
    source (const source::type& source)
    {
      this->_xsd_source_.set (source);
    }

    void bundle_delivery_event::
    source (::std::auto_ptr< source::type > source)
    {
      this->_xsd_source_.set (source);
    }


    // bundle_expired_event
    // 

    const bundle_expired_event::bundle::type& bundle_expired_event::
    bundle () const
    {
      return this->_xsd_bundle_.get ();
    }

    bundle_expired_event::bundle::type& bundle_expired_event::
    bundle ()
    {
      return this->_xsd_bundle_.get ();
    }

    void bundle_expired_event::
    bundle (const bundle::type& bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    void bundle_expired_event::
    bundle (::std::auto_ptr< bundle::type > bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }


    // contact_up_event
    // 

    const contact_up_event::contact::type& contact_up_event::
    contact () const
    {
      return this->_xsd_contact_.get ();
    }

    contact_up_event::contact::type& contact_up_event::
    contact ()
    {
      return this->_xsd_contact_.get ();
    }

    void contact_up_event::
    contact (const contact::type& contact)
    {
      this->_xsd_contact_.set (contact);
    }

    void contact_up_event::
    contact (::std::auto_ptr< contact::type > contact)
    {
      this->_xsd_contact_.set (contact);
    }


    // contact_down_event
    // 

    const contact_down_event::contact::type& contact_down_event::
    contact () const
    {
      return this->_xsd_contact_.get ();
    }

    contact_down_event::contact::type& contact_down_event::
    contact ()
    {
      return this->_xsd_contact_.get ();
    }

    void contact_down_event::
    contact (const contact::type& contact)
    {
      this->_xsd_contact_.set (contact);
    }

    void contact_down_event::
    contact (::std::auto_ptr< contact::type > contact)
    {
      this->_xsd_contact_.set (contact);
    }

    const contact_down_event::reason::type& contact_down_event::
    reason () const
    {
      return this->_xsd_reason_.get ();
    }

    contact_down_event::reason::type& contact_down_event::
    reason ()
    {
      return this->_xsd_reason_.get ();
    }

    void contact_down_event::
    reason (const reason::type& reason)
    {
      this->_xsd_reason_.set (reason);
    }

    void contact_down_event::
    reason (::std::auto_ptr< reason::type > reason)
    {
      this->_xsd_reason_.set (reason);
    }


    // link_created_event
    // 

    const link_created_event::link::type& link_created_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    link_created_event::link::type& link_created_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void link_created_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void link_created_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const link_created_event::reason::type& link_created_event::
    reason () const
    {
      return this->_xsd_reason_.get ();
    }

    link_created_event::reason::type& link_created_event::
    reason ()
    {
      return this->_xsd_reason_.get ();
    }

    void link_created_event::
    reason (const reason::type& reason)
    {
      this->_xsd_reason_.set (reason);
    }

    void link_created_event::
    reason (::std::auto_ptr< reason::type > reason)
    {
      this->_xsd_reason_.set (reason);
    }


    // link_deleted_event
    // 

    const link_deleted_event::link::type& link_deleted_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    link_deleted_event::link::type& link_deleted_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void link_deleted_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void link_deleted_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const link_deleted_event::reason::type& link_deleted_event::
    reason () const
    {
      return this->_xsd_reason_.get ();
    }

    link_deleted_event::reason::type& link_deleted_event::
    reason ()
    {
      return this->_xsd_reason_.get ();
    }

    void link_deleted_event::
    reason (const reason::type& reason)
    {
      this->_xsd_reason_.set (reason);
    }

    void link_deleted_event::
    reason (::std::auto_ptr< reason::type > reason)
    {
      this->_xsd_reason_.set (reason);
    }


    // link_available_event
    // 

    const link_available_event::link::type& link_available_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    link_available_event::link::type& link_available_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void link_available_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void link_available_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const link_available_event::reason::type& link_available_event::
    reason () const
    {
      return this->_xsd_reason_.get ();
    }

    link_available_event::reason::type& link_available_event::
    reason ()
    {
      return this->_xsd_reason_.get ();
    }

    void link_available_event::
    reason (const reason::type& reason)
    {
      this->_xsd_reason_.set (reason);
    }

    void link_available_event::
    reason (::std::auto_ptr< reason::type > reason)
    {
      this->_xsd_reason_.set (reason);
    }


    // link_unavailable_event
    // 

    const link_unavailable_event::link::type& link_unavailable_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    link_unavailable_event::link::type& link_unavailable_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void link_unavailable_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void link_unavailable_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const link_unavailable_event::reason::type& link_unavailable_event::
    reason () const
    {
      return this->_xsd_reason_.get ();
    }

    link_unavailable_event::reason::type& link_unavailable_event::
    reason ()
    {
      return this->_xsd_reason_.get ();
    }

    void link_unavailable_event::
    reason (const reason::type& reason)
    {
      this->_xsd_reason_.set (reason);
    }

    void link_unavailable_event::
    reason (::std::auto_ptr< reason::type > reason)
    {
      this->_xsd_reason_.set (reason);
    }


    // link_busy_event
    // 

    const link_busy_event::link::type& link_busy_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    link_busy_event::link::type& link_busy_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void link_busy_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void link_busy_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }


    // route_add_event
    // 

    const route_add_event::route_entry::type& route_add_event::
    route_entry () const
    {
      return this->_xsd_route_entry_.get ();
    }

    route_add_event::route_entry::type& route_add_event::
    route_entry ()
    {
      return this->_xsd_route_entry_.get ();
    }

    void route_add_event::
    route_entry (const route_entry::type& route_entry)
    {
      this->_xsd_route_entry_.set (route_entry);
    }

    void route_add_event::
    route_entry (::std::auto_ptr< route_entry::type > route_entry)
    {
      this->_xsd_route_entry_.set (route_entry);
    }


    // route_delete_event
    // 

    const route_delete_event::dest::type& route_delete_event::
    dest () const
    {
      return this->_xsd_dest_.get ();
    }

    route_delete_event::dest::type& route_delete_event::
    dest ()
    {
      return this->_xsd_dest_.get ();
    }

    void route_delete_event::
    dest (const dest::type& dest)
    {
      this->_xsd_dest_.set (dest);
    }

    void route_delete_event::
    dest (::std::auto_ptr< dest::type > dest)
    {
      this->_xsd_dest_.set (dest);
    }


    // custody_signal_event
    // 

    const custody_signal_event::orig_source_eid::type& custody_signal_event::
    orig_source_eid () const
    {
      return this->_xsd_orig_source_eid_.get ();
    }

    custody_signal_event::orig_source_eid::type& custody_signal_event::
    orig_source_eid ()
    {
      return this->_xsd_orig_source_eid_.get ();
    }

    void custody_signal_event::
    orig_source_eid (const orig_source_eid::type& orig_source_eid)
    {
      this->_xsd_orig_source_eid_.set (orig_source_eid);
    }

    void custody_signal_event::
    orig_source_eid (::std::auto_ptr< orig_source_eid::type > orig_source_eid)
    {
      this->_xsd_orig_source_eid_.set (orig_source_eid);
    }

    const custody_signal_event::admin_type::type& custody_signal_event::
    admin_type () const
    {
      return this->_xsd_admin_type_.get ();
    }

    custody_signal_event::admin_type::type& custody_signal_event::
    admin_type ()
    {
      return this->_xsd_admin_type_.get ();
    }

    void custody_signal_event::
    admin_type (const admin_type::type& admin_type)
    {
      this->_xsd_admin_type_.set (admin_type);
    }

    const custody_signal_event::admin_flags::type& custody_signal_event::
    admin_flags () const
    {
      return this->_xsd_admin_flags_.get ();
    }

    custody_signal_event::admin_flags::type& custody_signal_event::
    admin_flags ()
    {
      return this->_xsd_admin_flags_.get ();
    }

    void custody_signal_event::
    admin_flags (const admin_flags::type& admin_flags)
    {
      this->_xsd_admin_flags_.set (admin_flags);
    }

    const custody_signal_event::succeeded::type& custody_signal_event::
    succeeded () const
    {
      return this->_xsd_succeeded_.get ();
    }

    custody_signal_event::succeeded::type& custody_signal_event::
    succeeded ()
    {
      return this->_xsd_succeeded_.get ();
    }

    void custody_signal_event::
    succeeded (const succeeded::type& succeeded)
    {
      this->_xsd_succeeded_.set (succeeded);
    }

    const custody_signal_event::reason::type& custody_signal_event::
    reason () const
    {
      return this->_xsd_reason_.get ();
    }

    custody_signal_event::reason::type& custody_signal_event::
    reason ()
    {
      return this->_xsd_reason_.get ();
    }

    void custody_signal_event::
    reason (const reason::type& reason)
    {
      this->_xsd_reason_.set (reason);
    }

    const custody_signal_event::orig_frag_offset::type& custody_signal_event::
    orig_frag_offset () const
    {
      return this->_xsd_orig_frag_offset_.get ();
    }

    custody_signal_event::orig_frag_offset::type& custody_signal_event::
    orig_frag_offset ()
    {
      return this->_xsd_orig_frag_offset_.get ();
    }

    void custody_signal_event::
    orig_frag_offset (const orig_frag_offset::type& orig_frag_offset)
    {
      this->_xsd_orig_frag_offset_.set (orig_frag_offset);
    }

    const custody_signal_event::orig_frag_length::type& custody_signal_event::
    orig_frag_length () const
    {
      return this->_xsd_orig_frag_length_.get ();
    }

    custody_signal_event::orig_frag_length::type& custody_signal_event::
    orig_frag_length ()
    {
      return this->_xsd_orig_frag_length_.get ();
    }

    void custody_signal_event::
    orig_frag_length (const orig_frag_length::type& orig_frag_length)
    {
      this->_xsd_orig_frag_length_.set (orig_frag_length);
    }

    const custody_signal_event::custody_signal_seconds::type& custody_signal_event::
    custody_signal_seconds () const
    {
      return this->_xsd_custody_signal_seconds_.get ();
    }

    custody_signal_event::custody_signal_seconds::type& custody_signal_event::
    custody_signal_seconds ()
    {
      return this->_xsd_custody_signal_seconds_.get ();
    }

    void custody_signal_event::
    custody_signal_seconds (const custody_signal_seconds::type& custody_signal_seconds)
    {
      this->_xsd_custody_signal_seconds_.set (custody_signal_seconds);
    }

    const custody_signal_event::custody_signal_seqno::type& custody_signal_event::
    custody_signal_seqno () const
    {
      return this->_xsd_custody_signal_seqno_.get ();
    }

    custody_signal_event::custody_signal_seqno::type& custody_signal_event::
    custody_signal_seqno ()
    {
      return this->_xsd_custody_signal_seqno_.get ();
    }

    void custody_signal_event::
    custody_signal_seqno (const custody_signal_seqno::type& custody_signal_seqno)
    {
      this->_xsd_custody_signal_seqno_.set (custody_signal_seqno);
    }

    const custody_signal_event::orig_creation_seconds::type& custody_signal_event::
    orig_creation_seconds () const
    {
      return this->_xsd_orig_creation_seconds_.get ();
    }

    custody_signal_event::orig_creation_seconds::type& custody_signal_event::
    orig_creation_seconds ()
    {
      return this->_xsd_orig_creation_seconds_.get ();
    }

    void custody_signal_event::
    orig_creation_seconds (const orig_creation_seconds::type& orig_creation_seconds)
    {
      this->_xsd_orig_creation_seconds_.set (orig_creation_seconds);
    }

    const custody_signal_event::orig_creation_seqno::type& custody_signal_event::
    orig_creation_seqno () const
    {
      return this->_xsd_orig_creation_seqno_.get ();
    }

    custody_signal_event::orig_creation_seqno::type& custody_signal_event::
    orig_creation_seqno ()
    {
      return this->_xsd_orig_creation_seqno_.get ();
    }

    void custody_signal_event::
    orig_creation_seqno (const orig_creation_seqno::type& orig_creation_seqno)
    {
      this->_xsd_orig_creation_seqno_.set (orig_creation_seqno);
    }


    // custody_timeout_event
    // 

    const custody_timeout_event::bundle::type& custody_timeout_event::
    bundle () const
    {
      return this->_xsd_bundle_.get ();
    }

    custody_timeout_event::bundle::type& custody_timeout_event::
    bundle ()
    {
      return this->_xsd_bundle_.get ();
    }

    void custody_timeout_event::
    bundle (const bundle::type& bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    void custody_timeout_event::
    bundle (::std::auto_ptr< bundle::type > bundle)
    {
      this->_xsd_bundle_.set (bundle);
    }

    const custody_timeout_event::link::type& custody_timeout_event::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    custody_timeout_event::link::type& custody_timeout_event::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void custody_timeout_event::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void custody_timeout_event::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }


    // registration_added_event
    // 

    const registration_added_event::registration::type& registration_added_event::
    registration () const
    {
      return this->_xsd_registration_.get ();
    }

    registration_added_event::registration::type& registration_added_event::
    registration ()
    {
      return this->_xsd_registration_.get ();
    }

    void registration_added_event::
    registration (const registration::type& registration)
    {
      this->_xsd_registration_.set (registration);
    }

    void registration_added_event::
    registration (::std::auto_ptr< registration::type > registration)
    {
      this->_xsd_registration_.set (registration);
    }

    const registration_added_event::source::type& registration_added_event::
    source () const
    {
      return this->_xsd_source_.get ();
    }

    registration_added_event::source::type& registration_added_event::
    source ()
    {
      return this->_xsd_source_.get ();
    }

    void registration_added_event::
    source (const source::type& source)
    {
      this->_xsd_source_.set (source);
    }

    void registration_added_event::
    source (::std::auto_ptr< source::type > source)
    {
      this->_xsd_source_.set (source);
    }


    // registration_removed_event
    // 

    const registration_removed_event::registration::type& registration_removed_event::
    registration () const
    {
      return this->_xsd_registration_.get ();
    }

    registration_removed_event::registration::type& registration_removed_event::
    registration ()
    {
      return this->_xsd_registration_.get ();
    }

    void registration_removed_event::
    registration (const registration::type& registration)
    {
      this->_xsd_registration_.set (registration);
    }

    void registration_removed_event::
    registration (::std::auto_ptr< registration::type > registration)
    {
      this->_xsd_registration_.set (registration);
    }


    // registration_expired_event
    // 

    const registration_expired_event::regid::type& registration_expired_event::
    regid () const
    {
      return this->_xsd_regid_.get ();
    }

    registration_expired_event::regid::type& registration_expired_event::
    regid ()
    {
      return this->_xsd_regid_.get ();
    }

    void registration_expired_event::
    regid (const regid::type& regid)
    {
      this->_xsd_regid_.set (regid);
    }


    // open_link_request
    // 

    const open_link_request::link::type& open_link_request::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    open_link_request::link::type& open_link_request::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void open_link_request::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void open_link_request::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }


    // send_bundle_request
    // 

    const send_bundle_request::bundleid::type& send_bundle_request::
    bundleid () const
    {
      return this->_xsd_bundleid_.get ();
    }

    send_bundle_request::bundleid::type& send_bundle_request::
    bundleid ()
    {
      return this->_xsd_bundleid_.get ();
    }

    void send_bundle_request::
    bundleid (const bundleid::type& bundleid)
    {
      this->_xsd_bundleid_.set (bundleid);
    }

    const send_bundle_request::link::type& send_bundle_request::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    send_bundle_request::link::type& send_bundle_request::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void send_bundle_request::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void send_bundle_request::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const send_bundle_request::fwd_action::type& send_bundle_request::
    fwd_action () const
    {
      return this->_xsd_fwd_action_.get ();
    }

    send_bundle_request::fwd_action::type& send_bundle_request::
    fwd_action ()
    {
      return this->_xsd_fwd_action_.get ();
    }

    void send_bundle_request::
    fwd_action (const fwd_action::type& fwd_action)
    {
      this->_xsd_fwd_action_.set (fwd_action);
    }

    void send_bundle_request::
    fwd_action (::std::auto_ptr< fwd_action::type > fwd_action)
    {
      this->_xsd_fwd_action_.set (fwd_action);
    }


    // cancel_bundle_request
    // 

    const cancel_bundle_request::bundleid::type& cancel_bundle_request::
    bundleid () const
    {
      return this->_xsd_bundleid_.get ();
    }

    cancel_bundle_request::bundleid::type& cancel_bundle_request::
    bundleid ()
    {
      return this->_xsd_bundleid_.get ();
    }

    void cancel_bundle_request::
    bundleid (const bundleid::type& bundleid)
    {
      this->_xsd_bundleid_.set (bundleid);
    }

    const cancel_bundle_request::link::type& cancel_bundle_request::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    cancel_bundle_request::link::type& cancel_bundle_request::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void cancel_bundle_request::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void cancel_bundle_request::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }


    // inject_bundle_request
    // 

    const inject_bundle_request::source::type& inject_bundle_request::
    source () const
    {
      return this->_xsd_source_.get ();
    }

    inject_bundle_request::source::type& inject_bundle_request::
    source ()
    {
      return this->_xsd_source_.get ();
    }

    void inject_bundle_request::
    source (const source::type& source)
    {
      this->_xsd_source_.set (source);
    }

    void inject_bundle_request::
    source (::std::auto_ptr< source::type > source)
    {
      this->_xsd_source_.set (source);
    }

    const inject_bundle_request::dest::type& inject_bundle_request::
    dest () const
    {
      return this->_xsd_dest_.get ();
    }

    inject_bundle_request::dest::type& inject_bundle_request::
    dest ()
    {
      return this->_xsd_dest_.get ();
    }

    void inject_bundle_request::
    dest (const dest::type& dest)
    {
      this->_xsd_dest_.set (dest);
    }

    void inject_bundle_request::
    dest (::std::auto_ptr< dest::type > dest)
    {
      this->_xsd_dest_.set (dest);
    }

    const inject_bundle_request::replyto::container& inject_bundle_request::
    replyto () const
    {
      return this->_xsd_replyto_;
    }

    inject_bundle_request::replyto::container& inject_bundle_request::
    replyto ()
    {
      return this->_xsd_replyto_;
    }

    void inject_bundle_request::
    replyto (const replyto::type& replyto)
    {
      this->_xsd_replyto_.set (replyto);
    }

    void inject_bundle_request::
    replyto (const replyto::container& replyto)
    {
      this->_xsd_replyto_ = replyto;
    }

    void inject_bundle_request::
    replyto (::std::auto_ptr< replyto::type > replyto)
    {
      this->_xsd_replyto_.set (replyto);
    }

    const inject_bundle_request::custodian::container& inject_bundle_request::
    custodian () const
    {
      return this->_xsd_custodian_;
    }

    inject_bundle_request::custodian::container& inject_bundle_request::
    custodian ()
    {
      return this->_xsd_custodian_;
    }

    void inject_bundle_request::
    custodian (const custodian::type& custodian)
    {
      this->_xsd_custodian_.set (custodian);
    }

    void inject_bundle_request::
    custodian (const custodian::container& custodian)
    {
      this->_xsd_custodian_ = custodian;
    }

    void inject_bundle_request::
    custodian (::std::auto_ptr< custodian::type > custodian)
    {
      this->_xsd_custodian_.set (custodian);
    }

    const inject_bundle_request::link::type& inject_bundle_request::
    link () const
    {
      return this->_xsd_link_.get ();
    }

    inject_bundle_request::link::type& inject_bundle_request::
    link ()
    {
      return this->_xsd_link_.get ();
    }

    void inject_bundle_request::
    link (const link::type& link)
    {
      this->_xsd_link_.set (link);
    }

    void inject_bundle_request::
    link (::std::auto_ptr< link::type > link)
    {
      this->_xsd_link_.set (link);
    }

    const inject_bundle_request::fwd_action::container& inject_bundle_request::
    fwd_action () const
    {
      return this->_xsd_fwd_action_;
    }

    inject_bundle_request::fwd_action::container& inject_bundle_request::
    fwd_action ()
    {
      return this->_xsd_fwd_action_;
    }

    void inject_bundle_request::
    fwd_action (const fwd_action::type& fwd_action)
    {
      this->_xsd_fwd_action_.set (fwd_action);
    }

    void inject_bundle_request::
    fwd_action (const fwd_action::container& fwd_action)
    {
      this->_xsd_fwd_action_ = fwd_action;
    }

    void inject_bundle_request::
    fwd_action (::std::auto_ptr< fwd_action::type > fwd_action)
    {
      this->_xsd_fwd_action_.set (fwd_action);
    }

    const inject_bundle_request::priority::container& inject_bundle_request::
    priority () const
    {
      return this->_xsd_priority_;
    }

    inject_bundle_request::priority::container& inject_bundle_request::
    priority ()
    {
      return this->_xsd_priority_;
    }

    void inject_bundle_request::
    priority (const priority::type& priority)
    {
      this->_xsd_priority_.set (priority);
    }

    void inject_bundle_request::
    priority (const priority::container& priority)
    {
      this->_xsd_priority_ = priority;
    }

    void inject_bundle_request::
    priority (::std::auto_ptr< priority::type > priority)
    {
      this->_xsd_priority_.set (priority);
    }

    const inject_bundle_request::expiration::container& inject_bundle_request::
    expiration () const
    {
      return this->_xsd_expiration_;
    }

    inject_bundle_request::expiration::container& inject_bundle_request::
    expiration ()
    {
      return this->_xsd_expiration_;
    }

    void inject_bundle_request::
    expiration (const expiration::type& expiration)
    {
      this->_xsd_expiration_.set (expiration);
    }

    void inject_bundle_request::
    expiration (const expiration::container& expiration)
    {
      this->_xsd_expiration_ = expiration;
    }

    const inject_bundle_request::payload::type& inject_bundle_request::
    payload () const
    {
      return this->_xsd_payload_.get ();
    }

    inject_bundle_request::payload::type& inject_bundle_request::
    payload ()
    {
      return this->_xsd_payload_.get ();
    }

    void inject_bundle_request::
    payload (const payload::type& payload)
    {
      this->_xsd_payload_.set (payload);
    }

    void inject_bundle_request::
    payload (::std::auto_ptr< payload::type > payload)
    {
      this->_xsd_payload_.set (payload);
    }


    // link_report
    // 

    const link_report::link::container& link_report::
    link () const
    {
      return this->_xsd_link_;
    }

    link_report::link::container& link_report::
    link ()
    {
      return this->_xsd_link_;
    }

    void link_report::
    link (const link::container& link)
    {
      this->_xsd_link_ = link;
    }


    // contact_report
    // 

    const contact_report::contact::container& contact_report::
    contact () const
    {
      return this->_xsd_contact_;
    }

    contact_report::contact::container& contact_report::
    contact ()
    {
      return this->_xsd_contact_;
    }

    void contact_report::
    contact (const contact::container& contact)
    {
      this->_xsd_contact_ = contact;
    }


    // route_report
    // 

    const route_report::route_entry::container& route_report::
    route_entry () const
    {
      return this->_xsd_route_entry_;
    }

    route_report::route_entry::container& route_report::
    route_entry ()
    {
      return this->_xsd_route_entry_;
    }

    void route_report::
    route_entry (const route_entry::container& route_entry)
    {
      this->_xsd_route_entry_ = route_entry;
    }


    // bundle_report
    // 

    const bundle_report::bundle::container& bundle_report::
    bundle () const
    {
      return this->_xsd_bundle_;
    }

    bundle_report::bundle::container& bundle_report::
    bundle ()
    {
      return this->_xsd_bundle_;
    }

    void bundle_report::
    bundle (const bundle::container& bundle)
    {
      this->_xsd_bundle_ = bundle;
    }


    // dtn
    // 

    const dtn::bundle_received_event::container& dtn::
    bundle_received_event () const
    {
      return this->_xsd_bundle_received_event_;
    }

    dtn::bundle_received_event::container& dtn::
    bundle_received_event ()
    {
      return this->_xsd_bundle_received_event_;
    }

    void dtn::
    bundle_received_event (const bundle_received_event::type& bundle_received_event)
    {
      this->_xsd_bundle_received_event_.set (bundle_received_event);
    }

    void dtn::
    bundle_received_event (const bundle_received_event::container& bundle_received_event)
    {
      this->_xsd_bundle_received_event_ = bundle_received_event;
    }

    void dtn::
    bundle_received_event (::std::auto_ptr< bundle_received_event::type > bundle_received_event)
    {
      this->_xsd_bundle_received_event_.set (bundle_received_event);
    }

    const dtn::bundle_transmitted_event::container& dtn::
    bundle_transmitted_event () const
    {
      return this->_xsd_bundle_transmitted_event_;
    }

    dtn::bundle_transmitted_event::container& dtn::
    bundle_transmitted_event ()
    {
      return this->_xsd_bundle_transmitted_event_;
    }

    void dtn::
    bundle_transmitted_event (const bundle_transmitted_event::type& bundle_transmitted_event)
    {
      this->_xsd_bundle_transmitted_event_.set (bundle_transmitted_event);
    }

    void dtn::
    bundle_transmitted_event (const bundle_transmitted_event::container& bundle_transmitted_event)
    {
      this->_xsd_bundle_transmitted_event_ = bundle_transmitted_event;
    }

    void dtn::
    bundle_transmitted_event (::std::auto_ptr< bundle_transmitted_event::type > bundle_transmitted_event)
    {
      this->_xsd_bundle_transmitted_event_.set (bundle_transmitted_event);
    }

    const dtn::bundle_transmit_failed_event::container& dtn::
    bundle_transmit_failed_event () const
    {
      return this->_xsd_bundle_transmit_failed_event_;
    }

    dtn::bundle_transmit_failed_event::container& dtn::
    bundle_transmit_failed_event ()
    {
      return this->_xsd_bundle_transmit_failed_event_;
    }

    void dtn::
    bundle_transmit_failed_event (const bundle_transmit_failed_event::type& bundle_transmit_failed_event)
    {
      this->_xsd_bundle_transmit_failed_event_.set (bundle_transmit_failed_event);
    }

    void dtn::
    bundle_transmit_failed_event (const bundle_transmit_failed_event::container& bundle_transmit_failed_event)
    {
      this->_xsd_bundle_transmit_failed_event_ = bundle_transmit_failed_event;
    }

    void dtn::
    bundle_transmit_failed_event (::std::auto_ptr< bundle_transmit_failed_event::type > bundle_transmit_failed_event)
    {
      this->_xsd_bundle_transmit_failed_event_.set (bundle_transmit_failed_event);
    }

    const dtn::bundle_delivery_event::container& dtn::
    bundle_delivery_event () const
    {
      return this->_xsd_bundle_delivery_event_;
    }

    dtn::bundle_delivery_event::container& dtn::
    bundle_delivery_event ()
    {
      return this->_xsd_bundle_delivery_event_;
    }

    void dtn::
    bundle_delivery_event (const bundle_delivery_event::type& bundle_delivery_event)
    {
      this->_xsd_bundle_delivery_event_.set (bundle_delivery_event);
    }

    void dtn::
    bundle_delivery_event (const bundle_delivery_event::container& bundle_delivery_event)
    {
      this->_xsd_bundle_delivery_event_ = bundle_delivery_event;
    }

    void dtn::
    bundle_delivery_event (::std::auto_ptr< bundle_delivery_event::type > bundle_delivery_event)
    {
      this->_xsd_bundle_delivery_event_.set (bundle_delivery_event);
    }

    const dtn::bundle_expired_event::container& dtn::
    bundle_expired_event () const
    {
      return this->_xsd_bundle_expired_event_;
    }

    dtn::bundle_expired_event::container& dtn::
    bundle_expired_event ()
    {
      return this->_xsd_bundle_expired_event_;
    }

    void dtn::
    bundle_expired_event (const bundle_expired_event::type& bundle_expired_event)
    {
      this->_xsd_bundle_expired_event_.set (bundle_expired_event);
    }

    void dtn::
    bundle_expired_event (const bundle_expired_event::container& bundle_expired_event)
    {
      this->_xsd_bundle_expired_event_ = bundle_expired_event;
    }

    void dtn::
    bundle_expired_event (::std::auto_ptr< bundle_expired_event::type > bundle_expired_event)
    {
      this->_xsd_bundle_expired_event_.set (bundle_expired_event);
    }

    const dtn::contact_up_event::container& dtn::
    contact_up_event () const
    {
      return this->_xsd_contact_up_event_;
    }

    dtn::contact_up_event::container& dtn::
    contact_up_event ()
    {
      return this->_xsd_contact_up_event_;
    }

    void dtn::
    contact_up_event (const contact_up_event::type& contact_up_event)
    {
      this->_xsd_contact_up_event_.set (contact_up_event);
    }

    void dtn::
    contact_up_event (const contact_up_event::container& contact_up_event)
    {
      this->_xsd_contact_up_event_ = contact_up_event;
    }

    void dtn::
    contact_up_event (::std::auto_ptr< contact_up_event::type > contact_up_event)
    {
      this->_xsd_contact_up_event_.set (contact_up_event);
    }

    const dtn::contact_down_event::container& dtn::
    contact_down_event () const
    {
      return this->_xsd_contact_down_event_;
    }

    dtn::contact_down_event::container& dtn::
    contact_down_event ()
    {
      return this->_xsd_contact_down_event_;
    }

    void dtn::
    contact_down_event (const contact_down_event::type& contact_down_event)
    {
      this->_xsd_contact_down_event_.set (contact_down_event);
    }

    void dtn::
    contact_down_event (const contact_down_event::container& contact_down_event)
    {
      this->_xsd_contact_down_event_ = contact_down_event;
    }

    void dtn::
    contact_down_event (::std::auto_ptr< contact_down_event::type > contact_down_event)
    {
      this->_xsd_contact_down_event_.set (contact_down_event);
    }

    const dtn::link_created_event::container& dtn::
    link_created_event () const
    {
      return this->_xsd_link_created_event_;
    }

    dtn::link_created_event::container& dtn::
    link_created_event ()
    {
      return this->_xsd_link_created_event_;
    }

    void dtn::
    link_created_event (const link_created_event::type& link_created_event)
    {
      this->_xsd_link_created_event_.set (link_created_event);
    }

    void dtn::
    link_created_event (const link_created_event::container& link_created_event)
    {
      this->_xsd_link_created_event_ = link_created_event;
    }

    void dtn::
    link_created_event (::std::auto_ptr< link_created_event::type > link_created_event)
    {
      this->_xsd_link_created_event_.set (link_created_event);
    }

    const dtn::link_deleted_event::container& dtn::
    link_deleted_event () const
    {
      return this->_xsd_link_deleted_event_;
    }

    dtn::link_deleted_event::container& dtn::
    link_deleted_event ()
    {
      return this->_xsd_link_deleted_event_;
    }

    void dtn::
    link_deleted_event (const link_deleted_event::type& link_deleted_event)
    {
      this->_xsd_link_deleted_event_.set (link_deleted_event);
    }

    void dtn::
    link_deleted_event (const link_deleted_event::container& link_deleted_event)
    {
      this->_xsd_link_deleted_event_ = link_deleted_event;
    }

    void dtn::
    link_deleted_event (::std::auto_ptr< link_deleted_event::type > link_deleted_event)
    {
      this->_xsd_link_deleted_event_.set (link_deleted_event);
    }

    const dtn::link_available_event::container& dtn::
    link_available_event () const
    {
      return this->_xsd_link_available_event_;
    }

    dtn::link_available_event::container& dtn::
    link_available_event ()
    {
      return this->_xsd_link_available_event_;
    }

    void dtn::
    link_available_event (const link_available_event::type& link_available_event)
    {
      this->_xsd_link_available_event_.set (link_available_event);
    }

    void dtn::
    link_available_event (const link_available_event::container& link_available_event)
    {
      this->_xsd_link_available_event_ = link_available_event;
    }

    void dtn::
    link_available_event (::std::auto_ptr< link_available_event::type > link_available_event)
    {
      this->_xsd_link_available_event_.set (link_available_event);
    }

    const dtn::link_unavailable_event::container& dtn::
    link_unavailable_event () const
    {
      return this->_xsd_link_unavailable_event_;
    }

    dtn::link_unavailable_event::container& dtn::
    link_unavailable_event ()
    {
      return this->_xsd_link_unavailable_event_;
    }

    void dtn::
    link_unavailable_event (const link_unavailable_event::type& link_unavailable_event)
    {
      this->_xsd_link_unavailable_event_.set (link_unavailable_event);
    }

    void dtn::
    link_unavailable_event (const link_unavailable_event::container& link_unavailable_event)
    {
      this->_xsd_link_unavailable_event_ = link_unavailable_event;
    }

    void dtn::
    link_unavailable_event (::std::auto_ptr< link_unavailable_event::type > link_unavailable_event)
    {
      this->_xsd_link_unavailable_event_.set (link_unavailable_event);
    }

    const dtn::link_busy_event::container& dtn::
    link_busy_event () const
    {
      return this->_xsd_link_busy_event_;
    }

    dtn::link_busy_event::container& dtn::
    link_busy_event ()
    {
      return this->_xsd_link_busy_event_;
    }

    void dtn::
    link_busy_event (const link_busy_event::type& link_busy_event)
    {
      this->_xsd_link_busy_event_.set (link_busy_event);
    }

    void dtn::
    link_busy_event (const link_busy_event::container& link_busy_event)
    {
      this->_xsd_link_busy_event_ = link_busy_event;
    }

    void dtn::
    link_busy_event (::std::auto_ptr< link_busy_event::type > link_busy_event)
    {
      this->_xsd_link_busy_event_.set (link_busy_event);
    }

    const dtn::route_add_event::container& dtn::
    route_add_event () const
    {
      return this->_xsd_route_add_event_;
    }

    dtn::route_add_event::container& dtn::
    route_add_event ()
    {
      return this->_xsd_route_add_event_;
    }

    void dtn::
    route_add_event (const route_add_event::type& route_add_event)
    {
      this->_xsd_route_add_event_.set (route_add_event);
    }

    void dtn::
    route_add_event (const route_add_event::container& route_add_event)
    {
      this->_xsd_route_add_event_ = route_add_event;
    }

    void dtn::
    route_add_event (::std::auto_ptr< route_add_event::type > route_add_event)
    {
      this->_xsd_route_add_event_.set (route_add_event);
    }

    const dtn::route_delete_event::container& dtn::
    route_delete_event () const
    {
      return this->_xsd_route_delete_event_;
    }

    dtn::route_delete_event::container& dtn::
    route_delete_event ()
    {
      return this->_xsd_route_delete_event_;
    }

    void dtn::
    route_delete_event (const route_delete_event::type& route_delete_event)
    {
      this->_xsd_route_delete_event_.set (route_delete_event);
    }

    void dtn::
    route_delete_event (const route_delete_event::container& route_delete_event)
    {
      this->_xsd_route_delete_event_ = route_delete_event;
    }

    void dtn::
    route_delete_event (::std::auto_ptr< route_delete_event::type > route_delete_event)
    {
      this->_xsd_route_delete_event_.set (route_delete_event);
    }

    const dtn::custody_signal_event::container& dtn::
    custody_signal_event () const
    {
      return this->_xsd_custody_signal_event_;
    }

    dtn::custody_signal_event::container& dtn::
    custody_signal_event ()
    {
      return this->_xsd_custody_signal_event_;
    }

    void dtn::
    custody_signal_event (const custody_signal_event::type& custody_signal_event)
    {
      this->_xsd_custody_signal_event_.set (custody_signal_event);
    }

    void dtn::
    custody_signal_event (const custody_signal_event::container& custody_signal_event)
    {
      this->_xsd_custody_signal_event_ = custody_signal_event;
    }

    void dtn::
    custody_signal_event (::std::auto_ptr< custody_signal_event::type > custody_signal_event)
    {
      this->_xsd_custody_signal_event_.set (custody_signal_event);
    }

    const dtn::custody_timeout_event::container& dtn::
    custody_timeout_event () const
    {
      return this->_xsd_custody_timeout_event_;
    }

    dtn::custody_timeout_event::container& dtn::
    custody_timeout_event ()
    {
      return this->_xsd_custody_timeout_event_;
    }

    void dtn::
    custody_timeout_event (const custody_timeout_event::type& custody_timeout_event)
    {
      this->_xsd_custody_timeout_event_.set (custody_timeout_event);
    }

    void dtn::
    custody_timeout_event (const custody_timeout_event::container& custody_timeout_event)
    {
      this->_xsd_custody_timeout_event_ = custody_timeout_event;
    }

    void dtn::
    custody_timeout_event (::std::auto_ptr< custody_timeout_event::type > custody_timeout_event)
    {
      this->_xsd_custody_timeout_event_.set (custody_timeout_event);
    }

    const dtn::registration_added_event::container& dtn::
    registration_added_event () const
    {
      return this->_xsd_registration_added_event_;
    }

    dtn::registration_added_event::container& dtn::
    registration_added_event ()
    {
      return this->_xsd_registration_added_event_;
    }

    void dtn::
    registration_added_event (const registration_added_event::type& registration_added_event)
    {
      this->_xsd_registration_added_event_.set (registration_added_event);
    }

    void dtn::
    registration_added_event (const registration_added_event::container& registration_added_event)
    {
      this->_xsd_registration_added_event_ = registration_added_event;
    }

    void dtn::
    registration_added_event (::std::auto_ptr< registration_added_event::type > registration_added_event)
    {
      this->_xsd_registration_added_event_.set (registration_added_event);
    }

    const dtn::registration_removed_event::container& dtn::
    registration_removed_event () const
    {
      return this->_xsd_registration_removed_event_;
    }

    dtn::registration_removed_event::container& dtn::
    registration_removed_event ()
    {
      return this->_xsd_registration_removed_event_;
    }

    void dtn::
    registration_removed_event (const registration_removed_event::type& registration_removed_event)
    {
      this->_xsd_registration_removed_event_.set (registration_removed_event);
    }

    void dtn::
    registration_removed_event (const registration_removed_event::container& registration_removed_event)
    {
      this->_xsd_registration_removed_event_ = registration_removed_event;
    }

    void dtn::
    registration_removed_event (::std::auto_ptr< registration_removed_event::type > registration_removed_event)
    {
      this->_xsd_registration_removed_event_.set (registration_removed_event);
    }

    const dtn::registration_expired_event::container& dtn::
    registration_expired_event () const
    {
      return this->_xsd_registration_expired_event_;
    }

    dtn::registration_expired_event::container& dtn::
    registration_expired_event ()
    {
      return this->_xsd_registration_expired_event_;
    }

    void dtn::
    registration_expired_event (const registration_expired_event::type& registration_expired_event)
    {
      this->_xsd_registration_expired_event_.set (registration_expired_event);
    }

    void dtn::
    registration_expired_event (const registration_expired_event::container& registration_expired_event)
    {
      this->_xsd_registration_expired_event_ = registration_expired_event;
    }

    void dtn::
    registration_expired_event (::std::auto_ptr< registration_expired_event::type > registration_expired_event)
    {
      this->_xsd_registration_expired_event_.set (registration_expired_event);
    }

    const dtn::open_link_request::container& dtn::
    open_link_request () const
    {
      return this->_xsd_open_link_request_;
    }

    dtn::open_link_request::container& dtn::
    open_link_request ()
    {
      return this->_xsd_open_link_request_;
    }

    void dtn::
    open_link_request (const open_link_request::type& open_link_request)
    {
      this->_xsd_open_link_request_.set (open_link_request);
    }

    void dtn::
    open_link_request (const open_link_request::container& open_link_request)
    {
      this->_xsd_open_link_request_ = open_link_request;
    }

    void dtn::
    open_link_request (::std::auto_ptr< open_link_request::type > open_link_request)
    {
      this->_xsd_open_link_request_.set (open_link_request);
    }

    const dtn::send_bundle_request::container& dtn::
    send_bundle_request () const
    {
      return this->_xsd_send_bundle_request_;
    }

    dtn::send_bundle_request::container& dtn::
    send_bundle_request ()
    {
      return this->_xsd_send_bundle_request_;
    }

    void dtn::
    send_bundle_request (const send_bundle_request::type& send_bundle_request)
    {
      this->_xsd_send_bundle_request_.set (send_bundle_request);
    }

    void dtn::
    send_bundle_request (const send_bundle_request::container& send_bundle_request)
    {
      this->_xsd_send_bundle_request_ = send_bundle_request;
    }

    void dtn::
    send_bundle_request (::std::auto_ptr< send_bundle_request::type > send_bundle_request)
    {
      this->_xsd_send_bundle_request_.set (send_bundle_request);
    }

    const dtn::cancel_bundle_request::container& dtn::
    cancel_bundle_request () const
    {
      return this->_xsd_cancel_bundle_request_;
    }

    dtn::cancel_bundle_request::container& dtn::
    cancel_bundle_request ()
    {
      return this->_xsd_cancel_bundle_request_;
    }

    void dtn::
    cancel_bundle_request (const cancel_bundle_request::type& cancel_bundle_request)
    {
      this->_xsd_cancel_bundle_request_.set (cancel_bundle_request);
    }

    void dtn::
    cancel_bundle_request (const cancel_bundle_request::container& cancel_bundle_request)
    {
      this->_xsd_cancel_bundle_request_ = cancel_bundle_request;
    }

    void dtn::
    cancel_bundle_request (::std::auto_ptr< cancel_bundle_request::type > cancel_bundle_request)
    {
      this->_xsd_cancel_bundle_request_.set (cancel_bundle_request);
    }

    const dtn::inject_bundle_request::container& dtn::
    inject_bundle_request () const
    {
      return this->_xsd_inject_bundle_request_;
    }

    dtn::inject_bundle_request::container& dtn::
    inject_bundle_request ()
    {
      return this->_xsd_inject_bundle_request_;
    }

    void dtn::
    inject_bundle_request (const inject_bundle_request::type& inject_bundle_request)
    {
      this->_xsd_inject_bundle_request_.set (inject_bundle_request);
    }

    void dtn::
    inject_bundle_request (const inject_bundle_request::container& inject_bundle_request)
    {
      this->_xsd_inject_bundle_request_ = inject_bundle_request;
    }

    void dtn::
    inject_bundle_request (::std::auto_ptr< inject_bundle_request::type > inject_bundle_request)
    {
      this->_xsd_inject_bundle_request_.set (inject_bundle_request);
    }

    const dtn::link_query::container& dtn::
    link_query () const
    {
      return this->_xsd_link_query_;
    }

    dtn::link_query::container& dtn::
    link_query ()
    {
      return this->_xsd_link_query_;
    }

    void dtn::
    link_query (const link_query::type& link_query)
    {
      this->_xsd_link_query_.set (link_query);
    }

    void dtn::
    link_query (const link_query::container& link_query)
    {
      this->_xsd_link_query_ = link_query;
    }

    void dtn::
    link_query (::std::auto_ptr< link_query::type > link_query)
    {
      this->_xsd_link_query_.set (link_query);
    }

    const dtn::link_report::container& dtn::
    link_report () const
    {
      return this->_xsd_link_report_;
    }

    dtn::link_report::container& dtn::
    link_report ()
    {
      return this->_xsd_link_report_;
    }

    void dtn::
    link_report (const link_report::type& link_report)
    {
      this->_xsd_link_report_.set (link_report);
    }

    void dtn::
    link_report (const link_report::container& link_report)
    {
      this->_xsd_link_report_ = link_report;
    }

    void dtn::
    link_report (::std::auto_ptr< link_report::type > link_report)
    {
      this->_xsd_link_report_.set (link_report);
    }

    const dtn::contact_query::container& dtn::
    contact_query () const
    {
      return this->_xsd_contact_query_;
    }

    dtn::contact_query::container& dtn::
    contact_query ()
    {
      return this->_xsd_contact_query_;
    }

    void dtn::
    contact_query (const contact_query::type& contact_query)
    {
      this->_xsd_contact_query_.set (contact_query);
    }

    void dtn::
    contact_query (const contact_query::container& contact_query)
    {
      this->_xsd_contact_query_ = contact_query;
    }

    void dtn::
    contact_query (::std::auto_ptr< contact_query::type > contact_query)
    {
      this->_xsd_contact_query_.set (contact_query);
    }

    const dtn::contact_report::container& dtn::
    contact_report () const
    {
      return this->_xsd_contact_report_;
    }

    dtn::contact_report::container& dtn::
    contact_report ()
    {
      return this->_xsd_contact_report_;
    }

    void dtn::
    contact_report (const contact_report::type& contact_report)
    {
      this->_xsd_contact_report_.set (contact_report);
    }

    void dtn::
    contact_report (const contact_report::container& contact_report)
    {
      this->_xsd_contact_report_ = contact_report;
    }

    void dtn::
    contact_report (::std::auto_ptr< contact_report::type > contact_report)
    {
      this->_xsd_contact_report_.set (contact_report);
    }

    const dtn::route_query::container& dtn::
    route_query () const
    {
      return this->_xsd_route_query_;
    }

    dtn::route_query::container& dtn::
    route_query ()
    {
      return this->_xsd_route_query_;
    }

    void dtn::
    route_query (const route_query::type& route_query)
    {
      this->_xsd_route_query_.set (route_query);
    }

    void dtn::
    route_query (const route_query::container& route_query)
    {
      this->_xsd_route_query_ = route_query;
    }

    void dtn::
    route_query (::std::auto_ptr< route_query::type > route_query)
    {
      this->_xsd_route_query_.set (route_query);
    }

    const dtn::route_report::container& dtn::
    route_report () const
    {
      return this->_xsd_route_report_;
    }

    dtn::route_report::container& dtn::
    route_report ()
    {
      return this->_xsd_route_report_;
    }

    void dtn::
    route_report (const route_report::type& route_report)
    {
      this->_xsd_route_report_.set (route_report);
    }

    void dtn::
    route_report (const route_report::container& route_report)
    {
      this->_xsd_route_report_ = route_report;
    }

    void dtn::
    route_report (::std::auto_ptr< route_report::type > route_report)
    {
      this->_xsd_route_report_.set (route_report);
    }

    const dtn::bundle_query::container& dtn::
    bundle_query () const
    {
      return this->_xsd_bundle_query_;
    }

    dtn::bundle_query::container& dtn::
    bundle_query ()
    {
      return this->_xsd_bundle_query_;
    }

    void dtn::
    bundle_query (const bundle_query::type& bundle_query)
    {
      this->_xsd_bundle_query_.set (bundle_query);
    }

    void dtn::
    bundle_query (const bundle_query::container& bundle_query)
    {
      this->_xsd_bundle_query_ = bundle_query;
    }

    void dtn::
    bundle_query (::std::auto_ptr< bundle_query::type > bundle_query)
    {
      this->_xsd_bundle_query_.set (bundle_query);
    }

    const dtn::bundle_report::container& dtn::
    bundle_report () const
    {
      return this->_xsd_bundle_report_;
    }

    dtn::bundle_report::container& dtn::
    bundle_report ()
    {
      return this->_xsd_bundle_report_;
    }

    void dtn::
    bundle_report (const bundle_report::type& bundle_report)
    {
      this->_xsd_bundle_report_.set (bundle_report);
    }

    void dtn::
    bundle_report (const bundle_report::container& bundle_report)
    {
      this->_xsd_bundle_report_ = bundle_report;
    }

    void dtn::
    bundle_report (::std::auto_ptr< bundle_report::type > bundle_report)
    {
      this->_xsd_bundle_report_.set (bundle_report);
    }

    const dtn::eid::container& dtn::
    eid () const
    {
      return this->_xsd_eid_;
    }

    dtn::eid::container& dtn::
    eid ()
    {
      return this->_xsd_eid_;
    }

    void dtn::
    eid (const eid::type& eid)
    {
      this->_xsd_eid_.set (eid);
    }

    void dtn::
    eid (const eid::container& eid)
    {
      this->_xsd_eid_ = eid;
    }

    void dtn::
    eid (::std::auto_ptr< eid::type > eid)
    {
      this->_xsd_eid_.set (eid);
    }

    const dtn::hello_interval::container& dtn::
    hello_interval () const
    {
      return this->_xsd_hello_interval_;
    }

    dtn::hello_interval::container& dtn::
    hello_interval ()
    {
      return this->_xsd_hello_interval_;
    }

    void dtn::
    hello_interval (const hello_interval::type& hello_interval)
    {
      this->_xsd_hello_interval_.set (hello_interval);
    }

    void dtn::
    hello_interval (const hello_interval::container& hello_interval)
    {
      this->_xsd_hello_interval_ = hello_interval;
    }

    const dtn::alert::container& dtn::
    alert () const
    {
      return this->_xsd_alert_;
    }

    dtn::alert::container& dtn::
    alert ()
    {
      return this->_xsd_alert_;
    }

    void dtn::
    alert (const alert::type& alert)
    {
      this->_xsd_alert_.set (alert);
    }

    void dtn::
    alert (const alert::container& alert)
    {
      this->_xsd_alert_ = alert;
    }

    void dtn::
    alert (::std::auto_ptr< alert::type > alert)
    {
      this->_xsd_alert_.set (alert);
    }
  }
}

#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

namespace dtn
{
  namespace rtrmessage
  {
    // dtnStatusType
    //

    dtnStatusType::
    dtnStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_dtnStatusType_convert ();
    }

    dtnStatusType::
    dtnStatusType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_dtnStatusType_convert ();
    }

    dtnStatusType::
    dtnStatusType (const ::std::basic_string< char >& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_dtnStatusType_convert ();
    }

    dtnStatusType* dtnStatusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new dtnStatusType (*this, f, c);
    }

    dtnStatusType::_xsd_dtnStatusType dtnStatusType::
    _xsd_dtnStatusType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dtnStatusType_literals_);
      const _xsd_dtnStatusType* i (::std::lower_bound (
                                     _xsd_dtnStatusType_indexes_,
                                     _xsd_dtnStatusType_indexes_ + 2,
                                     *this,
                                     c));

      if (i == _xsd_dtnStatusType_indexes_ + 2 || _xsd_dtnStatusType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const dtnStatusType::
    _xsd_dtnStatusType_literals_[2] =
    {
      "justBooted",
      "shuttingDown"
    };

    const dtnStatusType::_xsd_dtnStatusType dtnStatusType::
    _xsd_dtnStatusType_indexes_[2] =
    {
      ::dtn::rtrmessage::dtnStatusType::justBooted,
      ::dtn::rtrmessage::dtnStatusType::shuttingDown
    };

    // bundlePriorityType
    //

    bundlePriorityType::
    bundlePriorityType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_bundlePriorityType_convert ();
    }

    bundlePriorityType::
    bundlePriorityType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_bundlePriorityType_convert ();
    }

    bundlePriorityType::
    bundlePriorityType (const ::std::basic_string< char >& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_bundlePriorityType_convert ();
    }

    bundlePriorityType* bundlePriorityType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundlePriorityType (*this, f, c);
    }

    bundlePriorityType::_xsd_bundlePriorityType bundlePriorityType::
    _xsd_bundlePriorityType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bundlePriorityType_literals_);
      const _xsd_bundlePriorityType* i (::std::lower_bound (
                                          _xsd_bundlePriorityType_indexes_,
                                          _xsd_bundlePriorityType_indexes_ + 4,
                                          *this,
                                          c));

      if (i == _xsd_bundlePriorityType_indexes_ + 4 || _xsd_bundlePriorityType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const bundlePriorityType::
    _xsd_bundlePriorityType_literals_[4] =
    {
      "bulk",
      "normal",
      "expedited",
      "_unknown_priority_"
    };

    const bundlePriorityType::_xsd_bundlePriorityType bundlePriorityType::
    _xsd_bundlePriorityType_indexes_[4] =
    {
      ::dtn::rtrmessage::bundlePriorityType::_unknown_priority_,
      ::dtn::rtrmessage::bundlePriorityType::bulk,
      ::dtn::rtrmessage::bundlePriorityType::expedited,
      ::dtn::rtrmessage::bundlePriorityType::normal
    };

    // eventSourceType
    //

    eventSourceType::
    eventSourceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_eventSourceType_convert ();
    }

    eventSourceType::
    eventSourceType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_eventSourceType_convert ();
    }

    eventSourceType::
    eventSourceType (const ::std::basic_string< char >& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_eventSourceType_convert ();
    }

    eventSourceType* eventSourceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new eventSourceType (*this, f, c);
    }

    eventSourceType::_xsd_eventSourceType eventSourceType::
    _xsd_eventSourceType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_eventSourceType_literals_);
      const _xsd_eventSourceType* i (::std::lower_bound (
                                       _xsd_eventSourceType_indexes_,
                                       _xsd_eventSourceType_indexes_ + 5,
                                       *this,
                                       c));

      if (i == _xsd_eventSourceType_indexes_ + 5 || _xsd_eventSourceType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const eventSourceType::
    _xsd_eventSourceType_literals_[5] =
    {
      "peer",
      "application",
      "dataStore",
      "admin",
      "fragmentation"
    };

    const eventSourceType::_xsd_eventSourceType eventSourceType::
    _xsd_eventSourceType_indexes_[5] =
    {
      ::dtn::rtrmessage::eventSourceType::admin,
      ::dtn::rtrmessage::eventSourceType::application,
      ::dtn::rtrmessage::eventSourceType::dataStore,
      ::dtn::rtrmessage::eventSourceType::fragmentation,
      ::dtn::rtrmessage::eventSourceType::peer
    };

    // bundleForwardActionType
    //

    bundleForwardActionType::
    bundleForwardActionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_bundleForwardActionType_convert ();
    }

    bundleForwardActionType::
    bundleForwardActionType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_bundleForwardActionType_convert ();
    }

    bundleForwardActionType::
    bundleForwardActionType (const ::std::basic_string< char >& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_bundleForwardActionType_convert ();
    }

    bundleForwardActionType* bundleForwardActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundleForwardActionType (*this, f, c);
    }

    bundleForwardActionType::_xsd_bundleForwardActionType bundleForwardActionType::
    _xsd_bundleForwardActionType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bundleForwardActionType_literals_);
      const _xsd_bundleForwardActionType* i (::std::lower_bound (
                                               _xsd_bundleForwardActionType_indexes_,
                                               _xsd_bundleForwardActionType_indexes_ + 2,
                                               *this,
                                               c));

      if (i == _xsd_bundleForwardActionType_indexes_ + 2 || _xsd_bundleForwardActionType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const bundleForwardActionType::
    _xsd_bundleForwardActionType_literals_[2] =
    {
      "forward",
      "copy"
    };

    const bundleForwardActionType::_xsd_bundleForwardActionType bundleForwardActionType::
    _xsd_bundleForwardActionType_indexes_[2] =
    {
      ::dtn::rtrmessage::bundleForwardActionType::copy,
      ::dtn::rtrmessage::bundleForwardActionType::forward
    };

    // contactReasonType
    //

    contactReasonType::
    contactReasonType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_contactReasonType_convert ();
    }

    contactReasonType::
    contactReasonType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_contactReasonType_convert ();
    }

    contactReasonType::
    contactReasonType (const ::std::basic_string< char >& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_contactReasonType_convert ();
    }

    contactReasonType* contactReasonType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new contactReasonType (*this, f, c);
    }

    contactReasonType::_xsd_contactReasonType contactReasonType::
    _xsd_contactReasonType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_contactReasonType_literals_);
      const _xsd_contactReasonType* i (::std::lower_bound (
                                         _xsd_contactReasonType_indexes_,
                                         _xsd_contactReasonType_indexes_ + 11,
                                         *this,
                                         c));

      if (i == _xsd_contactReasonType_indexes_ + 11 || _xsd_contactReasonType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const contactReasonType::
    _xsd_contactReasonType_literals_[11] =
    {
      "no_info",
      "user",
      "broken",
      "cl_error",
      "cl_version",
      "shutdown",
      "reconnect",
      "idle",
      "timeout",
      "blocked",
      "unblocked"
    };

    const contactReasonType::_xsd_contactReasonType contactReasonType::
    _xsd_contactReasonType_indexes_[11] =
    {
      ::dtn::rtrmessage::contactReasonType::blocked,
      ::dtn::rtrmessage::contactReasonType::broken,
      ::dtn::rtrmessage::contactReasonType::cl_error,
      ::dtn::rtrmessage::contactReasonType::cl_version,
      ::dtn::rtrmessage::contactReasonType::idle,
      ::dtn::rtrmessage::contactReasonType::no_info,
      ::dtn::rtrmessage::contactReasonType::reconnect,
      ::dtn::rtrmessage::contactReasonType::shutdown,
      ::dtn::rtrmessage::contactReasonType::timeout,
      ::dtn::rtrmessage::contactReasonType::unblocked,
      ::dtn::rtrmessage::contactReasonType::user
    };

    // linkTypeType
    //

    linkTypeType::
    linkTypeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_linkTypeType_convert ();
    }

    linkTypeType::
    linkTypeType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_linkTypeType_convert ();
    }

    linkTypeType::
    linkTypeType (const ::std::basic_string< char >& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_linkTypeType_convert ();
    }

    linkTypeType* linkTypeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new linkTypeType (*this, f, c);
    }

    linkTypeType::_xsd_linkTypeType linkTypeType::
    _xsd_linkTypeType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_linkTypeType_literals_);
      const _xsd_linkTypeType* i (::std::lower_bound (
                                    _xsd_linkTypeType_indexes_,
                                    _xsd_linkTypeType_indexes_ + 4,
                                    *this,
                                    c));

      if (i == _xsd_linkTypeType_indexes_ + 4 || _xsd_linkTypeType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const linkTypeType::
    _xsd_linkTypeType_literals_[4] =
    {
      "alwayson",
      "ondemand",
      "scheduled",
      "opportunistic"
    };

    const linkTypeType::_xsd_linkTypeType linkTypeType::
    _xsd_linkTypeType_indexes_[4] =
    {
      ::dtn::rtrmessage::linkTypeType::alwayson,
      ::dtn::rtrmessage::linkTypeType::ondemand,
      ::dtn::rtrmessage::linkTypeType::opportunistic,
      ::dtn::rtrmessage::linkTypeType::scheduled
    };

    // linkStateType
    //

    linkStateType::
    linkStateType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_linkStateType_convert ();
    }

    linkStateType::
    linkStateType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_linkStateType_convert ();
    }

    linkStateType::
    linkStateType (const ::std::basic_string< char >& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_linkStateType_convert ();
    }

    linkStateType* linkStateType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new linkStateType (*this, f, c);
    }

    linkStateType::_xsd_linkStateType linkStateType::
    _xsd_linkStateType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_linkStateType_literals_);
      const _xsd_linkStateType* i (::std::lower_bound (
                                     _xsd_linkStateType_indexes_,
                                     _xsd_linkStateType_indexes_ + 5,
                                     *this,
                                     c));

      if (i == _xsd_linkStateType_indexes_ + 5 || _xsd_linkStateType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const linkStateType::
    _xsd_linkStateType_literals_[5] =
    {
      "unavailable",
      "available",
      "opening",
      "open",
      "busy"
    };

    const linkStateType::_xsd_linkStateType linkStateType::
    _xsd_linkStateType_indexes_[5] =
    {
      ::dtn::rtrmessage::linkStateType::available,
      ::dtn::rtrmessage::linkStateType::busy,
      ::dtn::rtrmessage::linkStateType::open,
      ::dtn::rtrmessage::linkStateType::opening,
      ::dtn::rtrmessage::linkStateType::unavailable
    };

    // eidTypeType
    //

    eidTypeType::
    eidTypeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
    }

    eidTypeType::
    eidTypeType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
    }

    eidTypeType::
    eidTypeType (const ::std::basic_string< char >& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
    }

    eidTypeType* eidTypeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new eidTypeType (*this, f, c);
    }

    // failureActionType
    //

    failureActionType::
    failureActionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_failureActionType_convert ();
    }

    failureActionType::
    failureActionType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_failureActionType_convert ();
    }

    failureActionType::
    failureActionType (const ::std::basic_string< char >& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_failureActionType_convert ();
    }

    failureActionType* failureActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new failureActionType (*this, f, c);
    }

    failureActionType::_xsd_failureActionType failureActionType::
    _xsd_failureActionType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_failureActionType_literals_);
      const _xsd_failureActionType* i (::std::lower_bound (
                                         _xsd_failureActionType_indexes_,
                                         _xsd_failureActionType_indexes_ + 3,
                                         *this,
                                         c));

      if (i == _xsd_failureActionType_indexes_ + 3 || _xsd_failureActionType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const failureActionType::
    _xsd_failureActionType_literals_[3] =
    {
      "drop",
      "defer",
      "exec"
    };

    const failureActionType::_xsd_failureActionType failureActionType::
    _xsd_failureActionType_indexes_[3] =
    {
      ::dtn::rtrmessage::failureActionType::defer,
      ::dtn::rtrmessage::failureActionType::drop,
      ::dtn::rtrmessage::failureActionType::exec
    };

    // bundleLocationType
    //

    bundleLocationType::
    bundleLocationType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_bundleLocationType_convert ();
    }

    bundleLocationType::
    bundleLocationType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_bundleLocationType_convert ();
    }

    bundleLocationType::
    bundleLocationType (const ::std::basic_string< char >& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_bundleLocationType_convert ();
    }

    bundleLocationType* bundleLocationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundleLocationType (*this, f, c);
    }

    bundleLocationType::_xsd_bundleLocationType bundleLocationType::
    _xsd_bundleLocationType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bundleLocationType_literals_);
      const _xsd_bundleLocationType* i (::std::lower_bound (
                                          _xsd_bundleLocationType_indexes_,
                                          _xsd_bundleLocationType_indexes_ + 3,
                                          *this,
                                          c));

      if (i == _xsd_bundleLocationType_indexes_ + 3 || _xsd_bundleLocationType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const bundleLocationType::
    _xsd_bundleLocationType_literals_[3] =
    {
      "memory",
      "disk",
      "nodata"
    };

    const bundleLocationType::_xsd_bundleLocationType bundleLocationType::
    _xsd_bundleLocationType_indexes_[3] =
    {
      ::dtn::rtrmessage::bundleLocationType::disk,
      ::dtn::rtrmessage::bundleLocationType::memory,
      ::dtn::rtrmessage::bundleLocationType::nodata
    };

    // eidType
    //

    eidType::
    eidType ()
    : ::xml_schema::type (),
    _xsd_uri_ (::xml_schema::flags (), this)
    {
    }

    eidType::
    eidType (const uri::type& _xsd_uri)
    : ::xml_schema::type (),
    _xsd_uri_ (_xsd_uri,
               ::xml_schema::flags (),
               this)
    {
    }

    eidType::
    eidType (const eidType& _xsd_eidType,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_eidType, f, c),
    _xsd_uri_ (_xsd_eidType._xsd_uri_,
               f | ::xml_schema::flags::not_root,
               this)
    {
    }

    eidType::
    eidType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_uri_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void eidType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "uri" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< uri::type > r (
            uri::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->uri (r);
          continue;
        }
      }

      if (!_xsd_uri_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "uri",
          "");
      }
    }

    eidType* eidType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new eidType (*this, f, c);
    }

    // bundleType_base
    //

    bundleType_base::
    bundleType_base ()
    : ::xml_schema::type (),
    _xsd_source_ (::xml_schema::flags (), this),
    _xsd_dest_ (::xml_schema::flags (), this),
    _xsd_custodian_ (::xml_schema::flags (), this),
    _xsd_replyto_ (::xml_schema::flags (), this),
    _xsd_prevhop_ (::xml_schema::flags (), this),
    _xsd_length_ (::xml_schema::flags (), this),
    _xsd_location_ (::xml_schema::flags (), this),
    _xsd_payload_ (::xml_schema::flags (), this),
    _xsd_recv_blocks_ (::xml_schema::flags (), this),
    _xsd_api_blocks_ (::xml_schema::flags (), this),
    _xsd_bundleid_ (::xml_schema::flags (), this),
    _xsd_is_fragment_ (::xml_schema::flags (), this),
    _xsd_is_admin_ (::xml_schema::flags (), this),
    _xsd_do_not_fragment_ (::xml_schema::flags (), this),
    _xsd_priority_ (::xml_schema::flags (), this),
    _xsd_custody_requested_ (::xml_schema::flags (), this),
    _xsd_local_custody_ (::xml_schema::flags (), this),
    _xsd_singleton_dest_ (::xml_schema::flags (), this),
    _xsd_custody_rcpt_ (::xml_schema::flags (), this),
    _xsd_receive_rcpt_ (::xml_schema::flags (), this),
    _xsd_forward_rcpt_ (::xml_schema::flags (), this),
    _xsd_delivery_rcpt_ (::xml_schema::flags (), this),
    _xsd_deletion_rcpt_ (::xml_schema::flags (), this),
    _xsd_app_acked_rcpt_ (::xml_schema::flags (), this),
    _xsd_creation_ts_seconds_ (::xml_schema::flags (), this),
    _xsd_creation_ts_seqno_ (::xml_schema::flags (), this),
    _xsd_expiration_ (::xml_schema::flags (), this),
    _xsd_orig_length_ (::xml_schema::flags (), this),
    _xsd_frag_offset_ (::xml_schema::flags (), this),
    _xsd_owner_ (::xml_schema::flags (), this)
    {
    }

    bundleType_base::
    bundleType_base (const source::type& _xsd_source,
                     const dest::type& _xsd_dest,
                     const custodian::type& _xsd_custodian,
                     const replyto::type& _xsd_replyto,
                     const prevhop::type& _xsd_prevhop,
                     const length::type& _xsd_length,
                     const location::type& _xsd_location,
                     const bundleid::type& _xsd_bundleid,
                     const is_fragment::type& _xsd_is_fragment,
                     const is_admin::type& _xsd_is_admin,
                     const do_not_fragment::type& _xsd_do_not_fragment,
                     const priority::type& _xsd_priority,
                     const custody_requested::type& _xsd_custody_requested,
                     const local_custody::type& _xsd_local_custody,
                     const singleton_dest::type& _xsd_singleton_dest,
                     const custody_rcpt::type& _xsd_custody_rcpt,
                     const receive_rcpt::type& _xsd_receive_rcpt,
                     const forward_rcpt::type& _xsd_forward_rcpt,
                     const delivery_rcpt::type& _xsd_delivery_rcpt,
                     const deletion_rcpt::type& _xsd_deletion_rcpt,
                     const app_acked_rcpt::type& _xsd_app_acked_rcpt,
                     const creation_ts_seconds::type& _xsd_creation_ts_seconds,
                     const creation_ts_seqno::type& _xsd_creation_ts_seqno,
                     const expiration::type& _xsd_expiration,
                     const orig_length::type& _xsd_orig_length,
                     const frag_offset::type& _xsd_frag_offset,
                     const owner::type& _xsd_owner)
    : ::xml_schema::type (),
    _xsd_source_ (_xsd_source,
                  ::xml_schema::flags (),
                  this),
    _xsd_dest_ (_xsd_dest,
                ::xml_schema::flags (),
                this),
    _xsd_custodian_ (_xsd_custodian,
                     ::xml_schema::flags (),
                     this),
    _xsd_replyto_ (_xsd_replyto,
                   ::xml_schema::flags (),
                   this),
    _xsd_prevhop_ (_xsd_prevhop,
                   ::xml_schema::flags (),
                   this),
    _xsd_length_ (_xsd_length,
                  ::xml_schema::flags (),
                  this),
    _xsd_location_ (_xsd_location,
                    ::xml_schema::flags (),
                    this),
    _xsd_payload_ (::xml_schema::flags (), this),
    _xsd_recv_blocks_ (::xml_schema::flags (), this),
    _xsd_api_blocks_ (::xml_schema::flags (), this),
    _xsd_bundleid_ (_xsd_bundleid,
                    ::xml_schema::flags (),
                    this),
    _xsd_is_fragment_ (_xsd_is_fragment,
                       ::xml_schema::flags (),
                       this),
    _xsd_is_admin_ (_xsd_is_admin,
                    ::xml_schema::flags (),
                    this),
    _xsd_do_not_fragment_ (_xsd_do_not_fragment,
                           ::xml_schema::flags (),
                           this),
    _xsd_priority_ (_xsd_priority,
                    ::xml_schema::flags (),
                    this),
    _xsd_custody_requested_ (_xsd_custody_requested,
                             ::xml_schema::flags (),
                             this),
    _xsd_local_custody_ (_xsd_local_custody,
                         ::xml_schema::flags (),
                         this),
    _xsd_singleton_dest_ (_xsd_singleton_dest,
                          ::xml_schema::flags (),
                          this),
    _xsd_custody_rcpt_ (_xsd_custody_rcpt,
                        ::xml_schema::flags (),
                        this),
    _xsd_receive_rcpt_ (_xsd_receive_rcpt,
                        ::xml_schema::flags (),
                        this),
    _xsd_forward_rcpt_ (_xsd_forward_rcpt,
                        ::xml_schema::flags (),
                        this),
    _xsd_delivery_rcpt_ (_xsd_delivery_rcpt,
                         ::xml_schema::flags (),
                         this),
    _xsd_deletion_rcpt_ (_xsd_deletion_rcpt,
                         ::xml_schema::flags (),
                         this),
    _xsd_app_acked_rcpt_ (_xsd_app_acked_rcpt,
                          ::xml_schema::flags (),
                          this),
    _xsd_creation_ts_seconds_ (_xsd_creation_ts_seconds,
                               ::xml_schema::flags (),
                               this),
    _xsd_creation_ts_seqno_ (_xsd_creation_ts_seqno,
                             ::xml_schema::flags (),
                             this),
    _xsd_expiration_ (_xsd_expiration,
                      ::xml_schema::flags (),
                      this),
    _xsd_orig_length_ (_xsd_orig_length,
                       ::xml_schema::flags (),
                       this),
    _xsd_frag_offset_ (_xsd_frag_offset,
                       ::xml_schema::flags (),
                       this),
    _xsd_owner_ (_xsd_owner,
                 ::xml_schema::flags (),
                 this)
    {
    }

    bundleType_base::
    bundleType_base (const bundleType_base& _xsd_bundleType_base,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_bundleType_base, f, c),
    _xsd_source_ (_xsd_bundleType_base._xsd_source_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_dest_ (_xsd_bundleType_base._xsd_dest_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_custodian_ (_xsd_bundleType_base._xsd_custodian_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_replyto_ (_xsd_bundleType_base._xsd_replyto_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_prevhop_ (_xsd_bundleType_base._xsd_prevhop_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_length_ (_xsd_bundleType_base._xsd_length_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_location_ (_xsd_bundleType_base._xsd_location_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_payload_ (_xsd_bundleType_base._xsd_payload_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_recv_blocks_ (_xsd_bundleType_base._xsd_recv_blocks_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_api_blocks_ (_xsd_bundleType_base._xsd_api_blocks_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_bundleid_ (_xsd_bundleType_base._xsd_bundleid_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_is_fragment_ (_xsd_bundleType_base._xsd_is_fragment_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_is_admin_ (_xsd_bundleType_base._xsd_is_admin_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_do_not_fragment_ (_xsd_bundleType_base._xsd_do_not_fragment_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_priority_ (_xsd_bundleType_base._xsd_priority_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_custody_requested_ (_xsd_bundleType_base._xsd_custody_requested_,
                             f | ::xml_schema::flags::not_root,
                             this),
    _xsd_local_custody_ (_xsd_bundleType_base._xsd_local_custody_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_singleton_dest_ (_xsd_bundleType_base._xsd_singleton_dest_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_custody_rcpt_ (_xsd_bundleType_base._xsd_custody_rcpt_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_receive_rcpt_ (_xsd_bundleType_base._xsd_receive_rcpt_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_forward_rcpt_ (_xsd_bundleType_base._xsd_forward_rcpt_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_delivery_rcpt_ (_xsd_bundleType_base._xsd_delivery_rcpt_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_deletion_rcpt_ (_xsd_bundleType_base._xsd_deletion_rcpt_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_app_acked_rcpt_ (_xsd_bundleType_base._xsd_app_acked_rcpt_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_creation_ts_seconds_ (_xsd_bundleType_base._xsd_creation_ts_seconds_,
                               f | ::xml_schema::flags::not_root,
                               this),
    _xsd_creation_ts_seqno_ (_xsd_bundleType_base._xsd_creation_ts_seqno_,
                             f | ::xml_schema::flags::not_root,
                             this),
    _xsd_expiration_ (_xsd_bundleType_base._xsd_expiration_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_orig_length_ (_xsd_bundleType_base._xsd_orig_length_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_frag_offset_ (_xsd_bundleType_base._xsd_frag_offset_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_owner_ (_xsd_bundleType_base._xsd_owner_,
                 f | ::xml_schema::flags::not_root,
                 this)
    {
    }

    bundleType_base::
    bundleType_base (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_source_ (f | ::xml_schema::flags::not_root, this),
    _xsd_dest_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custodian_ (f | ::xml_schema::flags::not_root, this),
    _xsd_replyto_ (f | ::xml_schema::flags::not_root, this),
    _xsd_prevhop_ (f | ::xml_schema::flags::not_root, this),
    _xsd_length_ (f | ::xml_schema::flags::not_root, this),
    _xsd_location_ (f | ::xml_schema::flags::not_root, this),
    _xsd_payload_ (f | ::xml_schema::flags::not_root, this),
    _xsd_recv_blocks_ (f | ::xml_schema::flags::not_root, this),
    _xsd_api_blocks_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bundleid_ (f | ::xml_schema::flags::not_root, this),
    _xsd_is_fragment_ (f | ::xml_schema::flags::not_root, this),
    _xsd_is_admin_ (f | ::xml_schema::flags::not_root, this),
    _xsd_do_not_fragment_ (f | ::xml_schema::flags::not_root, this),
    _xsd_priority_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custody_requested_ (f | ::xml_schema::flags::not_root, this),
    _xsd_local_custody_ (f | ::xml_schema::flags::not_root, this),
    _xsd_singleton_dest_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custody_rcpt_ (f | ::xml_schema::flags::not_root, this),
    _xsd_receive_rcpt_ (f | ::xml_schema::flags::not_root, this),
    _xsd_forward_rcpt_ (f | ::xml_schema::flags::not_root, this),
    _xsd_delivery_rcpt_ (f | ::xml_schema::flags::not_root, this),
    _xsd_deletion_rcpt_ (f | ::xml_schema::flags::not_root, this),
    _xsd_app_acked_rcpt_ (f | ::xml_schema::flags::not_root, this),
    _xsd_creation_ts_seconds_ (f | ::xml_schema::flags::not_root, this),
    _xsd_creation_ts_seqno_ (f | ::xml_schema::flags::not_root, this),
    _xsd_expiration_ (f | ::xml_schema::flags::not_root, this),
    _xsd_orig_length_ (f | ::xml_schema::flags::not_root, this),
    _xsd_frag_offset_ (f | ::xml_schema::flags::not_root, this),
    _xsd_owner_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void bundleType_base::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // source
        //
        {
          if (e.name () == "source" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< source::type > r (
              source::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_source_.present ())
              continue;
            this->source (r);
            continue;
          }
        }

        // dest
        //
        {
          if (e.name () == "dest" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< dest::type > r (
              dest::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_dest_.present ())
              continue;
            this->dest (r);
            continue;
          }
        }

        // custodian
        //
        {
          if (e.name () == "custodian" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< custodian::type > r (
              custodian::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_custodian_.present ())
              continue;
            this->custodian (r);
            continue;
          }
        }

        // replyto
        //
        {
          if (e.name () == "replyto" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< replyto::type > r (
              replyto::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_replyto_.present ())
              continue;
            this->replyto (r);
            continue;
          }
        }

        // prevhop
        //
        {
          if (e.name () == "prevhop" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< prevhop::type > r (
              prevhop::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_prevhop_.present ())
              continue;
            this->prevhop (r);
            continue;
          }
        }

        // length
        //
        {
          if (e.name () == "length" && e.namespace_ ().empty ())
          {
            if (_xsd_length_.present ())
              continue;
            this->length (
              length::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));
            continue;
          }
        }

        // location
        //
        {
          if (e.name () == "location" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< location::type > r (
              location::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_location_.present ())
              continue;
            this->location (r);
            continue;
          }
        }

        // payload
        //
        {
          if (e.name () == "payload" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< payload::type > r (
              payload::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->payload ())
              continue;
            this->payload (r);
            continue;
          }
        }

        // recv_blocks
        //
        {
          if (e.name () == "recv_blocks" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< recv_blocks::type > r (
              recv_blocks::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->recv_blocks ())
              continue;
            this->recv_blocks (r);
            continue;
          }
        }

        // api_blocks
        //
        {
          if (e.name () == "api_blocks" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< api_blocks::type > r (
              api_blocks::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->api_blocks ())
              continue;
            this->api_blocks (r);
            continue;
          }
        }
      }

      if (!_xsd_source_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "source",
          "");
      }

      if (!_xsd_dest_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "dest",
          "");
      }

      if (!_xsd_custodian_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "custodian",
          "");
      }

      if (!_xsd_replyto_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "replyto",
          "");
      }

      if (!_xsd_prevhop_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "prevhop",
          "");
      }

      if (!_xsd_length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "length",
          "");
      }

      if (!_xsd_location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "bundleid" && a.namespace_ ().empty ())
        {
          this->bundleid (
            bundleid::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "is_fragment" && a.namespace_ ().empty ())
        {
          this->is_fragment (
            is_fragment::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "is_admin" && a.namespace_ ().empty ())
        {
          this->is_admin (
            is_admin::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "do_not_fragment" && a.namespace_ ().empty ())
        {
          this->do_not_fragment (
            do_not_fragment::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "priority" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< priority::type > r (
            priority::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->priority (r);
          continue;
        }

        if (a.name () == "custody_requested" && a.namespace_ ().empty ())
        {
          this->custody_requested (
            custody_requested::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "local_custody" && a.namespace_ ().empty ())
        {
          this->local_custody (
            local_custody::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "singleton_dest" && a.namespace_ ().empty ())
        {
          this->singleton_dest (
            singleton_dest::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "custody_rcpt" && a.namespace_ ().empty ())
        {
          this->custody_rcpt (
            custody_rcpt::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "receive_rcpt" && a.namespace_ ().empty ())
        {
          this->receive_rcpt (
            receive_rcpt::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "forward_rcpt" && a.namespace_ ().empty ())
        {
          this->forward_rcpt (
            forward_rcpt::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "delivery_rcpt" && a.namespace_ ().empty ())
        {
          this->delivery_rcpt (
            delivery_rcpt::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "deletion_rcpt" && a.namespace_ ().empty ())
        {
          this->deletion_rcpt (
            deletion_rcpt::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "app_acked_rcpt" && a.namespace_ ().empty ())
        {
          this->app_acked_rcpt (
            app_acked_rcpt::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "creation_ts_seconds" && a.namespace_ ().empty ())
        {
          this->creation_ts_seconds (
            creation_ts_seconds::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "creation_ts_seqno" && a.namespace_ ().empty ())
        {
          this->creation_ts_seqno (
            creation_ts_seqno::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "expiration" && a.namespace_ ().empty ())
        {
          this->expiration (
            expiration::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "orig_length" && a.namespace_ ().empty ())
        {
          this->orig_length (
            orig_length::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "frag_offset" && a.namespace_ ().empty ())
        {
          this->frag_offset (
            frag_offset::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "owner" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< owner::type > r (
            owner::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->owner (r);
          continue;
        }
      }

      if (!_xsd_bundleid_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bundleid",
          "");
      }

      if (!_xsd_is_fragment_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "is_fragment",
          "");
      }

      if (!_xsd_is_admin_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "is_admin",
          "");
      }

      if (!_xsd_do_not_fragment_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "do_not_fragment",
          "");
      }

      if (!_xsd_priority_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "priority",
          "");
      }

      if (!_xsd_custody_requested_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "custody_requested",
          "");
      }

      if (!_xsd_local_custody_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "local_custody",
          "");
      }

      if (!_xsd_singleton_dest_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "singleton_dest",
          "");
      }

      if (!_xsd_custody_rcpt_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "custody_rcpt",
          "");
      }

      if (!_xsd_receive_rcpt_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "receive_rcpt",
          "");
      }

      if (!_xsd_forward_rcpt_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "forward_rcpt",
          "");
      }

      if (!_xsd_delivery_rcpt_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "delivery_rcpt",
          "");
      }

      if (!_xsd_deletion_rcpt_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "deletion_rcpt",
          "");
      }

      if (!_xsd_app_acked_rcpt_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "app_acked_rcpt",
          "");
      }

      if (!_xsd_creation_ts_seconds_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "creation_ts_seconds",
          "");
      }

      if (!_xsd_creation_ts_seqno_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "creation_ts_seqno",
          "");
      }

      if (!_xsd_expiration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "expiration",
          "");
      }

      if (!_xsd_orig_length_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "orig_length",
          "");
      }

      if (!_xsd_frag_offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "frag_offset",
          "");
      }

      if (!_xsd_owner_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "owner",
          "");
      }
    }

    bundleType_base* bundleType_base::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundleType_base (*this, f, c);
    }

    // contactType_base
    //

    contactType_base::
    contactType_base ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_start_time_sec_ (::xml_schema::flags (), this),
    _xsd_start_time_usec_ (::xml_schema::flags (), this),
    _xsd_duration_ (::xml_schema::flags (), this),
    _xsd_bps_ (::xml_schema::flags (), this),
    _xsd_latency_ (::xml_schema::flags (), this)
    {
    }

    contactType_base::
    contactType_base (const link::type& _xsd_link,
                      const start_time_sec::type& _xsd_start_time_sec,
                      const start_time_usec::type& _xsd_start_time_usec,
                      const duration::type& _xsd_duration,
                      const bps::type& _xsd_bps,
                      const latency::type& _xsd_latency)
    : ::xml_schema::type (),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_start_time_sec_ (_xsd_start_time_sec,
                          ::xml_schema::flags (),
                          this),
    _xsd_start_time_usec_ (_xsd_start_time_usec,
                           ::xml_schema::flags (),
                           this),
    _xsd_duration_ (_xsd_duration,
                    ::xml_schema::flags (),
                    this),
    _xsd_bps_ (_xsd_bps,
               ::xml_schema::flags (),
               this),
    _xsd_latency_ (_xsd_latency,
                   ::xml_schema::flags (),
                   this)
    {
    }

    contactType_base::
    contactType_base (const contactType_base& _xsd_contactType_base,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_contactType_base, f, c),
    _xsd_link_ (_xsd_contactType_base._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_start_time_sec_ (_xsd_contactType_base._xsd_start_time_sec_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_start_time_usec_ (_xsd_contactType_base._xsd_start_time_usec_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_duration_ (_xsd_contactType_base._xsd_duration_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_bps_ (_xsd_contactType_base._xsd_bps_,
               f | ::xml_schema::flags::not_root,
               this),
    _xsd_latency_ (_xsd_contactType_base._xsd_latency_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    contactType_base::
    contactType_base (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_start_time_sec_ (f | ::xml_schema::flags::not_root, this),
    _xsd_start_time_usec_ (f | ::xml_schema::flags::not_root, this),
    _xsd_duration_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bps_ (f | ::xml_schema::flags::not_root, this),
    _xsd_latency_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void contactType_base::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "start_time_sec" && a.namespace_ ().empty ())
        {
          this->start_time_sec (
            start_time_sec::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "start_time_usec" && a.namespace_ ().empty ())
        {
          this->start_time_usec (
            start_time_usec::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "duration" && a.namespace_ ().empty ())
        {
          this->duration (
            duration::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "bps" && a.namespace_ ().empty ())
        {
          this->bps (
            bps::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "latency" && a.namespace_ ().empty ())
        {
          this->latency (
            latency::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_start_time_sec_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "start_time_sec",
          "");
      }

      if (!_xsd_start_time_usec_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "start_time_usec",
          "");
      }

      if (!_xsd_duration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "duration",
          "");
      }

      if (!_xsd_bps_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bps",
          "");
      }

      if (!_xsd_latency_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "latency",
          "");
      }
    }

    contactType_base* contactType_base::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new contactType_base (*this, f, c);
    }

    // clInfoType
    //

    clInfoType::
    clInfoType ()
    : ::xml_schema::type (),
    _xsd_local_addr_ (::xml_schema::flags (), this),
    _xsd_remote_addr_ (::xml_schema::flags (), this),
    _xsd_local_port_ (::xml_schema::flags (), this),
    _xsd_remote_port_ (::xml_schema::flags (), this),
    _xsd_segment_ack_enabled_ (::xml_schema::flags (), this),
    _xsd_negative_ack_enabled_ (::xml_schema::flags (), this),
    _xsd_keepalive_interval_ (::xml_schema::flags (), this),
    _xsd_segment_length_ (::xml_schema::flags (), this),
    _xsd_busy_queue_depth_ (::xml_schema::flags (), this),
    _xsd_reactive_frag_enabled_ (::xml_schema::flags (), this),
    _xsd_sendbuf_length_ (::xml_schema::flags (), this),
    _xsd_recvbuf_length_ (::xml_schema::flags (), this),
    _xsd_data_timeout_ (::xml_schema::flags (), this),
    _xsd_rate_ (::xml_schema::flags (), this),
    _xsd_bucket_depth_ (::xml_schema::flags (), this),
    _xsd_channel_ (::xml_schema::flags (), this)
    {
    }

    clInfoType::
    clInfoType (const clInfoType& _xsd_clInfoType,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_clInfoType, f, c),
    _xsd_local_addr_ (_xsd_clInfoType._xsd_local_addr_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_remote_addr_ (_xsd_clInfoType._xsd_remote_addr_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_local_port_ (_xsd_clInfoType._xsd_local_port_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_remote_port_ (_xsd_clInfoType._xsd_remote_port_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_segment_ack_enabled_ (_xsd_clInfoType._xsd_segment_ack_enabled_,
                               f | ::xml_schema::flags::not_root,
                               this),
    _xsd_negative_ack_enabled_ (_xsd_clInfoType._xsd_negative_ack_enabled_,
                                f | ::xml_schema::flags::not_root,
                                this),
    _xsd_keepalive_interval_ (_xsd_clInfoType._xsd_keepalive_interval_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_segment_length_ (_xsd_clInfoType._xsd_segment_length_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_busy_queue_depth_ (_xsd_clInfoType._xsd_busy_queue_depth_,
                            f | ::xml_schema::flags::not_root,
                            this),
    _xsd_reactive_frag_enabled_ (_xsd_clInfoType._xsd_reactive_frag_enabled_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_sendbuf_length_ (_xsd_clInfoType._xsd_sendbuf_length_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_recvbuf_length_ (_xsd_clInfoType._xsd_recvbuf_length_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_data_timeout_ (_xsd_clInfoType._xsd_data_timeout_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_rate_ (_xsd_clInfoType._xsd_rate_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_bucket_depth_ (_xsd_clInfoType._xsd_bucket_depth_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_channel_ (_xsd_clInfoType._xsd_channel_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    clInfoType::
    clInfoType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_local_addr_ (f | ::xml_schema::flags::not_root, this),
    _xsd_remote_addr_ (f | ::xml_schema::flags::not_root, this),
    _xsd_local_port_ (f | ::xml_schema::flags::not_root, this),
    _xsd_remote_port_ (f | ::xml_schema::flags::not_root, this),
    _xsd_segment_ack_enabled_ (f | ::xml_schema::flags::not_root, this),
    _xsd_negative_ack_enabled_ (f | ::xml_schema::flags::not_root, this),
    _xsd_keepalive_interval_ (f | ::xml_schema::flags::not_root, this),
    _xsd_segment_length_ (f | ::xml_schema::flags::not_root, this),
    _xsd_busy_queue_depth_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reactive_frag_enabled_ (f | ::xml_schema::flags::not_root, this),
    _xsd_sendbuf_length_ (f | ::xml_schema::flags::not_root, this),
    _xsd_recvbuf_length_ (f | ::xml_schema::flags::not_root, this),
    _xsd_data_timeout_ (f | ::xml_schema::flags::not_root, this),
    _xsd_rate_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bucket_depth_ (f | ::xml_schema::flags::not_root, this),
    _xsd_channel_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void clInfoType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "local_addr" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< local_addr::type > r (
            local_addr::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->local_addr (r);
          continue;
        }

        if (a.name () == "remote_addr" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< remote_addr::type > r (
            remote_addr::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->remote_addr (r);
          continue;
        }

        if (a.name () == "local_port" && a.namespace_ ().empty ())
        {
          this->local_port (
            local_port::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "remote_port" && a.namespace_ ().empty ())
        {
          this->remote_port (
            remote_port::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "segment_ack_enabled" && a.namespace_ ().empty ())
        {
          this->segment_ack_enabled (
            segment_ack_enabled::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "negative_ack_enabled" && a.namespace_ ().empty ())
        {
          this->negative_ack_enabled (
            negative_ack_enabled::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "keepalive_interval" && a.namespace_ ().empty ())
        {
          this->keepalive_interval (
            keepalive_interval::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "segment_length" && a.namespace_ ().empty ())
        {
          this->segment_length (
            segment_length::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "busy_queue_depth" && a.namespace_ ().empty ())
        {
          this->busy_queue_depth (
            busy_queue_depth::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "reactive_frag_enabled" && a.namespace_ ().empty ())
        {
          this->reactive_frag_enabled (
            reactive_frag_enabled::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "sendbuf_length" && a.namespace_ ().empty ())
        {
          this->sendbuf_length (
            sendbuf_length::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "recvbuf_length" && a.namespace_ ().empty ())
        {
          this->recvbuf_length (
            recvbuf_length::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "data_timeout" && a.namespace_ ().empty ())
        {
          this->data_timeout (
            data_timeout::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "rate" && a.namespace_ ().empty ())
        {
          this->rate (
            rate::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "bucket_depth" && a.namespace_ ().empty ())
        {
          this->bucket_depth (
            bucket_depth::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "channel" && a.namespace_ ().empty ())
        {
          this->channel (
            channel::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }
    }

    clInfoType* clInfoType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new clInfoType (*this, f, c);
    }

    // linkType_base
    //

    linkType_base::
    linkType_base ()
    : ::xml_schema::type (),
    _xsd_clinfo_ (::xml_schema::flags (), this),
    _xsd_remote_eid_ (::xml_schema::flags (), this),
    _xsd_type_ (::xml_schema::flags (), this),
    _xsd_nexthop_ (::xml_schema::flags (), this),
    _xsd_name_ (::xml_schema::flags (), this),
    _xsd_state_ (::xml_schema::flags (), this),
    _xsd_reliable_ (::xml_schema::flags (), this),
    _xsd_clayer_ (::xml_schema::flags (), this),
    _xsd_min_retry_interval_ (::xml_schema::flags (), this),
    _xsd_max_retry_interval_ (::xml_schema::flags (), this),
    _xsd_idle_close_time_ (::xml_schema::flags (), this)
    {
    }

    linkType_base::
    linkType_base (const remote_eid::type& _xsd_remote_eid,
                   const type::type_& _xsd_type,
                   const nexthop::type& _xsd_nexthop,
                   const name::type& _xsd_name,
                   const state::type& _xsd_state,
                   const reliable::type& _xsd_reliable,
                   const clayer::type& _xsd_clayer,
                   const min_retry_interval::type& _xsd_min_retry_interval,
                   const max_retry_interval::type& _xsd_max_retry_interval,
                   const idle_close_time::type& _xsd_idle_close_time)
    : ::xml_schema::type (),
    _xsd_clinfo_ (::xml_schema::flags (), this),
    _xsd_remote_eid_ (_xsd_remote_eid,
                      ::xml_schema::flags (),
                      this),
    _xsd_type_ (_xsd_type,
                ::xml_schema::flags (),
                this),
    _xsd_nexthop_ (_xsd_nexthop,
                   ::xml_schema::flags (),
                   this),
    _xsd_name_ (_xsd_name,
                ::xml_schema::flags (),
                this),
    _xsd_state_ (_xsd_state,
                 ::xml_schema::flags (),
                 this),
    _xsd_reliable_ (_xsd_reliable,
                    ::xml_schema::flags (),
                    this),
    _xsd_clayer_ (_xsd_clayer,
                  ::xml_schema::flags (),
                  this),
    _xsd_min_retry_interval_ (_xsd_min_retry_interval,
                              ::xml_schema::flags (),
                              this),
    _xsd_max_retry_interval_ (_xsd_max_retry_interval,
                              ::xml_schema::flags (),
                              this),
    _xsd_idle_close_time_ (_xsd_idle_close_time,
                           ::xml_schema::flags (),
                           this)
    {
    }

    linkType_base::
    linkType_base (const linkType_base& _xsd_linkType_base,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_linkType_base, f, c),
    _xsd_clinfo_ (_xsd_linkType_base._xsd_clinfo_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_remote_eid_ (_xsd_linkType_base._xsd_remote_eid_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_type_ (_xsd_linkType_base._xsd_type_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_nexthop_ (_xsd_linkType_base._xsd_nexthop_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_name_ (_xsd_linkType_base._xsd_name_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_state_ (_xsd_linkType_base._xsd_state_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_reliable_ (_xsd_linkType_base._xsd_reliable_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_clayer_ (_xsd_linkType_base._xsd_clayer_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_min_retry_interval_ (_xsd_linkType_base._xsd_min_retry_interval_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_max_retry_interval_ (_xsd_linkType_base._xsd_max_retry_interval_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_idle_close_time_ (_xsd_linkType_base._xsd_idle_close_time_,
                           f | ::xml_schema::flags::not_root,
                           this)
    {
    }

    linkType_base::
    linkType_base (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_clinfo_ (f | ::xml_schema::flags::not_root, this),
    _xsd_remote_eid_ (f | ::xml_schema::flags::not_root, this),
    _xsd_type_ (f | ::xml_schema::flags::not_root, this),
    _xsd_nexthop_ (f | ::xml_schema::flags::not_root, this),
    _xsd_name_ (f | ::xml_schema::flags::not_root, this),
    _xsd_state_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reliable_ (f | ::xml_schema::flags::not_root, this),
    _xsd_clayer_ (f | ::xml_schema::flags::not_root, this),
    _xsd_min_retry_interval_ (f | ::xml_schema::flags::not_root, this),
    _xsd_max_retry_interval_ (f | ::xml_schema::flags::not_root, this),
    _xsd_idle_close_time_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void linkType_base::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // clinfo
        //
        {
          if (e.name () == "clinfo" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< clinfo::type > r (
              clinfo::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->clinfo ())
              continue;
            this->clinfo (r);
            continue;
          }
        }

        // remote_eid
        //
        {
          if (e.name () == "remote_eid" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< remote_eid::type > r (
              remote_eid::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_remote_eid_.present ())
              continue;
            this->remote_eid (r);
            continue;
          }
        }
      }

      if (!_xsd_remote_eid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "remote_eid",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "type" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< type::type_ > r (
            type::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->type (r);
          continue;
        }

        if (a.name () == "nexthop" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< nexthop::type > r (
            nexthop::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->nexthop (r);
          continue;
        }

        if (a.name () == "name" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< name::type > r (
            name::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->name (r);
          continue;
        }

        if (a.name () == "state" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< state::type > r (
            state::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->state (r);
          continue;
        }

        if (a.name () == "reliable" && a.namespace_ ().empty ())
        {
          this->reliable (
            reliable::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "clayer" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< clayer::type > r (
            clayer::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->clayer (r);
          continue;
        }

        if (a.name () == "min_retry_interval" && a.namespace_ ().empty ())
        {
          this->min_retry_interval (
            min_retry_interval::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "max_retry_interval" && a.namespace_ ().empty ())
        {
          this->max_retry_interval (
            max_retry_interval::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "idle_close_time" && a.namespace_ ().empty ())
        {
          this->idle_close_time (
            idle_close_time::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!_xsd_nexthop_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "nexthop",
          "");
      }

      if (!_xsd_name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!_xsd_state_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "state",
          "");
      }

      if (!_xsd_reliable_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reliable",
          "");
      }

      if (!_xsd_clayer_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "clayer",
          "");
      }

      if (!_xsd_min_retry_interval_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "min_retry_interval",
          "");
      }

      if (!_xsd_max_retry_interval_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "max_retry_interval",
          "");
      }

      if (!_xsd_idle_close_time_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "idle_close_time",
          "");
      }
    }

    linkType_base* linkType_base::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new linkType_base (*this, f, c);
    }

    // routeEntryType_base
    //

    routeEntryType_base::
    routeEntryType_base ()
    : ::xml_schema::type (),
    _xsd_dest_pattern_ (::xml_schema::flags (), this),
    _xsd_source_pattern_ (::xml_schema::flags (), this),
    _xsd_route_priority_ (::xml_schema::flags (), this),
    _xsd_action_ (::xml_schema::flags (), this),
    _xsd_link_ (::xml_schema::flags (), this)
    {
    }

    routeEntryType_base::
    routeEntryType_base (const dest_pattern::type& _xsd_dest_pattern,
                         const source_pattern::type& _xsd_source_pattern,
                         const route_priority::type& _xsd_route_priority,
                         const action::type& _xsd_action,
                         const link::type& _xsd_link)
    : ::xml_schema::type (),
    _xsd_dest_pattern_ (_xsd_dest_pattern,
                        ::xml_schema::flags (),
                        this),
    _xsd_source_pattern_ (_xsd_source_pattern,
                          ::xml_schema::flags (),
                          this),
    _xsd_route_priority_ (_xsd_route_priority,
                          ::xml_schema::flags (),
                          this),
    _xsd_action_ (_xsd_action,
                  ::xml_schema::flags (),
                  this),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this)
    {
    }

    routeEntryType_base::
    routeEntryType_base (const routeEntryType_base& _xsd_routeEntryType_base,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_routeEntryType_base, f, c),
    _xsd_dest_pattern_ (_xsd_routeEntryType_base._xsd_dest_pattern_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_source_pattern_ (_xsd_routeEntryType_base._xsd_source_pattern_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_route_priority_ (_xsd_routeEntryType_base._xsd_route_priority_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_action_ (_xsd_routeEntryType_base._xsd_action_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_link_ (_xsd_routeEntryType_base._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    routeEntryType_base::
    routeEntryType_base (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_dest_pattern_ (f | ::xml_schema::flags::not_root, this),
    _xsd_source_pattern_ (f | ::xml_schema::flags::not_root, this),
    _xsd_route_priority_ (f | ::xml_schema::flags::not_root, this),
    _xsd_action_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void routeEntryType_base::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // dest_pattern
        //
        {
          if (e.name () == "dest_pattern" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< dest_pattern::type > r (
              dest_pattern::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_dest_pattern_.present ())
              continue;
            this->dest_pattern (r);
            continue;
          }
        }

        // source_pattern
        //
        {
          if (e.name () == "source_pattern" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< source_pattern::type > r (
              source_pattern::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_source_pattern_.present ())
              continue;
            this->source_pattern (r);
            continue;
          }
        }
      }

      if (!_xsd_dest_pattern_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "dest_pattern",
          "");
      }

      if (!_xsd_source_pattern_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "source_pattern",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "route_priority" && a.namespace_ ().empty ())
        {
          this->route_priority (
            route_priority::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "action" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< action::type > r (
            action::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->action (r);
          continue;
        }

        if (a.name () == "link" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< link::type > r (
            link::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->link (r);
          continue;
        }
      }

      if (!_xsd_route_priority_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "route_priority",
          "");
      }

      if (!_xsd_action_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "action",
          "");
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "link",
          "");
      }
    }

    routeEntryType_base* routeEntryType_base::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new routeEntryType_base (*this, f, c);
    }

    // registrationType_base
    //

    registrationType_base::
    registrationType_base ()
    : ::xml_schema::type (),
    _xsd_endpoint_ (::xml_schema::flags (), this),
    _xsd_regid_ (::xml_schema::flags (), this),
    _xsd_action_ (::xml_schema::flags (), this),
    _xsd_script_ (::xml_schema::flags (), this),
    _xsd_expiration_ (::xml_schema::flags (), this)
    {
    }

    registrationType_base::
    registrationType_base (const endpoint::type& _xsd_endpoint,
                           const regid::type& _xsd_regid,
                           const action::type& _xsd_action,
                           const script::type& _xsd_script,
                           const expiration::type& _xsd_expiration)
    : ::xml_schema::type (),
    _xsd_endpoint_ (_xsd_endpoint,
                    ::xml_schema::flags (),
                    this),
    _xsd_regid_ (_xsd_regid,
                 ::xml_schema::flags (),
                 this),
    _xsd_action_ (_xsd_action,
                  ::xml_schema::flags (),
                  this),
    _xsd_script_ (_xsd_script,
                  ::xml_schema::flags (),
                  this),
    _xsd_expiration_ (_xsd_expiration,
                      ::xml_schema::flags (),
                      this)
    {
    }

    registrationType_base::
    registrationType_base (const registrationType_base& _xsd_registrationType_base,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_registrationType_base, f, c),
    _xsd_endpoint_ (_xsd_registrationType_base._xsd_endpoint_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_regid_ (_xsd_registrationType_base._xsd_regid_,
                 f | ::xml_schema::flags::not_root,
                 this),
    _xsd_action_ (_xsd_registrationType_base._xsd_action_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_script_ (_xsd_registrationType_base._xsd_script_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_expiration_ (_xsd_registrationType_base._xsd_expiration_,
                      f | ::xml_schema::flags::not_root,
                      this)
    {
    }

    registrationType_base::
    registrationType_base (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_endpoint_ (f | ::xml_schema::flags::not_root, this),
    _xsd_regid_ (f | ::xml_schema::flags::not_root, this),
    _xsd_action_ (f | ::xml_schema::flags::not_root, this),
    _xsd_script_ (f | ::xml_schema::flags::not_root, this),
    _xsd_expiration_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void registrationType_base::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // endpoint
        //
        {
          if (e.name () == "endpoint" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< endpoint::type > r (
              endpoint::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_endpoint_.present ())
              continue;
            this->endpoint (r);
            continue;
          }
        }
      }

      if (!_xsd_endpoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "endpoint",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "regid" && a.namespace_ ().empty ())
        {
          this->regid (
            regid::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "action" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< action::type > r (
            action::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->action (r);
          continue;
        }

        if (a.name () == "script" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< script::type > r (
            script::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->script (r);
          continue;
        }

        if (a.name () == "expiration" && a.namespace_ ().empty ())
        {
          this->expiration (
            expiration::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_regid_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "regid",
          "");
      }

      if (!_xsd_action_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "action",
          "");
      }

      if (!_xsd_script_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "script",
          "");
      }

      if (!_xsd_expiration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "expiration",
          "");
      }
    }

    registrationType_base* registrationType_base::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new registrationType_base (*this, f, c);
    }

    // bundle_received_event
    //

    bundle_received_event::
    bundle_received_event ()
    : ::xml_schema::type (),
    _xsd_bundle_ (::xml_schema::flags (), this),
    _xsd_source_ (::xml_schema::flags (), this),
    _xsd_bytes_received_ (::xml_schema::flags (), this)
    {
    }

    bundle_received_event::
    bundle_received_event (const bundle::type& _xsd_bundle,
                           const source::type& _xsd_source,
                           const bytes_received::type& _xsd_bytes_received)
    : ::xml_schema::type (),
    _xsd_bundle_ (_xsd_bundle,
                  ::xml_schema::flags (),
                  this),
    _xsd_source_ (_xsd_source,
                  ::xml_schema::flags (),
                  this),
    _xsd_bytes_received_ (_xsd_bytes_received,
                          ::xml_schema::flags (),
                          this)
    {
    }

    bundle_received_event::
    bundle_received_event (const bundle_received_event& _xsd_bundle_received_event,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_bundle_received_event, f, c),
    _xsd_bundle_ (_xsd_bundle_received_event._xsd_bundle_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_source_ (_xsd_bundle_received_event._xsd_source_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_bytes_received_ (_xsd_bundle_received_event._xsd_bytes_received_,
                          f | ::xml_schema::flags::not_root,
                          this)
    {
    }

    bundle_received_event::
    bundle_received_event (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_ (f | ::xml_schema::flags::not_root, this),
    _xsd_source_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bytes_received_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void bundle_received_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle
        //
        {
          if (e.name () == "bundle" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< bundle::type > r (
              bundle::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_bundle_.present ())
              continue;
            this->bundle (r);
            continue;
          }
        }
      }

      if (!_xsd_bundle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "bundle",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "source" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< source::type > r (
            source::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->source (r);
          continue;
        }

        if (a.name () == "bytes_received" && a.namespace_ ().empty ())
        {
          this->bytes_received (
            bytes_received::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_source_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "source",
          "");
      }

      if (!_xsd_bytes_received_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bytes_received",
          "");
      }
    }

    bundle_received_event* bundle_received_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundle_received_event (*this, f, c);
    }

    // bundle_transmitted_event
    //

    bundle_transmitted_event::
    bundle_transmitted_event ()
    : ::xml_schema::type (),
    _xsd_bundle_ (::xml_schema::flags (), this),
    _xsd_contact_ (::xml_schema::flags (), this),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_bytes_sent_ (::xml_schema::flags (), this),
    _xsd_reliably_sent_ (::xml_schema::flags (), this)
    {
    }

    bundle_transmitted_event::
    bundle_transmitted_event (const bundle::type& _xsd_bundle,
                              const contact::type& _xsd_contact,
                              const link::type& _xsd_link,
                              const bytes_sent::type& _xsd_bytes_sent,
                              const reliably_sent::type& _xsd_reliably_sent)
    : ::xml_schema::type (),
    _xsd_bundle_ (_xsd_bundle,
                  ::xml_schema::flags (),
                  this),
    _xsd_contact_ (_xsd_contact,
                   ::xml_schema::flags (),
                   this),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_bytes_sent_ (_xsd_bytes_sent,
                      ::xml_schema::flags (),
                      this),
    _xsd_reliably_sent_ (_xsd_reliably_sent,
                         ::xml_schema::flags (),
                         this)
    {
    }

    bundle_transmitted_event::
    bundle_transmitted_event (const bundle_transmitted_event& _xsd_bundle_transmitted_event,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_bundle_transmitted_event, f, c),
    _xsd_bundle_ (_xsd_bundle_transmitted_event._xsd_bundle_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_contact_ (_xsd_bundle_transmitted_event._xsd_contact_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_link_ (_xsd_bundle_transmitted_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_bytes_sent_ (_xsd_bundle_transmitted_event._xsd_bytes_sent_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_reliably_sent_ (_xsd_bundle_transmitted_event._xsd_reliably_sent_,
                         f | ::xml_schema::flags::not_root,
                         this)
    {
    }

    bundle_transmitted_event::
    bundle_transmitted_event (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_ (f | ::xml_schema::flags::not_root, this),
    _xsd_contact_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bytes_sent_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reliably_sent_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void bundle_transmitted_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle
        //
        {
          if (e.name () == "bundle" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< bundle::type > r (
              bundle::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_bundle_.present ())
              continue;
            this->bundle (r);
            continue;
          }
        }

        // contact
        //
        {
          if (e.name () == "contact" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< contact::type > r (
              contact::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_contact_.present ())
              continue;
            this->contact (r);
            continue;
          }
        }

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_bundle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "bundle",
          "");
      }

      if (!_xsd_contact_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contact",
          "");
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "bytes_sent" && a.namespace_ ().empty ())
        {
          this->bytes_sent (
            bytes_sent::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "reliably_sent" && a.namespace_ ().empty ())
        {
          this->reliably_sent (
            reliably_sent::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_bytes_sent_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bytes_sent",
          "");
      }

      if (!_xsd_reliably_sent_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reliably_sent",
          "");
      }
    }

    bundle_transmitted_event* bundle_transmitted_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundle_transmitted_event (*this, f, c);
    }

    // bundle_transmit_failed_event
    //

    bundle_transmit_failed_event::
    bundle_transmit_failed_event ()
    : ::xml_schema::type (),
    _xsd_bundle_ (::xml_schema::flags (), this),
    _xsd_contact_ (::xml_schema::flags (), this),
    _xsd_link_ (::xml_schema::flags (), this)
    {
    }

    bundle_transmit_failed_event::
    bundle_transmit_failed_event (const bundle::type& _xsd_bundle,
                                  const contact::type& _xsd_contact,
                                  const link::type& _xsd_link)
    : ::xml_schema::type (),
    _xsd_bundle_ (_xsd_bundle,
                  ::xml_schema::flags (),
                  this),
    _xsd_contact_ (_xsd_contact,
                   ::xml_schema::flags (),
                   this),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this)
    {
    }

    bundle_transmit_failed_event::
    bundle_transmit_failed_event (const bundle_transmit_failed_event& _xsd_bundle_transmit_failed_event,
                                  ::xml_schema::flags f,
                                  ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_bundle_transmit_failed_event, f, c),
    _xsd_bundle_ (_xsd_bundle_transmit_failed_event._xsd_bundle_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_contact_ (_xsd_bundle_transmit_failed_event._xsd_contact_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_link_ (_xsd_bundle_transmit_failed_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    bundle_transmit_failed_event::
    bundle_transmit_failed_event (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_ (f | ::xml_schema::flags::not_root, this),
    _xsd_contact_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void bundle_transmit_failed_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle
        //
        {
          if (e.name () == "bundle" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< bundle::type > r (
              bundle::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_bundle_.present ())
              continue;
            this->bundle (r);
            continue;
          }
        }

        // contact
        //
        {
          if (e.name () == "contact" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< contact::type > r (
              contact::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_contact_.present ())
              continue;
            this->contact (r);
            continue;
          }
        }

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_bundle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "bundle",
          "");
      }

      if (!_xsd_contact_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contact",
          "");
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }
    }

    bundle_transmit_failed_event* bundle_transmit_failed_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundle_transmit_failed_event (*this, f, c);
    }

    // bundle_delivery_event
    //

    bundle_delivery_event::
    bundle_delivery_event ()
    : ::xml_schema::type (),
    _xsd_bundle_ (::xml_schema::flags (), this),
    _xsd_source_ (::xml_schema::flags (), this)
    {
    }

    bundle_delivery_event::
    bundle_delivery_event (const bundle::type& _xsd_bundle,
                           const source::type& _xsd_source)
    : ::xml_schema::type (),
    _xsd_bundle_ (_xsd_bundle,
                  ::xml_schema::flags (),
                  this),
    _xsd_source_ (_xsd_source,
                  ::xml_schema::flags (),
                  this)
    {
    }

    bundle_delivery_event::
    bundle_delivery_event (const bundle_delivery_event& _xsd_bundle_delivery_event,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_bundle_delivery_event, f, c),
    _xsd_bundle_ (_xsd_bundle_delivery_event._xsd_bundle_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_source_ (_xsd_bundle_delivery_event._xsd_source_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    bundle_delivery_event::
    bundle_delivery_event (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_ (f | ::xml_schema::flags::not_root, this),
    _xsd_source_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void bundle_delivery_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle
        //
        {
          if (e.name () == "bundle" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< bundle::type > r (
              bundle::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_bundle_.present ())
              continue;
            this->bundle (r);
            continue;
          }
        }
      }

      if (!_xsd_bundle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "bundle",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "source" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< source::type > r (
            source::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->source (r);
          continue;
        }
      }

      if (!_xsd_source_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "source",
          "");
      }
    }

    bundle_delivery_event* bundle_delivery_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundle_delivery_event (*this, f, c);
    }

    // bundle_expired_event
    //

    bundle_expired_event::
    bundle_expired_event ()
    : ::xml_schema::type (),
    _xsd_bundle_ (::xml_schema::flags (), this)
    {
    }

    bundle_expired_event::
    bundle_expired_event (const bundle::type& _xsd_bundle)
    : ::xml_schema::type (),
    _xsd_bundle_ (_xsd_bundle,
                  ::xml_schema::flags (),
                  this)
    {
    }

    bundle_expired_event::
    bundle_expired_event (const bundle_expired_event& _xsd_bundle_expired_event,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_bundle_expired_event, f, c),
    _xsd_bundle_ (_xsd_bundle_expired_event._xsd_bundle_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    bundle_expired_event::
    bundle_expired_event (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void bundle_expired_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle
        //
        {
          if (e.name () == "bundle" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< bundle::type > r (
              bundle::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_bundle_.present ())
              continue;
            this->bundle (r);
            continue;
          }
        }
      }

      if (!_xsd_bundle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "bundle",
          "");
      }
    }

    bundle_expired_event* bundle_expired_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundle_expired_event (*this, f, c);
    }

    // contact_up_event
    //

    contact_up_event::
    contact_up_event ()
    : ::xml_schema::type (),
    _xsd_contact_ (::xml_schema::flags (), this)
    {
    }

    contact_up_event::
    contact_up_event (const contact::type& _xsd_contact)
    : ::xml_schema::type (),
    _xsd_contact_ (_xsd_contact,
                   ::xml_schema::flags (),
                   this)
    {
    }

    contact_up_event::
    contact_up_event (const contact_up_event& _xsd_contact_up_event,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_contact_up_event, f, c),
    _xsd_contact_ (_xsd_contact_up_event._xsd_contact_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    contact_up_event::
    contact_up_event (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_contact_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void contact_up_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // contact
        //
        {
          if (e.name () == "contact" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< contact::type > r (
              contact::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_contact_.present ())
              continue;
            this->contact (r);
            continue;
          }
        }
      }

      if (!_xsd_contact_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contact",
          "");
      }
    }

    contact_up_event* contact_up_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new contact_up_event (*this, f, c);
    }

    // contact_down_event
    //

    contact_down_event::
    contact_down_event ()
    : ::xml_schema::type (),
    _xsd_contact_ (::xml_schema::flags (), this),
    _xsd_reason_ (::xml_schema::flags (), this)
    {
    }

    contact_down_event::
    contact_down_event (const contact::type& _xsd_contact,
                        const reason::type& _xsd_reason)
    : ::xml_schema::type (),
    _xsd_contact_ (_xsd_contact,
                   ::xml_schema::flags (),
                   this),
    _xsd_reason_ (_xsd_reason,
                  ::xml_schema::flags (),
                  this)
    {
    }

    contact_down_event::
    contact_down_event (const contact_down_event& _xsd_contact_down_event,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_contact_down_event, f, c),
    _xsd_contact_ (_xsd_contact_down_event._xsd_contact_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_reason_ (_xsd_contact_down_event._xsd_reason_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    contact_down_event::
    contact_down_event (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_contact_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reason_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void contact_down_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // contact
        //
        {
          if (e.name () == "contact" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< contact::type > r (
              contact::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_contact_.present ())
              continue;
            this->contact (r);
            continue;
          }
        }
      }

      if (!_xsd_contact_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contact",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "reason" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< reason::type > r (
            reason::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->reason (r);
          continue;
        }
      }

      if (!_xsd_reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reason",
          "");
      }
    }

    contact_down_event* contact_down_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new contact_down_event (*this, f, c);
    }

    // link_created_event
    //

    link_created_event::
    link_created_event ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_reason_ (::xml_schema::flags (), this)
    {
    }

    link_created_event::
    link_created_event (const link::type& _xsd_link,
                        const reason::type& _xsd_reason)
    : ::xml_schema::type (),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_reason_ (_xsd_reason,
                  ::xml_schema::flags (),
                  this)
    {
    }

    link_created_event::
    link_created_event (const link_created_event& _xsd_link_created_event,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_link_created_event, f, c),
    _xsd_link_ (_xsd_link_created_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_reason_ (_xsd_link_created_event._xsd_reason_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    link_created_event::
    link_created_event (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reason_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void link_created_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "reason" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< reason::type > r (
            reason::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->reason (r);
          continue;
        }
      }

      if (!_xsd_reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reason",
          "");
      }
    }

    link_created_event* link_created_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new link_created_event (*this, f, c);
    }

    // link_deleted_event
    //

    link_deleted_event::
    link_deleted_event ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_reason_ (::xml_schema::flags (), this)
    {
    }

    link_deleted_event::
    link_deleted_event (const link::type& _xsd_link,
                        const reason::type& _xsd_reason)
    : ::xml_schema::type (),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_reason_ (_xsd_reason,
                  ::xml_schema::flags (),
                  this)
    {
    }

    link_deleted_event::
    link_deleted_event (const link_deleted_event& _xsd_link_deleted_event,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_link_deleted_event, f, c),
    _xsd_link_ (_xsd_link_deleted_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_reason_ (_xsd_link_deleted_event._xsd_reason_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    link_deleted_event::
    link_deleted_event (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reason_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void link_deleted_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "reason" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< reason::type > r (
            reason::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->reason (r);
          continue;
        }
      }

      if (!_xsd_reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reason",
          "");
      }
    }

    link_deleted_event* link_deleted_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new link_deleted_event (*this, f, c);
    }

    // link_available_event
    //

    link_available_event::
    link_available_event ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_reason_ (::xml_schema::flags (), this)
    {
    }

    link_available_event::
    link_available_event (const link::type& _xsd_link,
                          const reason::type& _xsd_reason)
    : ::xml_schema::type (),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_reason_ (_xsd_reason,
                  ::xml_schema::flags (),
                  this)
    {
    }

    link_available_event::
    link_available_event (const link_available_event& _xsd_link_available_event,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_link_available_event, f, c),
    _xsd_link_ (_xsd_link_available_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_reason_ (_xsd_link_available_event._xsd_reason_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    link_available_event::
    link_available_event (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reason_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void link_available_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "reason" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< reason::type > r (
            reason::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->reason (r);
          continue;
        }
      }

      if (!_xsd_reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reason",
          "");
      }
    }

    link_available_event* link_available_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new link_available_event (*this, f, c);
    }

    // link_unavailable_event
    //

    link_unavailable_event::
    link_unavailable_event ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_reason_ (::xml_schema::flags (), this)
    {
    }

    link_unavailable_event::
    link_unavailable_event (const link::type& _xsd_link,
                            const reason::type& _xsd_reason)
    : ::xml_schema::type (),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_reason_ (_xsd_reason,
                  ::xml_schema::flags (),
                  this)
    {
    }

    link_unavailable_event::
    link_unavailable_event (const link_unavailable_event& _xsd_link_unavailable_event,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_link_unavailable_event, f, c),
    _xsd_link_ (_xsd_link_unavailable_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_reason_ (_xsd_link_unavailable_event._xsd_reason_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    link_unavailable_event::
    link_unavailable_event (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reason_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void link_unavailable_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "reason" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< reason::type > r (
            reason::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->reason (r);
          continue;
        }
      }

      if (!_xsd_reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reason",
          "");
      }
    }

    link_unavailable_event* link_unavailable_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new link_unavailable_event (*this, f, c);
    }

    // link_busy_event
    //

    link_busy_event::
    link_busy_event ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this)
    {
    }

    link_busy_event::
    link_busy_event (const link::type& _xsd_link)
    : ::xml_schema::type (),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this)
    {
    }

    link_busy_event::
    link_busy_event (const link_busy_event& _xsd_link_busy_event,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_link_busy_event, f, c),
    _xsd_link_ (_xsd_link_busy_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    link_busy_event::
    link_busy_event (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void link_busy_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }
    }

    link_busy_event* link_busy_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new link_busy_event (*this, f, c);
    }

    // route_add_event
    //

    route_add_event::
    route_add_event ()
    : ::xml_schema::type (),
    _xsd_route_entry_ (::xml_schema::flags (), this)
    {
    }

    route_add_event::
    route_add_event (const route_entry::type& _xsd_route_entry)
    : ::xml_schema::type (),
    _xsd_route_entry_ (_xsd_route_entry,
                       ::xml_schema::flags (),
                       this)
    {
    }

    route_add_event::
    route_add_event (const route_add_event& _xsd_route_add_event,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_route_add_event, f, c),
    _xsd_route_entry_ (_xsd_route_add_event._xsd_route_entry_,
                       f | ::xml_schema::flags::not_root,
                       this)
    {
    }

    route_add_event::
    route_add_event (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_route_entry_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void route_add_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // route_entry
        //
        {
          if (e.name () == "route_entry" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< route_entry::type > r (
              route_entry::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_route_entry_.present ())
              continue;
            this->route_entry (r);
            continue;
          }
        }
      }

      if (!_xsd_route_entry_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "route_entry",
          "");
      }
    }

    route_add_event* route_add_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new route_add_event (*this, f, c);
    }

    // route_delete_event
    //

    route_delete_event::
    route_delete_event ()
    : ::xml_schema::type (),
    _xsd_dest_ (::xml_schema::flags (), this)
    {
    }

    route_delete_event::
    route_delete_event (const dest::type& _xsd_dest)
    : ::xml_schema::type (),
    _xsd_dest_ (_xsd_dest,
                ::xml_schema::flags (),
                this)
    {
    }

    route_delete_event::
    route_delete_event (const route_delete_event& _xsd_route_delete_event,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_route_delete_event, f, c),
    _xsd_dest_ (_xsd_route_delete_event._xsd_dest_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    route_delete_event::
    route_delete_event (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_dest_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void route_delete_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // dest
        //
        {
          if (e.name () == "dest" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< dest::type > r (
              dest::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_dest_.present ())
              continue;
            this->dest (r);
            continue;
          }
        }
      }

      if (!_xsd_dest_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "dest",
          "");
      }
    }

    route_delete_event* route_delete_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new route_delete_event (*this, f, c);
    }

    // custody_signal_event
    //

    custody_signal_event::
    custody_signal_event ()
    : ::xml_schema::type (),
    _xsd_orig_source_eid_ (::xml_schema::flags (), this),
    _xsd_admin_type_ (::xml_schema::flags (), this),
    _xsd_admin_flags_ (::xml_schema::flags (), this),
    _xsd_succeeded_ (::xml_schema::flags (), this),
    _xsd_reason_ (::xml_schema::flags (), this),
    _xsd_orig_frag_offset_ (::xml_schema::flags (), this),
    _xsd_orig_frag_length_ (::xml_schema::flags (), this),
    _xsd_custody_signal_seconds_ (::xml_schema::flags (), this),
    _xsd_custody_signal_seqno_ (::xml_schema::flags (), this),
    _xsd_orig_creation_seconds_ (::xml_schema::flags (), this),
    _xsd_orig_creation_seqno_ (::xml_schema::flags (), this)
    {
    }

    custody_signal_event::
    custody_signal_event (const orig_source_eid::type& _xsd_orig_source_eid,
                          const admin_type::type& _xsd_admin_type,
                          const admin_flags::type& _xsd_admin_flags,
                          const succeeded::type& _xsd_succeeded,
                          const reason::type& _xsd_reason,
                          const orig_frag_offset::type& _xsd_orig_frag_offset,
                          const orig_frag_length::type& _xsd_orig_frag_length,
                          const custody_signal_seconds::type& _xsd_custody_signal_seconds,
                          const custody_signal_seqno::type& _xsd_custody_signal_seqno,
                          const orig_creation_seconds::type& _xsd_orig_creation_seconds,
                          const orig_creation_seqno::type& _xsd_orig_creation_seqno)
    : ::xml_schema::type (),
    _xsd_orig_source_eid_ (_xsd_orig_source_eid,
                           ::xml_schema::flags (),
                           this),
    _xsd_admin_type_ (_xsd_admin_type,
                      ::xml_schema::flags (),
                      this),
    _xsd_admin_flags_ (_xsd_admin_flags,
                       ::xml_schema::flags (),
                       this),
    _xsd_succeeded_ (_xsd_succeeded,
                     ::xml_schema::flags (),
                     this),
    _xsd_reason_ (_xsd_reason,
                  ::xml_schema::flags (),
                  this),
    _xsd_orig_frag_offset_ (_xsd_orig_frag_offset,
                            ::xml_schema::flags (),
                            this),
    _xsd_orig_frag_length_ (_xsd_orig_frag_length,
                            ::xml_schema::flags (),
                            this),
    _xsd_custody_signal_seconds_ (_xsd_custody_signal_seconds,
                                  ::xml_schema::flags (),
                                  this),
    _xsd_custody_signal_seqno_ (_xsd_custody_signal_seqno,
                                ::xml_schema::flags (),
                                this),
    _xsd_orig_creation_seconds_ (_xsd_orig_creation_seconds,
                                 ::xml_schema::flags (),
                                 this),
    _xsd_orig_creation_seqno_ (_xsd_orig_creation_seqno,
                               ::xml_schema::flags (),
                               this)
    {
    }

    custody_signal_event::
    custody_signal_event (const custody_signal_event& _xsd_custody_signal_event,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_custody_signal_event, f, c),
    _xsd_orig_source_eid_ (_xsd_custody_signal_event._xsd_orig_source_eid_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_admin_type_ (_xsd_custody_signal_event._xsd_admin_type_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_admin_flags_ (_xsd_custody_signal_event._xsd_admin_flags_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_succeeded_ (_xsd_custody_signal_event._xsd_succeeded_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_reason_ (_xsd_custody_signal_event._xsd_reason_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_orig_frag_offset_ (_xsd_custody_signal_event._xsd_orig_frag_offset_,
                            f | ::xml_schema::flags::not_root,
                            this),
    _xsd_orig_frag_length_ (_xsd_custody_signal_event._xsd_orig_frag_length_,
                            f | ::xml_schema::flags::not_root,
                            this),
    _xsd_custody_signal_seconds_ (_xsd_custody_signal_event._xsd_custody_signal_seconds_,
                                  f | ::xml_schema::flags::not_root,
                                  this),
    _xsd_custody_signal_seqno_ (_xsd_custody_signal_event._xsd_custody_signal_seqno_,
                                f | ::xml_schema::flags::not_root,
                                this),
    _xsd_orig_creation_seconds_ (_xsd_custody_signal_event._xsd_orig_creation_seconds_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_orig_creation_seqno_ (_xsd_custody_signal_event._xsd_orig_creation_seqno_,
                               f | ::xml_schema::flags::not_root,
                               this)
    {
    }

    custody_signal_event::
    custody_signal_event (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_orig_source_eid_ (f | ::xml_schema::flags::not_root, this),
    _xsd_admin_type_ (f | ::xml_schema::flags::not_root, this),
    _xsd_admin_flags_ (f | ::xml_schema::flags::not_root, this),
    _xsd_succeeded_ (f | ::xml_schema::flags::not_root, this),
    _xsd_reason_ (f | ::xml_schema::flags::not_root, this),
    _xsd_orig_frag_offset_ (f | ::xml_schema::flags::not_root, this),
    _xsd_orig_frag_length_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custody_signal_seconds_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custody_signal_seqno_ (f | ::xml_schema::flags::not_root, this),
    _xsd_orig_creation_seconds_ (f | ::xml_schema::flags::not_root, this),
    _xsd_orig_creation_seqno_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void custody_signal_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // orig_source_eid
        //
        {
          if (e.name () == "orig_source_eid" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< orig_source_eid::type > r (
              orig_source_eid::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_orig_source_eid_.present ())
              continue;
            this->orig_source_eid (r);
            continue;
          }
        }
      }

      if (!_xsd_orig_source_eid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "orig_source_eid",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "admin_type" && a.namespace_ ().empty ())
        {
          this->admin_type (
            admin_type::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "admin_flags" && a.namespace_ ().empty ())
        {
          this->admin_flags (
            admin_flags::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "succeeded" && a.namespace_ ().empty ())
        {
          this->succeeded (
            succeeded::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "reason" && a.namespace_ ().empty ())
        {
          this->reason (
            reason::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "orig_frag_offset" && a.namespace_ ().empty ())
        {
          this->orig_frag_offset (
            orig_frag_offset::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "orig_frag_length" && a.namespace_ ().empty ())
        {
          this->orig_frag_length (
            orig_frag_length::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "custody_signal_seconds" && a.namespace_ ().empty ())
        {
          this->custody_signal_seconds (
            custody_signal_seconds::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "custody_signal_seqno" && a.namespace_ ().empty ())
        {
          this->custody_signal_seqno (
            custody_signal_seqno::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "orig_creation_seconds" && a.namespace_ ().empty ())
        {
          this->orig_creation_seconds (
            orig_creation_seconds::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "orig_creation_seqno" && a.namespace_ ().empty ())
        {
          this->orig_creation_seqno (
            orig_creation_seqno::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_admin_type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "admin_type",
          "");
      }

      if (!_xsd_admin_flags_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "admin_flags",
          "");
      }

      if (!_xsd_succeeded_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "succeeded",
          "");
      }

      if (!_xsd_reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reason",
          "");
      }

      if (!_xsd_orig_frag_offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "orig_frag_offset",
          "");
      }

      if (!_xsd_orig_frag_length_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "orig_frag_length",
          "");
      }

      if (!_xsd_custody_signal_seconds_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "custody_signal_seconds",
          "");
      }

      if (!_xsd_custody_signal_seqno_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "custody_signal_seqno",
          "");
      }

      if (!_xsd_orig_creation_seconds_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "orig_creation_seconds",
          "");
      }

      if (!_xsd_orig_creation_seqno_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "orig_creation_seqno",
          "");
      }
    }

    custody_signal_event* custody_signal_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new custody_signal_event (*this, f, c);
    }

    // custody_timeout_event
    //

    custody_timeout_event::
    custody_timeout_event ()
    : ::xml_schema::type (),
    _xsd_bundle_ (::xml_schema::flags (), this),
    _xsd_link_ (::xml_schema::flags (), this)
    {
    }

    custody_timeout_event::
    custody_timeout_event (const bundle::type& _xsd_bundle,
                           const link::type& _xsd_link)
    : ::xml_schema::type (),
    _xsd_bundle_ (_xsd_bundle,
                  ::xml_schema::flags (),
                  this),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this)
    {
    }

    custody_timeout_event::
    custody_timeout_event (const custody_timeout_event& _xsd_custody_timeout_event,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_custody_timeout_event, f, c),
    _xsd_bundle_ (_xsd_custody_timeout_event._xsd_bundle_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_link_ (_xsd_custody_timeout_event._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    custody_timeout_event::
    custody_timeout_event (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void custody_timeout_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle
        //
        {
          if (e.name () == "bundle" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< bundle::type > r (
              bundle::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_bundle_.present ())
              continue;
            this->bundle (r);
            continue;
          }
        }

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_link_.present ())
              continue;
            this->link (r);
            continue;
          }
        }
      }

      if (!_xsd_bundle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "bundle",
          "");
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "link",
          "");
      }
    }

    custody_timeout_event* custody_timeout_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new custody_timeout_event (*this, f, c);
    }

    // registration_added_event
    //

    registration_added_event::
    registration_added_event ()
    : ::xml_schema::type (),
    _xsd_registration_ (::xml_schema::flags (), this),
    _xsd_source_ (::xml_schema::flags (), this)
    {
    }

    registration_added_event::
    registration_added_event (const registration::type& _xsd_registration,
                              const source::type& _xsd_source)
    : ::xml_schema::type (),
    _xsd_registration_ (_xsd_registration,
                        ::xml_schema::flags (),
                        this),
    _xsd_source_ (_xsd_source,
                  ::xml_schema::flags (),
                  this)
    {
    }

    registration_added_event::
    registration_added_event (const registration_added_event& _xsd_registration_added_event,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_registration_added_event, f, c),
    _xsd_registration_ (_xsd_registration_added_event._xsd_registration_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_source_ (_xsd_registration_added_event._xsd_source_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    registration_added_event::
    registration_added_event (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_registration_ (f | ::xml_schema::flags::not_root, this),
    _xsd_source_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void registration_added_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // registration
        //
        {
          if (e.name () == "registration" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< registration::type > r (
              registration::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_registration_.present ())
              continue;
            this->registration (r);
            continue;
          }
        }
      }

      if (!_xsd_registration_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "registration",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "source" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< source::type > r (
            source::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->source (r);
          continue;
        }
      }

      if (!_xsd_source_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "source",
          "");
      }
    }

    registration_added_event* registration_added_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new registration_added_event (*this, f, c);
    }

    // registration_removed_event
    //

    registration_removed_event::
    registration_removed_event ()
    : ::xml_schema::type (),
    _xsd_registration_ (::xml_schema::flags (), this)
    {
    }

    registration_removed_event::
    registration_removed_event (const registration::type& _xsd_registration)
    : ::xml_schema::type (),
    _xsd_registration_ (_xsd_registration,
                        ::xml_schema::flags (),
                        this)
    {
    }

    registration_removed_event::
    registration_removed_event (const registration_removed_event& _xsd_registration_removed_event,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_registration_removed_event, f, c),
    _xsd_registration_ (_xsd_registration_removed_event._xsd_registration_,
                        f | ::xml_schema::flags::not_root,
                        this)
    {
    }

    registration_removed_event::
    registration_removed_event (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_registration_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void registration_removed_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // registration
        //
        {
          if (e.name () == "registration" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< registration::type > r (
              registration::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (_xsd_registration_.present ())
              continue;
            this->registration (r);
            continue;
          }
        }
      }

      if (!_xsd_registration_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "registration",
          "");
      }
    }

    registration_removed_event* registration_removed_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new registration_removed_event (*this, f, c);
    }

    // registration_expired_event
    //

    registration_expired_event::
    registration_expired_event ()
    : ::xml_schema::type (),
    _xsd_regid_ (::xml_schema::flags (), this)
    {
    }

    registration_expired_event::
    registration_expired_event (const regid::type& _xsd_regid)
    : ::xml_schema::type (),
    _xsd_regid_ (_xsd_regid,
                 ::xml_schema::flags (),
                 this)
    {
    }

    registration_expired_event::
    registration_expired_event (const registration_expired_event& _xsd_registration_expired_event,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_registration_expired_event, f, c),
    _xsd_regid_ (_xsd_registration_expired_event._xsd_regid_,
                 f | ::xml_schema::flags::not_root,
                 this)
    {
    }

    registration_expired_event::
    registration_expired_event (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_regid_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void registration_expired_event::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "regid" && a.namespace_ ().empty ())
        {
          this->regid (
            regid::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }

      if (!_xsd_regid_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "regid",
          "");
      }
    }

    registration_expired_event* registration_expired_event::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new registration_expired_event (*this, f, c);
    }

    // open_link_request
    //

    open_link_request::
    open_link_request ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this)
    {
    }

    open_link_request::
    open_link_request (const link::type& _xsd_link)
    : ::xml_schema::type (),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this)
    {
    }

    open_link_request::
    open_link_request (const open_link_request& _xsd_open_link_request,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_open_link_request, f, c),
    _xsd_link_ (_xsd_open_link_request._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    open_link_request::
    open_link_request (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void open_link_request::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "link" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< link::type > r (
            link::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->link (r);
          continue;
        }
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "link",
          "");
      }
    }

    open_link_request* open_link_request::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new open_link_request (*this, f, c);
    }

    // send_bundle_request
    //

    send_bundle_request::
    send_bundle_request ()
    : ::xml_schema::type (),
    _xsd_bundleid_ (::xml_schema::flags (), this),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_fwd_action_ (::xml_schema::flags (), this)
    {
    }

    send_bundle_request::
    send_bundle_request (const bundleid::type& _xsd_bundleid,
                         const link::type& _xsd_link,
                         const fwd_action::type& _xsd_fwd_action)
    : ::xml_schema::type (),
    _xsd_bundleid_ (_xsd_bundleid,
                    ::xml_schema::flags (),
                    this),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_fwd_action_ (_xsd_fwd_action,
                      ::xml_schema::flags (),
                      this)
    {
    }

    send_bundle_request::
    send_bundle_request (const send_bundle_request& _xsd_send_bundle_request,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_send_bundle_request, f, c),
    _xsd_bundleid_ (_xsd_send_bundle_request._xsd_bundleid_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_link_ (_xsd_send_bundle_request._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_fwd_action_ (_xsd_send_bundle_request._xsd_fwd_action_,
                      f | ::xml_schema::flags::not_root,
                      this)
    {
    }

    send_bundle_request::
    send_bundle_request (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundleid_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_fwd_action_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void send_bundle_request::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "bundleid" && a.namespace_ ().empty ())
        {
          this->bundleid (
            bundleid::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "link" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< link::type > r (
            link::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->link (r);
          continue;
        }

        if (a.name () == "fwd_action" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< fwd_action::type > r (
            fwd_action::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->fwd_action (r);
          continue;
        }
      }

      if (!_xsd_bundleid_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bundleid",
          "");
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "link",
          "");
      }

      if (!_xsd_fwd_action_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "fwd_action",
          "");
      }
    }

    send_bundle_request* send_bundle_request::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new send_bundle_request (*this, f, c);
    }

    // cancel_bundle_request
    //

    cancel_bundle_request::
    cancel_bundle_request ()
    : ::xml_schema::type (),
    _xsd_bundleid_ (::xml_schema::flags (), this),
    _xsd_link_ (::xml_schema::flags (), this)
    {
    }

    cancel_bundle_request::
    cancel_bundle_request (const bundleid::type& _xsd_bundleid,
                           const link::type& _xsd_link)
    : ::xml_schema::type (),
    _xsd_bundleid_ (_xsd_bundleid,
                    ::xml_schema::flags (),
                    this),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this)
    {
    }

    cancel_bundle_request::
    cancel_bundle_request (const cancel_bundle_request& _xsd_cancel_bundle_request,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_cancel_bundle_request, f, c),
    _xsd_bundleid_ (_xsd_cancel_bundle_request._xsd_bundleid_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_link_ (_xsd_cancel_bundle_request._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    cancel_bundle_request::
    cancel_bundle_request (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundleid_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void cancel_bundle_request::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "bundleid" && a.namespace_ ().empty ())
        {
          this->bundleid (
            bundleid::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "link" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< link::type > r (
            link::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->link (r);
          continue;
        }
      }

      if (!_xsd_bundleid_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "bundleid",
          "");
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "link",
          "");
      }
    }

    cancel_bundle_request* cancel_bundle_request::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new cancel_bundle_request (*this, f, c);
    }

    // inject_bundle_request
    //

    inject_bundle_request::
    inject_bundle_request ()
    : ::xml_schema::type (),
    _xsd_source_ (::xml_schema::flags (), this),
    _xsd_dest_ (::xml_schema::flags (), this),
    _xsd_replyto_ (::xml_schema::flags (), this),
    _xsd_custodian_ (::xml_schema::flags (), this),
    _xsd_link_ (::xml_schema::flags (), this),
    _xsd_fwd_action_ (::xml_schema::flags (), this),
    _xsd_priority_ (::xml_schema::flags (), this),
    _xsd_expiration_ (::xml_schema::flags (), this),
    _xsd_payload_ (::xml_schema::flags (), this)
    {
    }

    inject_bundle_request::
    inject_bundle_request (const source::type& _xsd_source,
                           const dest::type& _xsd_dest,
                           const link::type& _xsd_link,
                           const payload::type& _xsd_payload)
    : ::xml_schema::type (),
    _xsd_source_ (_xsd_source,
                  ::xml_schema::flags (),
                  this),
    _xsd_dest_ (_xsd_dest,
                ::xml_schema::flags (),
                this),
    _xsd_replyto_ (::xml_schema::flags (), this),
    _xsd_custodian_ (::xml_schema::flags (), this),
    _xsd_link_ (_xsd_link,
                ::xml_schema::flags (),
                this),
    _xsd_fwd_action_ (::xml_schema::flags (), this),
    _xsd_priority_ (::xml_schema::flags (), this),
    _xsd_expiration_ (::xml_schema::flags (), this),
    _xsd_payload_ (_xsd_payload,
                   ::xml_schema::flags (),
                   this)
    {
    }

    inject_bundle_request::
    inject_bundle_request (const inject_bundle_request& _xsd_inject_bundle_request,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_inject_bundle_request, f, c),
    _xsd_source_ (_xsd_inject_bundle_request._xsd_source_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_dest_ (_xsd_inject_bundle_request._xsd_dest_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_replyto_ (_xsd_inject_bundle_request._xsd_replyto_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_custodian_ (_xsd_inject_bundle_request._xsd_custodian_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_link_ (_xsd_inject_bundle_request._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_fwd_action_ (_xsd_inject_bundle_request._xsd_fwd_action_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_priority_ (_xsd_inject_bundle_request._xsd_priority_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_expiration_ (_xsd_inject_bundle_request._xsd_expiration_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_payload_ (_xsd_inject_bundle_request._xsd_payload_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    inject_bundle_request::
    inject_bundle_request (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_source_ (f | ::xml_schema::flags::not_root, this),
    _xsd_dest_ (f | ::xml_schema::flags::not_root, this),
    _xsd_replyto_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custodian_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this),
    _xsd_fwd_action_ (f | ::xml_schema::flags::not_root, this),
    _xsd_priority_ (f | ::xml_schema::flags::not_root, this),
    _xsd_expiration_ (f | ::xml_schema::flags::not_root, this),
    _xsd_payload_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void inject_bundle_request::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "source" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< source::type > r (
            source::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->source (r);
          continue;
        }

        if (a.name () == "dest" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< dest::type > r (
            dest::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->dest (r);
          continue;
        }

        if (a.name () == "replyto" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< replyto::type > r (
            replyto::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->replyto (r);
          continue;
        }

        if (a.name () == "custodian" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< custodian::type > r (
            custodian::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->custodian (r);
          continue;
        }

        if (a.name () == "link" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< link::type > r (
            link::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->link (r);
          continue;
        }

        if (a.name () == "fwd_action" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< fwd_action::type > r (
            fwd_action::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->fwd_action (r);
          continue;
        }

        if (a.name () == "priority" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< priority::type > r (
            priority::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->priority (r);
          continue;
        }

        if (a.name () == "expiration" && a.namespace_ ().empty ())
        {
          this->expiration (
            expiration::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "payload" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< payload::type > r (
            payload::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->payload (r);
          continue;
        }
      }

      if (!_xsd_source_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "source",
          "");
      }

      if (!_xsd_dest_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "dest",
          "");
      }

      if (!_xsd_link_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "link",
          "");
      }

      if (!_xsd_payload_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "payload",
          "");
      }
    }

    inject_bundle_request* inject_bundle_request::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new inject_bundle_request (*this, f, c);
    }

    // link_report
    //

    link_report::
    link_report ()
    : ::xml_schema::type (),
    _xsd_link_ (::xml_schema::flags (), this)
    {
    }

    link_report::
    link_report (const link_report& _xsd_link_report,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_link_report, f, c),
    _xsd_link_ (_xsd_link_report._xsd_link_,
                f | ::xml_schema::flags::not_root,
                this)
    {
    }

    link_report::
    link_report (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_link_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void link_report::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // link
        //
        {
          if (e.name () == "link" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< link::type > r (
              link::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            this->link ().push_back (r);
            continue;
          }
        }
      }
    }

    link_report* link_report::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new link_report (*this, f, c);
    }

    // contact_report
    //

    contact_report::
    contact_report ()
    : ::xml_schema::type (),
    _xsd_contact_ (::xml_schema::flags (), this)
    {
    }

    contact_report::
    contact_report (const contact_report& _xsd_contact_report,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_contact_report, f, c),
    _xsd_contact_ (_xsd_contact_report._xsd_contact_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    contact_report::
    contact_report (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_contact_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void contact_report::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // contact
        //
        {
          if (e.name () == "contact" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< contact::type > r (
              contact::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            this->contact ().push_back (r);
            continue;
          }
        }
      }
    }

    contact_report* contact_report::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new contact_report (*this, f, c);
    }

    // route_report
    //

    route_report::
    route_report ()
    : ::xml_schema::type (),
    _xsd_route_entry_ (::xml_schema::flags (), this)
    {
    }

    route_report::
    route_report (const route_report& _xsd_route_report,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_route_report, f, c),
    _xsd_route_entry_ (_xsd_route_report._xsd_route_entry_,
                       f | ::xml_schema::flags::not_root,
                       this)
    {
    }

    route_report::
    route_report (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_route_entry_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void route_report::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // route_entry
        //
        {
          if (e.name () == "route_entry" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< route_entry::type > r (
              route_entry::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            this->route_entry ().push_back (r);
            continue;
          }
        }
      }
    }

    route_report* route_report::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new route_report (*this, f, c);
    }

    // bundle_report
    //

    bundle_report::
    bundle_report ()
    : ::xml_schema::type (),
    _xsd_bundle_ (::xml_schema::flags (), this)
    {
    }

    bundle_report::
    bundle_report (const bundle_report& _xsd_bundle_report,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_bundle_report, f, c),
    _xsd_bundle_ (_xsd_bundle_report._xsd_bundle_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    bundle_report::
    bundle_report (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void bundle_report::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle
        //
        {
          if (e.name () == "bundle" && e.namespace_ ().empty ())
          {
            ::std::auto_ptr< bundle::type > r (
              bundle::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            this->bundle ().push_back (r);
            continue;
          }
        }
      }
    }

    bundle_report* bundle_report::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new bundle_report (*this, f, c);
    }

    // dtn
    //

    dtn::
    dtn ()
    : ::xml_schema::type (),
    _xsd_bundle_received_event_ (::xml_schema::flags (), this),
    _xsd_bundle_transmitted_event_ (::xml_schema::flags (), this),
    _xsd_bundle_transmit_failed_event_ (::xml_schema::flags (), this),
    _xsd_bundle_delivery_event_ (::xml_schema::flags (), this),
    _xsd_bundle_expired_event_ (::xml_schema::flags (), this),
    _xsd_contact_up_event_ (::xml_schema::flags (), this),
    _xsd_contact_down_event_ (::xml_schema::flags (), this),
    _xsd_link_created_event_ (::xml_schema::flags (), this),
    _xsd_link_deleted_event_ (::xml_schema::flags (), this),
    _xsd_link_available_event_ (::xml_schema::flags (), this),
    _xsd_link_unavailable_event_ (::xml_schema::flags (), this),
    _xsd_link_busy_event_ (::xml_schema::flags (), this),
    _xsd_route_add_event_ (::xml_schema::flags (), this),
    _xsd_route_delete_event_ (::xml_schema::flags (), this),
    _xsd_custody_signal_event_ (::xml_schema::flags (), this),
    _xsd_custody_timeout_event_ (::xml_schema::flags (), this),
    _xsd_registration_added_event_ (::xml_schema::flags (), this),
    _xsd_registration_removed_event_ (::xml_schema::flags (), this),
    _xsd_registration_expired_event_ (::xml_schema::flags (), this),
    _xsd_open_link_request_ (::xml_schema::flags (), this),
    _xsd_send_bundle_request_ (::xml_schema::flags (), this),
    _xsd_cancel_bundle_request_ (::xml_schema::flags (), this),
    _xsd_inject_bundle_request_ (::xml_schema::flags (), this),
    _xsd_link_query_ (::xml_schema::flags (), this),
    _xsd_link_report_ (::xml_schema::flags (), this),
    _xsd_contact_query_ (::xml_schema::flags (), this),
    _xsd_contact_report_ (::xml_schema::flags (), this),
    _xsd_route_query_ (::xml_schema::flags (), this),
    _xsd_route_report_ (::xml_schema::flags (), this),
    _xsd_bundle_query_ (::xml_schema::flags (), this),
    _xsd_bundle_report_ (::xml_schema::flags (), this),
    _xsd_eid_ (::xml_schema::flags (), this),
    _xsd_hello_interval_ (::xml_schema::flags (), this),
    _xsd_alert_ (::xml_schema::flags (), this)
    {
    }

    dtn::
    dtn (const dtn& _xsd_dtn,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_dtn, f, c),
    _xsd_bundle_received_event_ (_xsd_dtn._xsd_bundle_received_event_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_bundle_transmitted_event_ (_xsd_dtn._xsd_bundle_transmitted_event_,
                                    f | ::xml_schema::flags::not_root,
                                    this),
    _xsd_bundle_transmit_failed_event_ (_xsd_dtn._xsd_bundle_transmit_failed_event_,
                                        f | ::xml_schema::flags::not_root,
                                        this),
    _xsd_bundle_delivery_event_ (_xsd_dtn._xsd_bundle_delivery_event_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_bundle_expired_event_ (_xsd_dtn._xsd_bundle_expired_event_,
                                f | ::xml_schema::flags::not_root,
                                this),
    _xsd_contact_up_event_ (_xsd_dtn._xsd_contact_up_event_,
                            f | ::xml_schema::flags::not_root,
                            this),
    _xsd_contact_down_event_ (_xsd_dtn._xsd_contact_down_event_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_link_created_event_ (_xsd_dtn._xsd_link_created_event_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_link_deleted_event_ (_xsd_dtn._xsd_link_deleted_event_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_link_available_event_ (_xsd_dtn._xsd_link_available_event_,
                                f | ::xml_schema::flags::not_root,
                                this),
    _xsd_link_unavailable_event_ (_xsd_dtn._xsd_link_unavailable_event_,
                                  f | ::xml_schema::flags::not_root,
                                  this),
    _xsd_link_busy_event_ (_xsd_dtn._xsd_link_busy_event_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_route_add_event_ (_xsd_dtn._xsd_route_add_event_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_route_delete_event_ (_xsd_dtn._xsd_route_delete_event_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_custody_signal_event_ (_xsd_dtn._xsd_custody_signal_event_,
                                f | ::xml_schema::flags::not_root,
                                this),
    _xsd_custody_timeout_event_ (_xsd_dtn._xsd_custody_timeout_event_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_registration_added_event_ (_xsd_dtn._xsd_registration_added_event_,
                                    f | ::xml_schema::flags::not_root,
                                    this),
    _xsd_registration_removed_event_ (_xsd_dtn._xsd_registration_removed_event_,
                                      f | ::xml_schema::flags::not_root,
                                      this),
    _xsd_registration_expired_event_ (_xsd_dtn._xsd_registration_expired_event_,
                                      f | ::xml_schema::flags::not_root,
                                      this),
    _xsd_open_link_request_ (_xsd_dtn._xsd_open_link_request_,
                             f | ::xml_schema::flags::not_root,
                             this),
    _xsd_send_bundle_request_ (_xsd_dtn._xsd_send_bundle_request_,
                               f | ::xml_schema::flags::not_root,
                               this),
    _xsd_cancel_bundle_request_ (_xsd_dtn._xsd_cancel_bundle_request_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_inject_bundle_request_ (_xsd_dtn._xsd_inject_bundle_request_,
                                 f | ::xml_schema::flags::not_root,
                                 this),
    _xsd_link_query_ (_xsd_dtn._xsd_link_query_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_link_report_ (_xsd_dtn._xsd_link_report_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_contact_query_ (_xsd_dtn._xsd_contact_query_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_contact_report_ (_xsd_dtn._xsd_contact_report_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_route_query_ (_xsd_dtn._xsd_route_query_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_route_report_ (_xsd_dtn._xsd_route_report_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_bundle_query_ (_xsd_dtn._xsd_bundle_query_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_bundle_report_ (_xsd_dtn._xsd_bundle_report_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_eid_ (_xsd_dtn._xsd_eid_,
               f | ::xml_schema::flags::not_root,
               this),
    _xsd_hello_interval_ (_xsd_dtn._xsd_hello_interval_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_alert_ (_xsd_dtn._xsd_alert_,
                 f | ::xml_schema::flags::not_root,
                 this)
    {
    }

    dtn::
    dtn (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_bundle_received_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bundle_transmitted_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bundle_transmit_failed_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bundle_delivery_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bundle_expired_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_contact_up_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_contact_down_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_created_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_deleted_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_available_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_unavailable_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_busy_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_route_add_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_route_delete_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custody_signal_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_custody_timeout_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_registration_added_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_registration_removed_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_registration_expired_event_ (f | ::xml_schema::flags::not_root, this),
    _xsd_open_link_request_ (f | ::xml_schema::flags::not_root, this),
    _xsd_send_bundle_request_ (f | ::xml_schema::flags::not_root, this),
    _xsd_cancel_bundle_request_ (f | ::xml_schema::flags::not_root, this),
    _xsd_inject_bundle_request_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_query_ (f | ::xml_schema::flags::not_root, this),
    _xsd_link_report_ (f | ::xml_schema::flags::not_root, this),
    _xsd_contact_query_ (f | ::xml_schema::flags::not_root, this),
    _xsd_contact_report_ (f | ::xml_schema::flags::not_root, this),
    _xsd_route_query_ (f | ::xml_schema::flags::not_root, this),
    _xsd_route_report_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bundle_query_ (f | ::xml_schema::flags::not_root, this),
    _xsd_bundle_report_ (f | ::xml_schema::flags::not_root, this),
    _xsd_eid_ (f | ::xml_schema::flags::not_root, this),
    _xsd_hello_interval_ (f | ::xml_schema::flags::not_root, this),
    _xsd_alert_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void dtn::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

        // bundle_received_event
        //
        {
          if (e.name () == "bundle_received_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< bundle_received_event::type > r (
              bundle_received_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->bundle_received_event ())
              continue;
            this->bundle_received_event (r);
            continue;
          }
        }

        // bundle_transmitted_event
        //
        {
          if (e.name () == "bundle_transmitted_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< bundle_transmitted_event::type > r (
              bundle_transmitted_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->bundle_transmitted_event ())
              continue;
            this->bundle_transmitted_event (r);
            continue;
          }
        }

        // bundle_transmit_failed_event
        //
        {
          if (e.name () == "bundle_transmit_failed_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< bundle_transmit_failed_event::type > r (
              bundle_transmit_failed_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->bundle_transmit_failed_event ())
              continue;
            this->bundle_transmit_failed_event (r);
            continue;
          }
        }

        // bundle_delivery_event
        //
        {
          if (e.name () == "bundle_delivery_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< bundle_delivery_event::type > r (
              bundle_delivery_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->bundle_delivery_event ())
              continue;
            this->bundle_delivery_event (r);
            continue;
          }
        }

        // bundle_expired_event
        //
        {
          if (e.name () == "bundle_expired_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< bundle_expired_event::type > r (
              bundle_expired_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->bundle_expired_event ())
              continue;
            this->bundle_expired_event (r);
            continue;
          }
        }

        // contact_up_event
        //
        {
          if (e.name () == "contact_up_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< contact_up_event::type > r (
              contact_up_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->contact_up_event ())
              continue;
            this->contact_up_event (r);
            continue;
          }
        }

        // contact_down_event
        //
        {
          if (e.name () == "contact_down_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< contact_down_event::type > r (
              contact_down_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->contact_down_event ())
              continue;
            this->contact_down_event (r);
            continue;
          }
        }

        // link_created_event
        //
        {
          if (e.name () == "link_created_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< link_created_event::type > r (
              link_created_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->link_created_event ())
              continue;
            this->link_created_event (r);
            continue;
          }
        }

        // link_deleted_event
        //
        {
          if (e.name () == "link_deleted_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< link_deleted_event::type > r (
              link_deleted_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->link_deleted_event ())
              continue;
            this->link_deleted_event (r);
            continue;
          }
        }

        // link_available_event
        //
        {
          if (e.name () == "link_available_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< link_available_event::type > r (
              link_available_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->link_available_event ())
              continue;
            this->link_available_event (r);
            continue;
          }
        }

        // link_unavailable_event
        //
        {
          if (e.name () == "link_unavailable_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< link_unavailable_event::type > r (
              link_unavailable_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->link_unavailable_event ())
              continue;
            this->link_unavailable_event (r);
            continue;
          }
        }

        // link_busy_event
        //
        {
          if (e.name () == "link_busy_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< link_busy_event::type > r (
              link_busy_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->link_busy_event ())
              continue;
            this->link_busy_event (r);
            continue;
          }
        }

        // route_add_event
        //
        {
          if (e.name () == "route_add_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< route_add_event::type > r (
              route_add_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->route_add_event ())
              continue;
            this->route_add_event (r);
            continue;
          }
        }

        // route_delete_event
        //
        {
          if (e.name () == "route_delete_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< route_delete_event::type > r (
              route_delete_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->route_delete_event ())
              continue;
            this->route_delete_event (r);
            continue;
          }
        }

        // custody_signal_event
        //
        {
          if (e.name () == "custody_signal_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< custody_signal_event::type > r (
              custody_signal_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->custody_signal_event ())
              continue;
            this->custody_signal_event (r);
            continue;
          }
        }

        // custody_timeout_event
        //
        {
          if (e.name () == "custody_timeout_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< custody_timeout_event::type > r (
              custody_timeout_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->custody_timeout_event ())
              continue;
            this->custody_timeout_event (r);
            continue;
          }
        }

        // registration_added_event
        //
        {
          if (e.name () == "registration_added_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< registration_added_event::type > r (
              registration_added_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->registration_added_event ())
              continue;
            this->registration_added_event (r);
            continue;
          }
        }

        // registration_removed_event
        //
        {
          if (e.name () == "registration_removed_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< registration_removed_event::type > r (
              registration_removed_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->registration_removed_event ())
              continue;
            this->registration_removed_event (r);
            continue;
          }
        }

        // registration_expired_event
        //
        {
          if (e.name () == "registration_expired_event" && e.namespace_ () == "")
          {
            ::std::auto_ptr< registration_expired_event::type > r (
              registration_expired_event::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->registration_expired_event ())
              continue;
            this->registration_expired_event (r);
            continue;
          }
        }

        // open_link_request
        //
        {
          if (e.name () == "open_link_request" && e.namespace_ () == "")
          {
            ::std::auto_ptr< open_link_request::type > r (
              open_link_request::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->open_link_request ())
              continue;
            this->open_link_request (r);
            continue;
          }
        }

        // send_bundle_request
        //
        {
          if (e.name () == "send_bundle_request" && e.namespace_ () == "")
          {
            ::std::auto_ptr< send_bundle_request::type > r (
              send_bundle_request::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->send_bundle_request ())
              continue;
            this->send_bundle_request (r);
            continue;
          }
        }

        // cancel_bundle_request
        //
        {
          if (e.name () == "cancel_bundle_request" && e.namespace_ () == "")
          {
            ::std::auto_ptr< cancel_bundle_request::type > r (
              cancel_bundle_request::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->cancel_bundle_request ())
              continue;
            this->cancel_bundle_request (r);
            continue;
          }
        }

        // inject_bundle_request
        //
        {
          if (e.name () == "inject_bundle_request" && e.namespace_ () == "")
          {
            ::std::auto_ptr< inject_bundle_request::type > r (
              inject_bundle_request::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->inject_bundle_request ())
              continue;
            this->inject_bundle_request (r);
            continue;
          }
        }

        // link_query
        //
        {
          if (e.name () == "link_query" && e.namespace_ () == "")
          {
            ::std::auto_ptr< link_query::type > r (
              link_query::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->link_query ())
              continue;
            this->link_query (r);
            continue;
          }
        }

        // link_report
        //
        {
          if (e.name () == "link_report" && e.namespace_ () == "")
          {
            ::std::auto_ptr< link_report::type > r (
              link_report::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->link_report ())
              continue;
            this->link_report (r);
            continue;
          }
        }

        // contact_query
        //
        {
          if (e.name () == "contact_query" && e.namespace_ () == "")
          {
            ::std::auto_ptr< contact_query::type > r (
              contact_query::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->contact_query ())
              continue;
            this->contact_query (r);
            continue;
          }
        }

        // contact_report
        //
        {
          if (e.name () == "contact_report" && e.namespace_ () == "")
          {
            ::std::auto_ptr< contact_report::type > r (
              contact_report::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->contact_report ())
              continue;
            this->contact_report (r);
            continue;
          }
        }

        // route_query
        //
        {
          if (e.name () == "route_query" && e.namespace_ () == "")
          {
            ::std::auto_ptr< route_query::type > r (
              route_query::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->route_query ())
              continue;
            this->route_query (r);
            continue;
          }
        }

        // route_report
        //
        {
          if (e.name () == "route_report" && e.namespace_ () == "")
          {
            ::std::auto_ptr< route_report::type > r (
              route_report::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->route_report ())
              continue;
            this->route_report (r);
            continue;
          }
        }

        // bundle_query
        //
        {
          if (e.name () == "bundle_query" && e.namespace_ () == "")
          {
            ::std::auto_ptr< bundle_query::type > r (
              bundle_query::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->bundle_query ())
              continue;
            this->bundle_query (r);
            continue;
          }
        }

        // bundle_report
        //
        {
          if (e.name () == "bundle_report" && e.namespace_ () == "")
          {
            ::std::auto_ptr< bundle_report::type > r (
              bundle_report::traits::create (
                e.dom_element (),
                f | ::xml_schema::flags::not_root,
                this));

            if (this->bundle_report ())
              continue;
            this->bundle_report (r);
            continue;
          }
        }
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

        if (a.name () == "eid" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< eid::type > r (
            eid::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->eid (r);
          continue;
        }

        if (a.name () == "hello_interval" && a.namespace_ ().empty ())
        {
          this->hello_interval (
            hello_interval::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }

        if (a.name () == "alert" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< alert::type > r (
            alert::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->alert (r);
          continue;
        }
      }
    }

    dtn* dtn::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new dtn (*this, f, c);
    }
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dtn
{
  namespace rtrmessage
  {
    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::std::basic_string< char >& u,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::dtn::rtrmessage::dtn_ (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::std::basic_string< char >& u,
          ::xsd::cxx::xml::error_handler< char >& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::dtn::rtrmessage::dtn_ (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::std::basic_string< char >& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::dtn::rtrmessage::dtn_ (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::dtn::rtrmessage::dtn_ (wrap, f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream& is,
          ::xsd::cxx::xml::error_handler< char >& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::dtn::rtrmessage::dtn_ (wrap, h, f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::dtn::rtrmessage::dtn_ (wrap, h, f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream& is,
          const ::std::basic_string< char >& sid,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::dtn::rtrmessage::dtn_ (wrap, f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream& is,
          const ::std::basic_string< char >& sid,
          ::xsd::cxx::xml::error_handler< char >& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::dtn::rtrmessage::dtn_ (wrap, h, f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (::std::istream& is,
          const ::std::basic_string< char >& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::dtn::rtrmessage::dtn_ (wrap, h, f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMInputSource& i,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::dtn::rtrmessage::dtn_ (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMInputSource& i,
          ::xsd::cxx::xml::error_handler< char >& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::dtn::rtrmessage::dtn_ (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMInputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< char > ();
      }

      return ::dtn::rtrmessage::dtn_ (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::dtn::rtrmessage::dtn >
    dtn_ (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xsd::cxx::tree::properties< char >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< char > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      if (e.name () == "dtn" &&
          e.namespace_ () == "")
      {
        ::std::auto_ptr< ::dtn::rtrmessage::dtn > r (
          ::xsd::cxx::tree::traits< ::dtn::rtrmessage::dtn, char >::create (
            e.dom_element (), f, 0));
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        e.name (),
        e.namespace_ (),
        "dtn",
        "");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dtn
{
  namespace rtrmessage
  {
    void
    operator<< (::xercesc::DOMElement& e,
                dtnStatusType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                dtnStatusType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                dtnStatusType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                bundlePriorityType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                bundlePriorityType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                bundlePriorityType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                eventSourceType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                eventSourceType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                eventSourceType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                bundleForwardActionType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                bundleForwardActionType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                bundleForwardActionType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                contactReasonType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                contactReasonType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                contactReasonType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                linkTypeType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                linkTypeType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                linkTypeType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                linkStateType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                linkStateType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                linkStateType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const eidTypeType& v)
    {
      e << static_cast< const ::xml_schema::string& > (v);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                const eidTypeType& v)
    {
      a << static_cast< const ::xml_schema::string& > (v);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                const eidTypeType& v)
    {
      l << static_cast< const ::xml_schema::string& > (v);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                failureActionType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                failureActionType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                failureActionType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                bundleLocationType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                bundleLocationType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< char >& l,
                bundleLocationType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const eidType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "uri",
          e);

        a.dom_attribute () << i.uri ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const bundleType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "source",
          e);
        s.dom_element () << i.source ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "dest",
          e);
        s.dom_element () << i.dest ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "custodian",
          e);
        s.dom_element () << i.custodian ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "replyto",
          e);
        s.dom_element () << i.replyto ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "prevhop",
          e);
        s.dom_element () << i.prevhop ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "length",
          e);
        s.dom_element () << i.length ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "location",
          e);
        s.dom_element () << i.location ();
      }

      {
        if (i.payload ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "payload",
            e);
          s.dom_element () << *i.payload ();
        }
      }

      {
        if (i.recv_blocks ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "recv_blocks",
            e);
          s.dom_element () << *i.recv_blocks ();
        }
      }

      {
        if (i.api_blocks ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "api_blocks",
            e);
          s.dom_element () << *i.api_blocks ();
        }
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "bundleid",
          e);

        a.dom_attribute () << i.bundleid ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "is_fragment",
          e);

        a.dom_attribute () << i.is_fragment ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "is_admin",
          e);

        a.dom_attribute () << i.is_admin ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "do_not_fragment",
          e);

        a.dom_attribute () << i.do_not_fragment ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "priority",
          e);

        a.dom_attribute () << i.priority ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "custody_requested",
          e);

        a.dom_attribute () << i.custody_requested ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "local_custody",
          e);

        a.dom_attribute () << i.local_custody ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "singleton_dest",
          e);

        a.dom_attribute () << i.singleton_dest ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "custody_rcpt",
          e);

        a.dom_attribute () << i.custody_rcpt ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "receive_rcpt",
          e);

        a.dom_attribute () << i.receive_rcpt ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "forward_rcpt",
          e);

        a.dom_attribute () << i.forward_rcpt ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "delivery_rcpt",
          e);

        a.dom_attribute () << i.delivery_rcpt ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "deletion_rcpt",
          e);

        a.dom_attribute () << i.deletion_rcpt ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "app_acked_rcpt",
          e);

        a.dom_attribute () << i.app_acked_rcpt ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "creation_ts_seconds",
          e);

        a.dom_attribute () << i.creation_ts_seconds ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "creation_ts_seqno",
          e);

        a.dom_attribute () << i.creation_ts_seqno ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "expiration",
          e);

        a.dom_attribute () << i.expiration ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "orig_length",
          e);

        a.dom_attribute () << i.orig_length ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "frag_offset",
          e);

        a.dom_attribute () << i.frag_offset ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "owner",
          e);

        a.dom_attribute () << i.owner ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const contactType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "start_time_sec",
          e);

        a.dom_attribute () << i.start_time_sec ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "start_time_usec",
          e);

        a.dom_attribute () << i.start_time_usec ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "duration",
          e);

        a.dom_attribute () << i.duration ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "bps",
          e);

        a.dom_attribute () << i.bps ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "latency",
          e);

        a.dom_attribute () << i.latency ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const clInfoType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      if (i.local_addr ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "local_addr",
          e);

        a.dom_attribute () << *i.local_addr ();
      }

      if (i.remote_addr ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "remote_addr",
          e);

        a.dom_attribute () << *i.remote_addr ();
      }

      if (i.local_port ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "local_port",
          e);

        a.dom_attribute () << *i.local_port ();
      }

      if (i.remote_port ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "remote_port",
          e);

        a.dom_attribute () << *i.remote_port ();
      }

      if (i.segment_ack_enabled ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "segment_ack_enabled",
          e);

        a.dom_attribute () << *i.segment_ack_enabled ();
      }

      if (i.negative_ack_enabled ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "negative_ack_enabled",
          e);

        a.dom_attribute () << *i.negative_ack_enabled ();
      }

      if (i.keepalive_interval ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "keepalive_interval",
          e);

        a.dom_attribute () << *i.keepalive_interval ();
      }

      if (i.segment_length ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "segment_length",
          e);

        a.dom_attribute () << *i.segment_length ();
      }

      if (i.busy_queue_depth ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "busy_queue_depth",
          e);

        a.dom_attribute () << *i.busy_queue_depth ();
      }

      if (i.reactive_frag_enabled ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reactive_frag_enabled",
          e);

        a.dom_attribute () << *i.reactive_frag_enabled ();
      }

      if (i.sendbuf_length ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "sendbuf_length",
          e);

        a.dom_attribute () << *i.sendbuf_length ();
      }

      if (i.recvbuf_length ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "recvbuf_length",
          e);

        a.dom_attribute () << *i.recvbuf_length ();
      }

      if (i.data_timeout ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "data_timeout",
          e);

        a.dom_attribute () << *i.data_timeout ();
      }

      if (i.rate ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "rate",
          e);

        a.dom_attribute () << *i.rate ();
      }

      if (i.bucket_depth ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "bucket_depth",
          e);

        a.dom_attribute () << *i.bucket_depth ();
      }

      if (i.channel ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "channel",
          e);

        a.dom_attribute () << *i.channel ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const linkType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.clinfo ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "clinfo",
            e);
          s.dom_element () << *i.clinfo ();
        }
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "remote_eid",
          e);
        s.dom_element () << i.remote_eid ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "type",
          e);

        a.dom_attribute () << i.type ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "nexthop",
          e);

        a.dom_attribute () << i.nexthop ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "name",
          e);

        a.dom_attribute () << i.name ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "state",
          e);

        a.dom_attribute () << i.state ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reliable",
          e);

        a.dom_attribute () << i.reliable ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "clayer",
          e);

        a.dom_attribute () << i.clayer ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "min_retry_interval",
          e);

        a.dom_attribute () << i.min_retry_interval ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "max_retry_interval",
          e);

        a.dom_attribute () << i.max_retry_interval ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "idle_close_time",
          e);

        a.dom_attribute () << i.idle_close_time ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const routeEntryType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "dest_pattern",
          e);
        s.dom_element () << i.dest_pattern ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "source_pattern",
          e);
        s.dom_element () << i.source_pattern ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "route_priority",
          e);

        a.dom_attribute () << i.route_priority ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "action",
          e);

        a.dom_attribute () << i.action ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "link",
          e);

        a.dom_attribute () << i.link ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const registrationType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "endpoint",
          e);
        s.dom_element () << i.endpoint ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "regid",
          e);

        a.dom_attribute () << i.regid ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "action",
          e);

        a.dom_attribute () << i.action ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "script",
          e);

        a.dom_attribute () << i.script ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "expiration",
          e);

        a.dom_attribute () << i.expiration ();
      }
    }

    void
    dtn_ (::xercesc::DOMDocument& d,
          const ::dtn::rtrmessage::dtn& s,
          ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

      if (e.name () == "dtn" &&
          e.namespace_ () == "")
      {
        e.dom_element () << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          e.name (),
          e.namespace_ (),
          "dtn",
          "");
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    dtn_ (const ::dtn::rtrmessage::dtn& s,
          const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
          ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "dtn",
            "",
            m,
            f));
        ::dtn::rtrmessage::dtn_ (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
      }
    }

    void
    dtn_ (::xercesc::XMLFormatTarget& t,
          const ::dtn::rtrmessage::dtn& s,
          const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
          const ::std::basic_string< char >& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::dtn::rtrmessage::dtn_ (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    dtn_ (::xercesc::XMLFormatTarget& t,
          const ::dtn::rtrmessage::dtn& s,
          const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
          ::xsd::cxx::xml::error_handler< char >& h,
          const ::std::basic_string< char >& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::dtn::rtrmessage::dtn_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    dtn_ (::xercesc::XMLFormatTarget& t,
          const ::dtn::rtrmessage::dtn& s,
          const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
          ::xercesc::DOMErrorHandler& h,
          const ::std::basic_string< char >& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::dtn::rtrmessage::dtn_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    dtn_ (::std::ostream& o,
          const ::dtn::rtrmessage::dtn& s,
          const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
          const ::std::basic_string< char >& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::dtn::rtrmessage::dtn_ (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    dtn_ (::std::ostream& o,
          const ::dtn::rtrmessage::dtn& s,
          const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
          ::xsd::cxx::xml::error_handler< char >& h,
          const ::std::basic_string< char >& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::dtn::rtrmessage::dtn_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    dtn_ (::std::ostream& o,
          const ::dtn::rtrmessage::dtn& s,
          const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
          ::xercesc::DOMErrorHandler& h,
          const ::std::basic_string< char >& e,
          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::dtn::rtrmessage::dtn_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const bundle_received_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "bundle",
          e);
        s.dom_element () << i.bundle ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "source",
          e);

        a.dom_attribute () << i.source ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "bytes_received",
          e);

        a.dom_attribute () << i.bytes_received ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const bundle_transmitted_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "bundle",
          e);
        s.dom_element () << i.bundle ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "contact",
          e);
        s.dom_element () << i.contact ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "bytes_sent",
          e);

        a.dom_attribute () << i.bytes_sent ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reliably_sent",
          e);

        a.dom_attribute () << i.reliably_sent ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const bundle_transmit_failed_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "bundle",
          e);
        s.dom_element () << i.bundle ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "contact",
          e);
        s.dom_element () << i.contact ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const bundle_delivery_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "bundle",
          e);
        s.dom_element () << i.bundle ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "source",
          e);

        a.dom_attribute () << i.source ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const bundle_expired_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "bundle",
          e);
        s.dom_element () << i.bundle ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const contact_up_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "contact",
          e);
        s.dom_element () << i.contact ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const contact_down_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "contact",
          e);
        s.dom_element () << i.contact ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reason",
          e);

        a.dom_attribute () << i.reason ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const link_created_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reason",
          e);

        a.dom_attribute () << i.reason ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const link_deleted_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reason",
          e);

        a.dom_attribute () << i.reason ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const link_available_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reason",
          e);

        a.dom_attribute () << i.reason ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const link_unavailable_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reason",
          e);

        a.dom_attribute () << i.reason ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const link_busy_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const route_add_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "route_entry",
          e);
        s.dom_element () << i.route_entry ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const route_delete_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "dest",
          e);
        s.dom_element () << i.dest ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const custody_signal_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "orig_source_eid",
          e);
        s.dom_element () << i.orig_source_eid ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "admin_type",
          e);

        a.dom_attribute () << i.admin_type ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "admin_flags",
          e);

        a.dom_attribute () << i.admin_flags ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "succeeded",
          e);

        a.dom_attribute () << i.succeeded ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "reason",
          e);

        a.dom_attribute () << i.reason ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "orig_frag_offset",
          e);

        a.dom_attribute () << i.orig_frag_offset ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "orig_frag_length",
          e);

        a.dom_attribute () << i.orig_frag_length ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "custody_signal_seconds",
          e);

        a.dom_attribute () << i.custody_signal_seconds ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "custody_signal_seqno",
          e);

        a.dom_attribute () << i.custody_signal_seqno ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "orig_creation_seconds",
          e);

        a.dom_attribute () << i.orig_creation_seconds ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "orig_creation_seqno",
          e);

        a.dom_attribute () << i.orig_creation_seqno ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const custody_timeout_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "bundle",
          e);
        s.dom_element () << i.bundle ();
      }

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "link",
          e);
        s.dom_element () << i.link ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const registration_added_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "registration",
          e);
        s.dom_element () << i.registration ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "source",
          e);

        a.dom_attribute () << i.source ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const registration_removed_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::element< char > s (
          "registration",
          e);
        s.dom_element () << i.registration ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const registration_expired_event& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "regid",
          e);

        a.dom_attribute () << i.regid ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const open_link_request& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "link",
          e);

        a.dom_attribute () << i.link ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const send_bundle_request& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "bundleid",
          e);

        a.dom_attribute () << i.bundleid ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "link",
          e);

        a.dom_attribute () << i.link ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "fwd_action",
          e);

        a.dom_attribute () << i.fwd_action ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const cancel_bundle_request& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "bundleid",
          e);

        a.dom_attribute () << i.bundleid ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "link",
          e);

        a.dom_attribute () << i.link ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const inject_bundle_request& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "source",
          e);

        a.dom_attribute () << i.source ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "dest",
          e);

        a.dom_attribute () << i.dest ();
      }

      if (i.replyto ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "replyto",
          e);

        a.dom_attribute () << *i.replyto ();
      }

      if (i.custodian ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "custodian",
          e);

        a.dom_attribute () << *i.custodian ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "link",
          e);

        a.dom_attribute () << i.link ();
      }

      if (i.fwd_action ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "fwd_action",
          e);

        a.dom_attribute () << *i.fwd_action ();
      }

      if (i.priority ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "priority",
          e);

        a.dom_attribute () << *i.priority ();
      }

      if (i.expiration ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "expiration",
          e);

        a.dom_attribute () << *i.expiration ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "payload",
          e);

        a.dom_attribute () << i.payload ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const link_report& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        for (link_report::link::const_iterator
             b (i.link ().begin ()), n (i.link ().end ());
             b != n; ++b)
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link",
            e);
          s.dom_element () << *b;
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const contact_report& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        for (contact_report::contact::const_iterator
             b (i.contact ().begin ()), n (i.contact ().end ());
             b != n; ++b)
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "contact",
            e);
          s.dom_element () << *b;
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const route_report& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        for (route_report::route_entry::const_iterator
             b (i.route_entry ().begin ()), n (i.route_entry ().end ());
             b != n; ++b)
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "route_entry",
            e);
          s.dom_element () << *b;
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const bundle_report& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        for (bundle_report::bundle::const_iterator
             b (i.bundle ().begin ()), n (i.bundle ().end ());
             b != n; ++b)
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle",
            e);
          s.dom_element () << *b;
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const dtn& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        if (i.bundle_received_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle_received_event",
            e);
          s.dom_element () << *i.bundle_received_event ();
        }
      }

      {
        if (i.bundle_transmitted_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle_transmitted_event",
            e);
          s.dom_element () << *i.bundle_transmitted_event ();
        }
      }

      {
        if (i.bundle_transmit_failed_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle_transmit_failed_event",
            e);
          s.dom_element () << *i.bundle_transmit_failed_event ();
        }
      }

      {
        if (i.bundle_delivery_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle_delivery_event",
            e);
          s.dom_element () << *i.bundle_delivery_event ();
        }
      }

      {
        if (i.bundle_expired_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle_expired_event",
            e);
          s.dom_element () << *i.bundle_expired_event ();
        }
      }

      {
        if (i.contact_up_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "contact_up_event",
            e);
          s.dom_element () << *i.contact_up_event ();
        }
      }

      {
        if (i.contact_down_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "contact_down_event",
            e);
          s.dom_element () << *i.contact_down_event ();
        }
      }

      {
        if (i.link_created_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link_created_event",
            e);
          s.dom_element () << *i.link_created_event ();
        }
      }

      {
        if (i.link_deleted_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link_deleted_event",
            e);
          s.dom_element () << *i.link_deleted_event ();
        }
      }

      {
        if (i.link_available_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link_available_event",
            e);
          s.dom_element () << *i.link_available_event ();
        }
      }

      {
        if (i.link_unavailable_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link_unavailable_event",
            e);
          s.dom_element () << *i.link_unavailable_event ();
        }
      }

      {
        if (i.link_busy_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link_busy_event",
            e);
          s.dom_element () << *i.link_busy_event ();
        }
      }

      {
        if (i.route_add_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "route_add_event",
            e);
          s.dom_element () << *i.route_add_event ();
        }
      }

      {
        if (i.route_delete_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "route_delete_event",
            e);
          s.dom_element () << *i.route_delete_event ();
        }
      }

      {
        if (i.custody_signal_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "custody_signal_event",
            e);
          s.dom_element () << *i.custody_signal_event ();
        }
      }

      {
        if (i.custody_timeout_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "custody_timeout_event",
            e);
          s.dom_element () << *i.custody_timeout_event ();
        }
      }

      {
        if (i.registration_added_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "registration_added_event",
            e);
          s.dom_element () << *i.registration_added_event ();
        }
      }

      {
        if (i.registration_removed_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "registration_removed_event",
            e);
          s.dom_element () << *i.registration_removed_event ();
        }
      }

      {
        if (i.registration_expired_event ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "registration_expired_event",
            e);
          s.dom_element () << *i.registration_expired_event ();
        }
      }

      {
        if (i.open_link_request ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "open_link_request",
            e);
          s.dom_element () << *i.open_link_request ();
        }
      }

      {
        if (i.send_bundle_request ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "send_bundle_request",
            e);
          s.dom_element () << *i.send_bundle_request ();
        }
      }

      {
        if (i.cancel_bundle_request ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "cancel_bundle_request",
            e);
          s.dom_element () << *i.cancel_bundle_request ();
        }
      }

      {
        if (i.inject_bundle_request ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "inject_bundle_request",
            e);
          s.dom_element () << *i.inject_bundle_request ();
        }
      }

      {
        if (i.link_query ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link_query",
            e);
          s.dom_element () << *i.link_query ();
        }
      }

      {
        if (i.link_report ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "link_report",
            e);
          s.dom_element () << *i.link_report ();
        }
      }

      {
        if (i.contact_query ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "contact_query",
            e);
          s.dom_element () << *i.contact_query ();
        }
      }

      {
        if (i.contact_report ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "contact_report",
            e);
          s.dom_element () << *i.contact_report ();
        }
      }

      {
        if (i.route_query ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "route_query",
            e);
          s.dom_element () << *i.route_query ();
        }
      }

      {
        if (i.route_report ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "route_report",
            e);
          s.dom_element () << *i.route_report ();
        }
      }

      {
        if (i.bundle_query ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle_query",
            e);
          s.dom_element () << *i.bundle_query ();
        }
      }

      {
        if (i.bundle_report ())
        {
          ::xsd::cxx::xml::dom::element< char > s (
            "bundle_report",
            e);
          s.dom_element () << *i.bundle_report ();
        }
      }

      if (i.eid ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "eid",
          e);

        a.dom_attribute () << *i.eid ();
      }

      if (i.hello_interval ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "hello_interval",
          e);

        a.dom_attribute () << *i.hello_interval ();
      }

      if (i.alert ())
      {
        ::xsd::cxx::xml::dom::attribute< char > a (
          "alert",
          e);

        a.dom_attribute () << *i.alert ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
#endif
//
// End epilogue.

