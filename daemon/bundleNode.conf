
log /daemon INFO "bundle daemon config running..."

set loopback [test set loopback]
set tidy     [storage set tidy]

set port 5000
set sqldb "dtn"
set dbdir "/tmp/bundledb"
set payloaddir  "/tmp/bundles"
set localhost "localhost"
set localdir  "/tmp/incoming-bundles"
set peer ""

if {$loopback != 0} {
    storage set sqldb "dtn$loopback"
    set dbdir  /tmp/bundledb-$loopback
    set payloaddir /tmp/bundles-$loopback
    set localhost 10.0.0.$loopback
    set localdir  /tmp/incoming-bundles-$loopback
    
    if {$loopback == 1} {
	set peer    10.0.0.2
	set peerdir /tmp/incoming-bundles-2
	
    } elseif {$loopback == 2} {
	set peer    10.0.0.1
	set peerdir /tmp/incoming-bundles-1

    } else {
	error "invalid loopback value $loopback"
    }

    foreach dir [list $dbdir $payloaddir $localdir $peerdir] {
	if {! [file exists $dir]} {
	    file mkdir $dir
	}
    }
}

# clean up
if {$tidy} {
    puts "tidy option set, cleaning payload and local file dirs"
    foreach dir [list $dbdir $payloaddir $localdir] {
	file delete -force [glob -nocomplain $dir/*]
    }
}

# initialize storage
storage set sqldb $sqldb
storage set dbdir $dbdir
#storage init berkeleydb
storage init postgres

# set the payload directory and other params
param set payload_dir $payloaddir

param set tcpcl_ack_blocksz 500
# param set payload_mem_threshold 

# set a local tcp interface
interface bundles://internet/tcp://$localhost:$port/

# and a file one
# interface file://unix/file://$localdir/

#
# set up routing...
#

if {$loopback != 0} {
    # with a tcp route 
    route add bundles://internet/bundles://$peer/* \
	    bundles://internet/tcp://$peer:$port/ ONDEMAND
    
    # and/or a file route 
#     route add bundles://internet/bundles://$peer/* \
#  	    bundles://internet/file://$peerdir/ ONDEMAND
}

# test proc for sending a bundle
proc sendbundle {} {
    global localhost peer port
    set length  1048576
    set length  5000

    set payload "test bundle payload data\n"

    while {$length - [string length $payload] > 32} {
	append payload [format "%4d: 0123456789abcdef\n" [string length $payload]]
    }
    while {$length > [string length $payload]} {
	append payload "."
    }
    
    bundle inject bundles://internet/bundles://$localhost/	\
	    	  bundles://internet/bundles://$peer/demux	\
		  $payload $length
}

# and one for sending a bundle with hex data (doesn't really work
proc sendbundlehex {} {
    global localhost peer port
    bundle inject bundles://internet/bundles://$localhost/	\
	    	  bundles://internet/bundles://$peer/demux	\
		  [binary format i {12345678}]
}

# set up the test smtp daemon
set testsmtpd 0
if {$testsmtpd} {
    package require smtp
    package require smtpd
    package require mime

    proc deliverMIME {token} {
	set sender [lindex [mime::getheader $token From] 0]
	set recipients [lindex [mime::getheader $token To] 0]
	set mail "From $sender [clock format [clock seconds]]"
	append mail "\n" [mime::buildmessage $token]
	puts $mail

	# mail inject $to $body
    }

    proc deliver {sender recipients data} {
	set mail "From $sender  [clock format [clock seconds]]"
	append mail "\n" [join $data "\n"]
	puts "$mail"
    }

    set smtp_port 2500
  
    smtpd::configure -deliverMIME deliverMIME
#    smtpd::configure -deliver deliver
    smtpd::start 0 $smtp_port

    proc send_test_mail {} {
	global smtp_port
	
	set token [mime::initialize -canonical text/plain \
		-string "this is a test"]
	mime::setheader $token To "test@test.com"
	mime::setheader $token Subject "test subject"
	smtp::sendmessage $token \
		-recipients test@test.com -servers localhost -ports $smtp_port
	mime::finalize $token
    }

}

#
# Use the initscript hook to store some code we want run only _after_
# everything else is initialized
#
test set initscript {
    registration logger add bundles://*/*
    if {$loopback == 2} { sendbundle }

    if {$testsmtpd} {
	puts "sending test mail..."
	send_test_mail
    }
}


# # define a bgerror proc to print the error stack
# proc bgerror {err} {
#     global errorInfo
#     puts "tcl error: $err\n$errorInfo"
# }

