
log /daemon INFO "bundle daemon config running..."

set loopback [test set loopback]

#
# initialize storage
#
if {$loopback != 0} {
    storage set sqldb "dtn$loopback"
}
storage init postgres

set port 5000
set localhost "localhost"
set localdir  "/tmp/incoming-bundles"
set peer ""

if {$loopback != 0} {
    set localhost 10.0.0.$loopback
    set localdir  /tmp/incoming-bundles-$loopback
    
    if {$loopback == 1} {
	set peer    10.0.0.2
	set peerdir /tmp/incoming-bundles-2
	
    } elseif {$loopback == 2} {
	set peer    10.0.0.1
	set peerdir /tmp/incoming-bundles-1

    } else {
	error "invalid loopback value $loopback"
    }
}

# set a local tcp interface
interface bundles://internet/tcp://$localhost:$port/

# and a file one
interface file://unix/file://$localdir/

#
# set up routing...
#

if {$loopback != 0} {
    # with a tcp route 
    route add bundles://internet/bundles://$peer/* \
	    bundles://internet/tcp://$peer:$port/ ONDEMAND
    
    # and/or a file route 
    route add bundles://internet/bundles://$peer/* \
	    bundles://internet/file://$peerdir/ ONDEMAND
}

# test proc for sending a bundle
proc sendbundle {} {
    global localhost peer port
    bundle inject bundles://internet/bundles://$localhost/	\
	    	  bundles://internet/bundles://$peer/demux	\
		  "test bundle payload data"
}

# and one for sending a bundle with hex data (doesn't really work
proc sendbundlehex {} {
    global localhost peer port
    bundle inject bundles://internet/bundles://$localhost/	\
	    	  bundles://internet/bundles://$peer/demux	\
		  [binary format i {12345678}]
}

#
# Use the initscript hook to store some code we want run only _after_
# everything else is initialized
#
test set initscript {
    registration logger add bundles://*/*
    if {$loopback == 2} { sendbundlehex }
}

