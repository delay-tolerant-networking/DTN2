/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "dtn_types.h"
/*
 * IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
 * By downloading, copying, installing or using the software you agree
 * to this license. If you do not agree to this license, do not
 * download, install, copy or use the software.
 * 
 * Intel Open Source License 
 * 
 * Copyright (c) 2004 Intel Corporation. All rights reserved. 
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 *   Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 
 *   Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * 
 *   Neither the name of the Intel Corporation nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from * this software without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * INTEL OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**********************************
 * This file defines the types used in the DTN client API. The structures are
 * autogenerated using rpcgen, as are the marshalling and unmarshalling
 * XDR routines.
 */

#include <limits.h>
#ifndef ARG_MAX
#define ARG_MAX _POSIX_ARG_MAX
#endif

#include <rpc/rpc.h>


/**********************************
 * Constants.
 * (Note that we use #defines to get the comments as well)
 */
#define DTN_MAX_TUPLE 1024 /* max tuple size (bytes) */
#define DTN_MAX_PATH_LEN PATH_MAX /* max path length */
#define DTN_MAX_EXEC_LEN ARG_MAX /* length of string passed to exec() */
#define DTN_MAX_AUTHDATA 1024 /* length of auth/security data*/
#define DTN_MAX_REGION_LEN 64 /* 64 chars "should" be long enough */
#define DTN_MAX_BUNDLE_MEM 50000 /* biggest in-memory bundle is ~50K*/
#define DTN_MAX_INFREQ_TUPLES 32 /* max number of responses to a dtn_getinfo call */
// XXX/demmer should move error codes to dtn_api.h



/**********************************
 * Error codes
 *
 */


bool_t
xdr_DTN_STATUS (XDR *xdrs, DTN_STATUS *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

#define DTN_SUCCESS (0) /* ok */
#define DTN_BASE 128
#define DTN_INVAL (DTN_BASE+1) /* invalid argument */
#define DTN_XDRERR (DTN_BASE+2) /* error in xdr routines */
#define DTN_COMMERR (DTN_BASE+3) /* error in ipc communication */
#define DTN_SERVERR (DTN_BASE+4) /* server error (eg failed syscall) */
#define DTN_TOOBIG (DTN_BASE+5) /* payload too large */

/**
 * Specification of a dtn tuple as parsed into a region string and
 * admin identifier. As per the bundle specification, the admin
 * portion is either a URI or a one or two byte binary value.
 *
 */

bool_t
xdr_dtn_tuple_t (XDR *xdrs, dtn_tuple_t *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_vector (xdrs, (char *)objp->region, DTN_MAX_REGION_LEN,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->admin.admin_val, (u_int *) &objp->admin.admin_len, DTN_MAX_TUPLE))
		 return FALSE;
	return TRUE;
}

/**
 * Information requests
 *     DTN_INFOREQ_INTERFACES - list of local interfaces
 *     DTN_INFOREQ_CONTACTS   - list of available contacts
 *     DTN_INFOREQ_ROUTES     - list of currently reachable peers
 */

bool_t
xdr_dtn_info_request_t (XDR *xdrs, dtn_info_request_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dtn_inforeq_interfaces_t (XDR *xdrs, dtn_inforeq_interfaces_t *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_dtn_tuple_t (xdrs, &objp->local_tuple))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->other_ifs, DTN_MAX_INFREQ_TUPLES,
		sizeof (dtn_tuple_t), (xdrproc_t) xdr_dtn_tuple_t))
		 return FALSE;
	return TRUE;
}

/**
 * Information request response structure that is a union, based
 * on the type of the request, of the returned values.
 */

bool_t
xdr_dtn_info_response_t (XDR *xdrs, dtn_info_response_t *objp)
{
	register int32_t *buf;

	 if (!xdr_dtn_info_request_t (xdrs, &objp->request))
		 return FALSE;
	switch (objp->request) {
	case DTN_INFOREQ_INTERFACES:
		 if (!xdr_dtn_inforeq_interfaces_t (xdrs, &objp->dtn_info_response_t_u.interfaces))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

/**
 * A registration cookie.
 */

bool_t
xdr_dtn_reg_id_t (XDR *xdrs, dtn_reg_id_t *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

/**
 * DTN timeouts are specified in seconds.
 */

bool_t
xdr_dtn_timeval_t (XDR *xdrs, dtn_timeval_t *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

/**
 * Value for an unspecified registration cookie (i.e. indication that
 * the daemon should allocate a new unique id).
 */

/**
 * Registration actions
 *     DTN_REG_ABORT  - drop bundle if unreachable
 *     DTN_REG_DEFER  - spool bundle for later retrieval
 *     DTN_REG_EXEC   - exec program on bundle arrival
 *     DTN_REG_CANCEL - cancel a prior registration
 */

bool_t
xdr_dtn_reg_action_t (XDR *xdrs, dtn_reg_action_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

/**
 * Registration state.
 */

bool_t
xdr_dtn_reg_info_t (XDR *xdrs, dtn_reg_info_t *objp)
{
	register int32_t *buf;

	 if (!xdr_dtn_tuple_t (xdrs, &objp->endpoint))
		 return FALSE;
	 if (!xdr_dtn_reg_action_t (xdrs, &objp->action))
		 return FALSE;
	 if (!xdr_dtn_reg_id_t (xdrs, &objp->regid))
		 return FALSE;
	 if (!xdr_dtn_timeval_t (xdrs, &objp->timeout))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->args.args_val, (u_int *) &objp->args.args_len, DTN_MAX_EXEC_LEN))
		 return FALSE;
	return TRUE;
}

/**
 * Bundle priority specifier.
 *     COS_BULK      - lowest priority
 *     COS_NORMAL    - regular priority
 *     COS_EXPEDITED - important
 *     COS_RESERVED  - TBD
 */

bool_t
xdr_dtn_bundle_priority_t (XDR *xdrs, dtn_bundle_priority_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

/**
 * Bundle delivery option flags. Note that multiple options
 * may be selected for a given bundle.
 *     
 *     DOPTS_NONE           - no custody, etc
 *     DOPTS_CUSTODY        - custody xfer
 *     DOPTS_RETURN_RCPT    - end to end return receipt
 *     DOPTS_RECV_RCPT      - per hop arrival receipt
 *     DOPTS_FWD_RCPT       - per hop departure receipt
 *     DOPTS_CUST_RCPT      - per custodian receipt
 *     DOPTS_OVERWRITE      - request queue overwrite option
 */

bool_t
xdr_dtn_bundle_delivery_opts_t (XDR *xdrs, dtn_bundle_delivery_opts_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

/**
 * Bundle metadata.
 */

bool_t
xdr_dtn_bundle_spec_t (XDR *xdrs, dtn_bundle_spec_t *objp)
{
	register int32_t *buf;

	 if (!xdr_dtn_tuple_t (xdrs, &objp->source))
		 return FALSE;
	 if (!xdr_dtn_tuple_t (xdrs, &objp->dest))
		 return FALSE;
	 if (!xdr_dtn_tuple_t (xdrs, &objp->replyto))
		 return FALSE;
	 if (!xdr_dtn_bundle_priority_t (xdrs, &objp->priority))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->dopts))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->expiration))
		 return FALSE;
	return TRUE;
}

/**
 * The payload of a bundle can be sent or received either in a file,
 * in which case the payload structure contains the filename, or in
 * memory where the struct has the actual data.
 *
 * Note that there is a limit (DTN_PAYLOAD_MEM) on the maximum size
 * bundle payload that can be sent or received in memory.
 */

bool_t
xdr_dtn_bundle_payload_location_t (XDR *xdrs, dtn_bundle_payload_location_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dtn_bundle_payload_t (XDR *xdrs, dtn_bundle_payload_t *objp)
{
	register int32_t *buf;

	 if (!xdr_dtn_bundle_payload_location_t (xdrs, &objp->location))
		 return FALSE;
	switch (objp->location) {
	case DTN_PAYLOAD_FILE:
		 if (!xdr_bytes (xdrs, (char **)&objp->dtn_bundle_payload_t_u.filename.filename_val, (u_int *) &objp->dtn_bundle_payload_t_u.filename.filename_len, DTN_MAX_PATH_LEN))
			 return FALSE;
		break;
	case DTN_PAYLOAD_MEM:
		 if (!xdr_bytes (xdrs, (char **)&objp->dtn_bundle_payload_t_u.buf.buf_val, (u_int *) &objp->dtn_bundle_payload_t_u.buf.buf_len, DTN_MAX_BUNDLE_MEM))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}

/**
 * Bundle authentication data. TBD
 */

bool_t
xdr_dtn_bundle_auth_t (XDR *xdrs, dtn_bundle_auth_t *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->blob.blob_val, (u_int *) &objp->blob.blob_len, DTN_MAX_AUTHDATA))
		 return FALSE;
	return TRUE;
}
