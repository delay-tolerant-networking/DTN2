<html>
<head>
<title> DTN2 Manual: Starting dtnd and sending a ping </title>
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>
<h1>Starting dtnd and sending a ping
</h1>

<p>
In this tutorial, you'll learn how to configure and start an instance
of dtnd, then make it answer a ping.

<h2> Configuration </h2>

<p>
In this section, we'll prepare an appropriate <tt>dtn.conf</tt>
file for our instance of dtnd.

<h3> Directories </h3>

<p>
First, you need to choose a directory that will hold the files dtnd
needs. For the purposes of this tutorial, we'll assume your username
is <tt>fred</tt> and that you want dtnd to write into
<tt>/home/fred/dtn</tt>.

<p> Make the <tt>/home/fred/dtn</tt> directory, then copy the example
<tt>dtn.conf</tt> file from <tt>DTN2/daemon/dtn.conf</tt> to
<tt>/home/fred/dtn/dtn.conf</tt>. Edit the <tt>dtn.conf</tt> file. For
this tutorial, we'll use the simplest database to configure,
BerkeleyDB. Leave the <i>storage set type berkeleydb</i> line alone.
In other tutorials, you'll see how to use a SQL database. Set the
<i>payloaddir</i> to <tt>/home/fred/dtn/bundles</tt> and set the
<i>dbdir</i> to <tt>/home/fred/dtn/db</tt>.

<p> The <i>dbdir</i> directory is where persistent objects that DTN2 uses to
manage its internal state live. This database will remain fairly small. It
needs to be preserved between invocations of the DTN2 daemon, because
the data in it lets DTN2 know the status of registrations with
clients, and bundles which are in flight in the network. One of the
"disruptions" that a DTN is tolerant of is the failure of a node.
Using the data in the database, a new DTN2 daemon can carry on the
work the previous one was doing.

<p> The <i>payload</i> directory is where bundles which are in-flight
live. In general, the bundles in this directory are ones which this
DTN2 instance has custody of. That means that if they disappear out of
this directory, they will be lost forever, since there are no other
authoratative copies of the bundle in the network. DTN2 and the DTN
protocols are designed to maintain the files in this directory without
leaving old ones lying around. If you see an old file there, it's
likely due to a bug. Please help us get to the bottom of what's causing it.
Unlike packets, which are typically quite small (from 50 to 64,000
bytes), a single bundle can be very large (over 2 gigabytes).
On a server dedicated to
running DTN2, your payload directory should have access to the largest
partition on your server. As an analogy, on a mail server the mail
spool is usually on /var, and has access to the majority of the extra
disk space on a machine. The same should be true for the payload
directory.

<h3>The Local Tuple</h3>

<p> You don't need to make any changes in the <i>local_eid</i>, but
scroll down and take a look at it anyway. In the defualt
configuration, it looks like this: <i>route local_eid
"bundles://internet/host://[info hostname]"</i>. Note the square
brackets. To understand what's happening here, you need to know that
this configuration file is not simply a file of settings for dtnd, but
an actual <a href="http://www.tcl.tk">TCL</a> script. It is interpreted by
the TCL interpreter that is built in to dtnd. In TCL, square brackets
mean "interpret this first, and replace the brackets with the result".
So before dtnd sees a <i>route local_eid ...</i> command, TCL
processes the <i>info hostname</i> command. As you might be able to
guess by now, the entire line results in the <i>local_eid</i> being
set to a custom string based on your hostname.

<p> This is the only place in this particular configuration file where
we will use TCL features like the square brackets. However, you should
remember that all the power of TCL is available to you as you write
your own configuration files, should you desire it. For an example of
this, see <a href="configuration.html#rotate">the example showing how
to rotate logs</a> from within dtnd.

<p> So the local eid is set, but what is it? From the
<a href="arch.html">Architecture</a> section, you should recall
that nodes in the DTN are identified by eids. The local eid
is simply the way our DTN node will refer to itself. Without this
setting, it would not recognize bundles intended for it, and might
just pass them on ad infinitum! People who have configured Internet
email systems like Postfix or Sendmail might recognize this setting,
as mail routers need to know their own name for the same reason.

<p>
DTN nodes within the administrative region named "internet" are
expected to use hostnames in the local part of the eid that
resolve to an IP address they have configured. However, that still
leaves you considerable latitude in how to choose your local eid.
For instance, if you had a machine named something cumbersome like
<tt>az10001.prod.sfo.company.com</tt>, but there was a nice simple
CNAME of <tt>dtn.company.com</tt> pointing to it, you could set the
hostname in the local eid to the simpler <tt>dtn.company.com</tt>.
That might be a very good idea, in fact. Afterall, the computer might
get renamed, but if it is still playing the same part in the DTN
there's no reason to force other members of the DTN to use a new name.
Also, consider the case where you need to move the DTN node to another
machine due to hardware failure, but there are already bundles in
flight with a destination eid using the original name. Using a CNAME
can help avoid losing those bundles.

<p>
At this time, one dtnd can have only one local eid name. This
limitation might disappear in future versions if it proves to be a
problem.

<h3> Interfaces </h3>

<p>
Take a look at the <i>interface add</i> command a few lines
down. You will not likely need to change this, but you can see
that this is where you control which IP address and port dtnd will
be listening on. Usually DTN nodes that are communicating via
TCP listen on port 5000, but that is not an IETF port assignment
and nothing about the protocol requires operation on that port.
If you have another application on the same server listening on
port 5000, you'll need to choose a different port for your dtnd
to use.

<p> In some security contexts, and with some virtual interface
configurations, it is desireable to have dtnd listen only on a certain
interface, for instance "listen to internal connections only".
You can do this by changing the 0.0.0.0 address (meaning "listen on
all interfaces") to an address that is on only one of the host's
interface. For this tutorial, we will allow dtnd to listen on all
interfaces, so leave the address as 0.0.0.0.

<p> Note that we are adding an interface of type TCP. There are other
ways that DTN nodes can communicate, including across a filesystem
(where some external activity, like a messenger with a USB keychain
drive, is responsible for moving the files).  When you start using
alternative <b>convergence layers</b> you'll have other <i>interface
add</i> lines in your configuration file.

<p> The <i>interface add</i> command can take convergence layer
specific arguments to customize the default behavior of links
that operate across that interface. For the purposes of this tutorial,
we will be using the defaults. For more information on these arguments
see the reference pages on the <a href="configuration.html#link">link
command</a>.

<h3> Links and Routes </h3>

<p>
Because in this tutorial, we are setting up a standalone dtnd,
we will not need any <tt>link</tt> or <tt>route</tt> statements.
You'll end up with a Disruption Tolerant Network made up of
only one daemon. Not much to brag about, but out of simple
beginnings come great things!

<h2> Initializing the Database </h2>

<p>
Before dtnd can use the database to keep track of runtime state,
it needs to initialize it. This is a simple matter of starting
the daemon once with the <tt>--init-db</tt> argument. You'll
also want to give it the location of the configuration file, so
that dtnd can find the correct database directory. Put that together
and you have:

<blockquote><pre>$ <font color=blue>daemon/dtnd.conf -c /home/fred/dtn/dtn.conf --init-db </font>
[1108493233.189564 /dtnd info] Bundle Daemon Initializing...
[1108493233.209564 /dtnd info] random seed is 209564
[1108493233.224564 /dtnd info] parsing configuration file /home/fred/dtn/dtn.conf ...
[1108493233.231564 /dtnd info] dtnd parsing configuration...
[1108493233.234564 /interface info] adding interface tcp host://0.0.0.0:5000/
[1108493233.276564 /dtnd info] dtnd configuration parsing complete
[1108493233.609564 /storage/berkeleydb info] database file '/home/fred/dtn/db/DTN.db' validated
[1108493233.615564 /storage/berkeleydb info] initializing globals database table ...
[1108493233.662564 /storage/berkeleydb info] initializing bundles database table ...
[1108493233.733564 /storage/berkeleydb info] initializing registration database table...
[1108493233.948564 /storage/berkeleydb info] closing database file...
[1108493234.037564 /dtnd info] database initialization complete.
</pre>
</blockquote>

<h2> Running the Daemon </h2>

<p>
For now, you start dtnd from the commandline, like any other
Unix command. By default, the TCL interpreter takes input from
standard in, so you will need to leave it running in the foreground. While
you are learning the ins and outs of dtnd, it is best to run it
this way, so that you can interact with it. Use the <tt>-c</tt>
argument to tell it where to find the configuration file.
For information on other arguments you can give dtnd, see
the <a href="man/dtnd.html">dtnd man page</a>.

<p>
Once you start dtnd with a command like <tt>DTN2/daemon/dtnd -c
/home/fred/dtn/dtn.conf</tt>, it will put out some messages, then
give you the <tt>dtn%</tt> prompt. This means the server is up
and running, awaiting commands from you. Things you type at the
prompt are interpreted by the same TCL interpreter that just parsed
the configuration file. In a way, you can consider the configuration
file a list of commands that will be issued for you
each time you start the server.

<p>
Here's an example of starting up the server:

<blockquote><pre>
[1108500270.498718 /dtnd info] Bundle Daemon Initializing...
[1108500270.498718 /dtnd info] random seed is 498718
[1108500270.546718 /dtnd info] parsing configuration file /home/fred/dtn/dtn.conf...
[1108500270.553718 /dtnd info] dtnd parsing configuration...
[1108500270.557718 /interface info] adding interface tcp host://0.0.0.0:5000/
[1108500270.577718 /dtnd info] dtnd configuration parsing complete
[1108500270.985718 /storage/berkeleydb info] database file '/home/fred/dtn/db/DTN.db' validated
[1108500271.136718 /tcl info] can't load tclreadline: can't find package tclreadline
[1108500271.142718 /tcl info] fall back to simple command loop
</pre></blockquote>

<p>
Note that this installation of TCL is missing the optional
<i>tclreadline</i> package. As a result we get a warning from dtnd
at startup, but it will still work correctly. The user interface
is just slightly more difficult to use because you cannot go back
through your command history and edit previous commands.

<p>
Use the online help system to learn what you can do from here. Type
<b>help</b>. For help on a specific command, type <b>help
<i>command</i></b>. For now, though, you don't need to use any
commands. Just let dtnd run in its own window. When we start talking
to dtnd with an application you'll see log messages in the window
where dtnd is running.

<h2> Pinging the daemon </h2>

<p>
A Disruption Tolerant Network is made up of a number of
servers whose job is to move bundles through the system.
But where do the bundles come from? They come from applications.
In the future, you can expect to see applications to move
scientific data, web pages, e-mail, and other data that
needs to traverse a network region prone to disruption.
For now though, the best way to see your new DTN (consisting
of just your one server) operate is to send a ping bundle into
to it, and see what comes back out!

<p>
To ping your server, run the <tt>dtnping</tt> command. It lives
in the <tt>DTN2/apps/dtnping</tt> directory. You'll need to give it
one argument, which is the eid address of the endpoint that you
want to ping. Since there is only one server in your DTN, the
choice should be simple. You need to use the local eid
that you set in the configuration file. If you'd like to
check what dtnd thinks it's local eid name is, use the
<tt>route dump</tt> command in the window where dtnd is running.

<p>
Alternatively, <tt>dtnping</tt> contains a convenience shortcut
whereby the string 'localhost' is interpreted as the local eid
of the daemon.

<p>
Here's an example of how to ping a server who's local eid
is <i>bundles://internet/host://dtn-a</i>:

<blockquote><pre>$ <font color=blue>DTN2/apps/dtnping/dtnping bundles://internet/host://dtn-a</font>
local_eid [internet host://dtn-a/ping]
dtn_register succeeded, regid 0xa
PING [internet host://dtn-a]...
69 bytes from [internet host://dtn-a]: time=202.00 ms
69 bytes from [internet host://dtn-a]: time=208.00 ms
<font color=blue>Ctrl-C</font></pre></blockquote>

<h2> What next? </h2>

<p>
You've set up a standalone dtnd and pinged it. From here, you
can explore two directions. In the <a href="tutorial-2.html">
DTN2 applications</a> tutorial, you can learn how to use the other
applications that come with DTN2 to interact with your new little
DTN. In the <a href="tutorial-3.html">building a bigger DTN</a>
tutorial, you can see how to use links to make several nodes work
together as part of a bigger DTN.

</body>
</html>

