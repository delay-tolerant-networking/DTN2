July 2 DTN Reference Implementation Discussion 
10.00a - 12.30p

DCE/NDR Research Overview - Ting
   - similar to Sun RPC - client server communication model
     - binding on both client side and server side (registration of 
        interfaces, routines, object)
     - name service for binding registrations...
     - NDR is embedded in DCE, like XDR is embedded in RPC
        - no separate implementation from DCE
        - similar to XDR (data serialization and basic objects, and list 
          structures)
     - Conclusion: we don't want to use DCE because it is too heavyweight
     - But: Kevin wants NDR for persistent storage
         except 1: we were considering for application/bundle daemon comm
         except 2: we planned for out own abstract persistence mechanism
         (we == Mike, Melissa, Sushant)

Data Sharing between App and Bundle Services
  - Shared Memory? -- problematic
     - not worry about data structures (except for allocation)
     - but less portable
     - still need to allocate from other places
  - XDR/NDR
     - current state (like it is now)
     - unhappy that it is sun RPC, which is a little opaque
     - question: is DCE the same way?
*     - TING will look more into how NDR does serialization, etc

Ideas Directory
* - Kevin, Ting, Melissa will do

*	Kevin contact somebody at UCLA regarding the /dev used
		in EmStar
		- check in timer stuff from NS2
*	Mike will e-mail out Capriccio

Storage discussion:
 - Mike, Melissa and Sushant have 
 - Based on Marshalling 
    - serializer action that does the "right" type of serialization
      (e.g. SQL, XML, file/blob, etc)

 - Object specific Storage Interfaces:
   - Store: BundleStore (: SQLBundleStore, : FileBundleStore, etc)
   - Store: BundleMetaDataStore
   - Store: RegistrationStore
   - Store: RoutingStore

- Multiple Inheritance for Generic Functions:
   - eg. SQLStore - SQLBundleStore inherits from both BundleStore and SQLStore
   - diamond or not (does SQLStore inherit from Store?)
   
*    - need class diagrams - Mike will check-in and generate :)
        - will email explanation out
*    - Sushant volunteers to do the  postgres implementation

Discussion of data movement:
  - Conceptual Pipe primitive for moving data
    - each incoming bundle is a pipe
    - given a pipe, construct next-pipes
       - file write handle, or pipe to output CL for cut through
       - or combine - both writes simultaneous
    - Fragmentation - a pipe is actually a sequence of pipes
    - like "click" (push and pull model queue)
    
  - Do we create multiple TCP connections if we have multiple bundles that
    need to go out? (connection pools)
  
  - Discussion of Contact Lists:
    - want to take queue management out of CL?
    - currently one end push and one end pull...
    - Bob: problem is that for short bundles the CL is constantly 
      handshaking with bundle daemon, which requires context switch
    - Keith: trading simplicity against efficiency of allowing the CL to 
      pick up the next bundle as soon as it's done sending the current one.
    - But performance is not primary goal.

  - On Necessity for cut-through routing
    - don't need this in reference implementation, esp as proof of concept
    - sets of requirements that are at odds with each other
    - on pipes: may be good even aside from cut-through routing

  - On Requirements for Reference Implementation
    - keep it simple, pedagogical
    - mike: but it is research platform
    - needs to be extendable

* - Further Investigation and Description required:
    (Mike, Melissa)

Framing Protocol
  - convergence layer is blind to bundle header formats, but knows
    enough to figure out length of bundle (inc headers)
  - make restriction - CL doesn't write to disk, which implies that
    no bundle is so large that it can't fit into memory, for transferrence
    to bundle daemon
    -> limiting size of bundles to be transferred to the memory capabilities
       of the dtn node
    -> how hard will it be to relax this assumption for future 
       implementations
    -> pipe model will potentially deal with this problem.
       - will be harder to get right
       - pipe can parse header (be aware of bundle semantics)
          - smart pipe filter
          - pipe->consume(bundle chunk)
       - can be pipe's problem to figure out if they have the whole bundles
  - for tcp, we need to know where the next bundle is starting
  - cl will only write one bundle per pipe, even if >1 bundle in conx
  - responsibility of framing protocol is to determine lengths...

  - Keith: figure out how to send bundles bidirectionally over single
    tcp connection (for firewalls)
    - may not need for ref. impl, but ... nice to have
    - one side initiates two connections, but for one, can negotiate to be
      in the opposite direction...

ARs
* playground accounts for sonesh and nabeel
*  - Kevin send out pdf forms, and tell sonesh to talk to Mike

Goals
* limping: get as much of the components working
* Kevin: close on what objects are acceptable
