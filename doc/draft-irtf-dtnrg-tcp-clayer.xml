<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc ipr="full3667" docName="draft-irtf-dtnrg-bundle-tcpcl.txt">
 
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<?rfc toc="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc iprnotified="no"?>
<?rfc compact="yes"?>

<front>
   <title abbrev="TCP Bundling Convergence Layer">
      Protocol for the TCP Bundling Convergence Layer
   </title>
  
   <author initials="M.J." surname="Demmer" fullname="Michael J. Demmer">
      <organization abbrev="UC Berkeley / Intel Research">
         University of California, Berkeley
         Intel Research Berkeley
      </organization>
   </author>

   <date month="March" year="2005"/>

   <abstract><t> This internet draft describes a protocol for
      implementing a Convergence Layer as described in the <xref
      target="refs.dtnarch">Architecture for Delay Tolerant Networking
      </xref> (DTN), using the TCP transport protocol.
   </t></abstract> </front>

<middle>

<section title="Introduction">
<t>
   This document describes the protocol used when implementing a TCP
   Convergence Layer, as described in the <xref target="refs.dtnarch">
   Architecture for Delay Tolerant Networking </xref> (DTN).
</t>

<t>
   Note that this document describes version 2 of the protocol.
   Version 1 was never specified in an Internet Draft or other public
   document, although it was implemented in the <xref
   target="refs.dtnimpl">DTN reference implementation</xref> versions
   2.0.1 and 2.0.2.
</t>

<t>
   Communication between two Bundle daemons using the TCP Convergence
   Layer is initiated by one daemon opening a TCP session via the
   normal TCP connection establishment mechanism (i.e. the connect()
   call in the BSD sockets API). This operation establishes a new TCP
   session between the two nodes, herein termed a "connection".
</t>

<t>
   In this protocol, one side of the connection is termed the "sender"
   and one side is the "receiver". All bundle transmissions occur in
   only one direction, from sender to receiver. However, other
   messages are transmitted from receiver to sender, as described
   below. In addition, as will be described in <xref
   target="sec:receiver_connect"/>, the party that initiates the TCP
   connection is not necessarily the sender.
</t>

<t>
   XXX something about byte order
</t>

</section>

<section title="Contact Header" anchor="sec:contact">

<t>
   When a connection is established between a sender and receiver,
   both parties MUST transmit a Contact Header upon establishing a
   connection.
</t>
   
<figure anchor="fig:contact_header"
   title="Contact Header Format">
   <preamble>
      The format for the Contact Header is as follows:
   </preamble>
   
   <artwork>
                     1                   2                   3  
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|                          magic='dtn!'                         |
+---------------+---------------+---------------+---------------+
|     version   |     flags     |        partial_ack_len        |
+---------------+---------------+---------------+---------------+
|        idle_close_time        |       keepalive_interval      |
+---------------+---------------+---------------+---------------+
   </artwork>
</figure>

<t>
   The fields of the contact header are:
</t>

<t>
<list style="hanging" hangIndent="5">
   <t hangText="magic:"> A four byte field that always contains the
      byte sequence 0x64 0x76 0x6e 0x21, i.e. the ASCII string "dtn!".
   </t>
   <t></t>
   
   <t hangText="version:"> A one byte field value containing the
	 current version of the protocol.
   </t>
   <t></t>

   <t hangText="flags:"> A one byte field containing optional
      connection flags. The first five bits are unused and must be set
      to zero. The last three bits are interpreted as follows.
   </t>
</list>
</t>

<texttable anchor="contact:flags"
           title="Contact Header Flags">
   <ttcol align="center">Value</ttcol>
   <ttcol align="center">Meaning</ttcol>

   <c>001</c>
   <c>Request acknowledgement of bundle reception.</c>

   <c>010</c>
   <c>Request reactive fragmentation.</c>

   <c>100</c>
   <c>Connection initiator is the receiver.</c>

</texttable>

<t>
<list style="hanging" hangIndent="5">

   <t hangText="partial_ack_len:"> A two byte field containing the
      length in bytes for which partial reception acknowledgements are
      requested (see <xref target="sec:partial"/>).
   </t>
   <t></t>
   
   <t hangText="idle_close_time:"> A two byte field containing the
      number of seconds that a connection should be maintained when no
      data (bundles or acknowledgements) are being exchanged (see
      <xref target="sec:idle"/>).
   </t>
   <t></t>

   <t hangText="keepalive_interval:"> A two byte field containing the
      number of seconds between exchanges of keepalive messages on the
      connection (see <xref target="sec:keepalive"/>).
   </t>
</list>
</t>
</section>

<section title="Magic number and version validation">
<t>
   Upon receipt of the contact header from the other side, both the
   sender and receiver follow the following semantics for validating the 
   the value of each connection flag and parameter.
</t>

<t>
   If either side does not send the correct magic string, the
   connection MUST be terminated. The intent of the magic string is to
   provide some more apparent protection against an inadvertent
   connection to a TCP convergence layer. To prevent a flood of
   repeated connections, either side MAY choose to hold an invalid
   connection open for some time before closing it.
</t>

<t>
   If one party receives a version number that is greater than that
   node's current version of the protocol, the receiving party SHOULD
   interpret all received fields as if the sending party was
   conforming to the node's current version. For the party that
   receives a version number that is smaller than the node's current
   version, the node MAY conform to the older version of the protocol
   or the node MAY terminate the connection.
</t>

</section>

<section title="Message Type Codes" anchor="sec:types">

<t>
   After the initial exchange of a contact header, all messages
   transmitted over the connection are preceded by a one byte message
   type code.
</t>

<texttable anchor="types:codes"
           title="TCPCL Header Types">

   <preamble>
      The types and values for the message type code are as follows.
   </preamble>
   <ttcol align="center" width="18%">Header</ttcol>
   <ttcol align="center" width="6%">Type</ttcol>
   <ttcol align="left" width="76%">Comment</ttcol>
   
   <c>BUNDLE_DATA</c>
   <c>0x01</c>
   <c>Precedes the transmission of a Bundle Data Header, which itself
      precedes the transmission of a Bundle.
      <t></t>
   </c>

   <c>BUNDLE_ACK</c>
   <c>0x02</c>
   <c>Precedes the transmission of a Bundle Acknowledgement Header.</c>

   <c>KEEPALIVE</c>
   <c>0x03</c>
   <c>Described in <xref target="sec:keepalive"/>.</c>
   
   <c>SHUTDOWN</c>
   <c>0x04</c>
   <c>Indicates that the transmitting side of the connection wishes to
      cleanly terminate the connection.
   </c>
</texttable>
</section>

<section title="Bundle Data" anchor="sec:data">
   
<t>
   The sender side transmits a bundle to the receiver side by first
   transmitting a BUNDLE_DATA message code, and then transmitting a
   Bundle Data Header.
</t>

<figure anchor="fig:data_header"
        title="Bundle Data Header Format">

   <preamble>
      The format for the Bundle Data Header and the preceding type is
      as follows.
   </preamble>

   <artwork>
                     1                   2                   3  
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+
| BUNDLE_DATA   |
+---------------+---------------+---------------+---------------+
|                           bundle_id                           |
+---------------+---------------+---------------+---------------+
|                         bundle_length                         |
+---------------+---------------+---------------+---------------+
|         header_length         |          __unused__           |
+---------------+---------------+---------------+---------------+
   </artwork>
</figure>

<t>
   The fields of the bundle data header are:
</t>

<t>
<list style="hanging" hangIndent="5">
   <t hangText="bundle_id:"> A four byte field that contains an
      identifier for the bundle at the sender. The format and
      specification for this field is implementation specific.
   </t>
   <t></t>

   <t hangText="bundle_length:"> A four byte field the contains the
      total length of the bundle transmission that immediately
      follows.
   </t>
   <t></t>

   <t hangText="header_length:"> A two byte field the contains the
      total length of the bundle transmission that follows the bundle
      data header.
   </t>
   <t></t>

   <t hangText="__unused__:"> A two byte field that is ignored.</t>
</list>
</t>

<t>
   Immediately following the Bundle Data Header is the transmission of
   a bundle, as specified in XXX cite bundle protocol.
</t>

</section>

<section title="Bundle Acknowledgements" anchor="sec:acks">
   
<t>
   When sending acknowledgements of receipt of data, the receiver side
   of the connection first transmits a BUNDLE_ACK message type code
   and then transmits a Bundle Acknowledgement Header.
</t>

<figure anchor="fig:ack_header"
        title="Bundle Acknowledgement Header Format">

   <preamble>
      The format for the Bundle Acknowledgement Header and the
      preceding type code is as follows.
   </preamble>

   <artwork>
                     1                   2                   3  
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+
|  BUNDLE_ACK   |    
+---------------+---------------+---------------+---------------+
|                           bundle_id                           |
+---------------+---------------+---------------+---------------+
|                          acked_length                         |
+---------------+---------------+---------------+---------------+
   </artwork>
</figure>

<t>
   The fields of the bundle acknowledgement header are:
</t>

<t>
<list style="hanging" hangIndent="5">
   <t hangText="bundle_id:"> A four byte field that contains the
      identifier for the bundle at the sender that was transmitted in
      the bundle data header.
   </t>
   <t></t>

   <t hangText="acked_length:"> A four byte field the contains the
      total length (in bytes) of the amount of data that has been
      successfully received and is being acknowledged.
   </t>
</list>
</t>

<t>
   If, during the exchange of contact headers, BOTH the sender and
   receiver set the bundle_ack_enabled flag (see <xref
   target="sec:contact"/>), then the receiver MUST transmit a bundle
   acknowledgement header when it successfully receives the entire
   bundle.
</t>

</section>

<section title="Partial Bundle Acknowledgements" anchor="sec:partial">
<t>
   The protocol also includes a provision for bundle acknowledgements
   to be transmitted during the course of receiving a bundle. The
   motivation behind this feature is to enable the bundle daemon to
   communicate state knowledge to enable "reactive fragmentation", as
   described in <xref target="sec:reactive_fragmentation"/>.
</t>

<t>
   As described in <xref target="sec:contact"/>, one of the parameters
   in the contact header is the partial_ack_len. The sender populates
   this field with a requested length (in bytes), and the receiver
   populates the field with an offered length (in bytes). The two
   parties agree that the negotiated value is the MAXIMUM of the two
   lengths. However, if either side sets the length to be zero, then
   the feature is disabled and no partial acknowledgements are
   transmitted.
</t>

<t>
   If the two parties agree to a non-zero value of the partial_ack_len
   parameter, then the receiver SHOULD transmit a bundle
   acknowledgement (see <xref target="sec:acks"/>) whenever it
   receives at least partial_ack_len additional bytes of the bundle
   payload since the last acknowledgement transmission (or the start
   of the bundle if no acknowledgements have been sent).
</t>
</section>

<section title="Keepalive Messages" anchor="sec:keepalive">
<t>
   The protocol includes a provision for transmission of keepalive
   messages over the TCP connection to determine if the connection has
   been disrupted.
</t>

<t>
   As described in <xref target="sec:contact"/>, one of the parameters
   in the contact header is the keepalive_interval. Both sides
   populate this field with their requested intervals (in seconds)
   between keepalive messages. The two parties SHOULD set the
   negotiated interval to the MAXIMUM value of the two requests. If
   either side sets the interval to zero, then this feature is
   disabled and no keepalive messages should be sent.
</t>

<t>
   The format of a keepalive message is a one byte message type code
   of KEEPALIVE (as described in <xref target="types:codes"/>, with no
   additional data. Both sides SHOULD send a keepalive message
   whenever the negotiated interval has elapsed without transmission
   of any message (keepalive or other).
</t>

<t>
   If no message (keepalive or other) has been received for at least
   twice the keepalive interval, then either party MAY terminate the
   session by transmitting a one byte message type code of SHUTDOWN
   (as described in <xref target="types:codes"/>) and closing the TCP
   connection.
</t>
</section>

<section title="Idle Connection Shutdown" anchor="sec:idle">
<t>
   The protocol includes a provision for clean shutdown of idle TCP
   connections.
</t>

<t>
   As described in <xref target="sec:contact"/>, one of the parameters
   in the contact header is the idle_close_time. Both sides populate
   this field with the requested duration (in seconds) to maintain an
   open connection after the last non-keepalive message is transmitted
   over the connection. The two parties SHOULD set the negotiated
   interval to the MAXIMUM value of the two requests. If either side
   sets the interval to zero, then that side SHOULD not close idle
   connections. The other party MAY adopt this same behavior or MAY
   choose to close idle connections at its own behest.
</t>

<t>
   If no bundle data other than keepalives has been received for at least
   twice the keepalive interval, then either party MAY terminate the
   session by transmitting a one byte message type code of SHUTDOWN
   (as described in <xref target="types:codes"/>) and closing the TCP
   connection.
</t>

</section>

<section title="Receiver Initated Connection" anchor="sec:receiver_connect">
</section>

<section title="Reactive Fragmentation" anchor="sec:reactive_fragmentation">
</section>



<section title="Requirements notation">
   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119"/>.</t> </section>

<section title="Security Considerations">
   <t>None.</t>
</section>

</middle>

<back>
<references>
   <reference anchor="RFC2119">
      <front>
         <title>XXX</title>
         <author initials="X." surname="YZ" fullname="XYZ">
            <organization abbrev="XXX">XXX</organization>
         </author>
      </front>
   </reference>

   <reference anchor="refs.dtnarch">
      <front>
         <title>Delay-Tolerant Network Architecture</title>
         <author initials="V." surname="Cerf et al" fullname="Vinton Cerf">
            <organization abbrev="MCI/Jet Propulsion Laboratory">
               MCI/Jet Propulsion Laboratory
            </organization>
         </author>
      </front>
      <format type='TXT' octets='0'
              target='http://somewhere'/>
   </reference>
   <reference anchor="refs.dtnimpl">
      <front>
         <title>Implementing Delay Tolerant Networking</title>
         <author initials="M." surname="Demmer et al"
                 fullname="Michael Demmer et al">
            <organization abbrev="UC Berkeley / Intel Research">
               University of California, Berkeley
               Intel Research Berkeley
            </organization>
         </author>
      </front>
      <format type='TXT' octets='0'
              target='http://somewhere'/>
   </reference>
   
</references>
</back>

</rfc>
