<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="exp" ipr="full3978" docName="draft-irtf-dtnrg-tcp-clayer.txt">
 
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<?rfc toc="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc iprnotified="no"?>
<?rfc compact="yes"?>

<front>
   <title abbrev="DTN TCP Convergence Layer">
      Delay Tolerant Networking TCP Convergence Layer Protocol
   </title>

   <workgroup>Delay Tolerant Networking Research Group</workgroup>

   <author initials="M.J." surname="Demmer" fullname="Michael J. Demmer">
      <organization abbrev="UC Berkeley">
         University of California, Berkeley
      </organization>

      <address>
         <postal>
            <street>Computer Science Division</street>
            <street>445 Soda Hall</street>
            <city>Berkeley</city>
            <region>CA</region>
            <code>94720-1776</code>
            <country>US</country>
         </postal>

         <email>demmer@cs.berkeley.edu</email>
      </address>
   </author>

   <date month="August" year="2006"/>

   <abstract>
      <t>
         This document describes a protocol for a TCP-based
         Convergence Layer for Delay Tolerant Networking (DTN).
      </t>
   </abstract>

</front>

<middle>

<section title="Introduction">
<t>
   This document describes a TCP based convergence layer protocol for
   Delay Tolerant Networking (TCPCL). Delay Tolerant Networking is an
   end-to-end architecture providing communications in and/or through
   highly stressed environments, including those with intermittent
   connectivity, long and/or variable delays, and high bit error
   rates. More detailed descriptions of the rationale and capabilities
   of these networks can be found in the <xref target="refs.dtnarch">
   Delay-Tolerant Network Architecture</xref> Internet Draft.
</t>

<t>
   An important goal of the DTN architecture is to accomodate a wide
   range of networking technologies and environments. The protocol
   used for DTN communications is the <xref target="refs.bundleproto">
   Bundling Protocol (BP)</xref>, an application-layer protocol that
   is used to construct a store-and-forward overlay network. As
   described in the bundle protocol specification, BP requires the
   services of a "convergence layer adapter" (CLA) to send and receive
   bundles using an underlying internet protocol. This document
   describes one such convergence layer adapter that uses the
   well-known <xref target="refs.tcprfc">Transmission Control Protocol
   (TCP)</xref>.
</t>

<t>
   The locations of the TCPCL and BP in the Internet model protocol
   stack are shown in Figure <xref target="fig:protocol_stack"/>. In
   particular, both the BP and the TCPCL sit at the application layer,
   while TCP and IP sit at their normal layers.
</t>

<figure anchor="fig:protocol_stack"
        title="The locations of the bundle protocol and the TCP
        convergence layer protocol in the Internet protocol stack">

   <artwork>
   +-------------------------+ 
   |     DTN Application     | -\
   +-------------------------|   |
   |  Bundle Protocol (BP)   |   -> Application Layer
   +-------------------------+   |
   | TCP Conv. Layer (TCPCL) | -/
   +-------------------------+ 
   |          TCP            | ---> Transport Layer
   +-------------------------+
   |           IP            | ---> Network Layer
   +-------------------------+
   |   Link-Layer Protocol   | ---> Link Layer
   +-------------------------+
   |    Physical Medium      | ---> Physical Layer
   +-------------------------+
   </artwork>
</figure>

<t>
   This document describes the format of the protocol data units
   passed between entities participating in TCPCL communications. This
   document does not address:
</t>

<t>
<list style="hanging" hangIndent="5">
   <t>
      The format of protocol data units of the bundling protocol, as
      those are defined elsewhere <xref target="refs.bundleproto"/>.
   </t>
   <t></t>
   
   <t>
      Mechanisms for locating or identifying other bundle nodes within
      an internet.
   </t>
   <t></t>

   <t>
      Operational logic or procedures used to implement this protocol.
   </t>
   <t></t>
</list>
</t>

<t>
   Note that this document describes version 3 of the protocol.
   Versions 0, 1, and 2 were never specified in any Internet Draft,
   RFC, or any other public document. These prior versions of the
   protocol were, however, implemented in
   the <xref target="refs.dtnimpl"> DTN reference
   implementation</xref>, in prior releases, hence this specification
   reflects those prior versions.
</t>

<t>
   The current protocol is implemented by the DTN reference
   implementation release 2.3.0. XXX Should release this before
   publishing this document.
</t>

</section> <!-- Introduction -->

<section title="Definitions">

<section title="Definitions Relating to the Bundle Protocol">   

<t>The following set of definitions are abbreviated versions of those
   which appear in the <xref target="refs.bundleproto"> Bundle
   Protocol Specification</xref>. To the extent in which terms appear
   in both documents, they are intended to have the same meaning.
</t>
   
<list style="hanging" hangIndent="5">
   <t hangText="Bundle --">A bundle is a protocol data unit of the DTN
      bundle protocol.
   </t>
   <t></t>
   
   <t hangText="Bundle payload --">A bundle payload (or simply
      "payload") is the application data whose conveyance to the
      bundle's destination is the purpose for the transmission of a
      given bundle.
   </t>
   <t></t>

   <t hangText="Fragment --">A fragment is a bundle whose payload
      contains a range of bytes from another bundle's payload.
   </t>
   <t></t>

   <t hangText="Bundle node --">A bundle node (or simply a "node") is
      any entity that can send and/or receive bundles. The particular
      instantiation of this entity is deliberately unconstrained,
      allowing for implementations in software libraries, long-running
      processes, or even hardware. One component of the bundle node is
      the implementation of a convergence layer adapter.
   </t>
   <t></t>

   <t hangText="Convergence layer adapter --">A convergence layer
      adapter (CLA) sends and receives bundles utilizing the services
      of some 'native' internet protocol. This document describes the
      manner in which a CLA sends and receives bundles when using the
      TCP protocol for inter-node communication.
   </t>
   <t></t>

   <t hangText="Self Describing Numeric Value --">A self describing
      numeric value (SDNV) is a variable length encoding for integer
      values, defined in the bundle protocol specification.
   </t>
   <t></t>
</list>
</section> <!-- BPDefinitions -->
   
<section title="Definitions specific to the TCPCL Protocol">

<t>This section contains definitions that are interpreted to be
   specific to the operation of the TCPCL protocol, as described
   below.
</t>

<list style="hanging" hangIndent="5">
   <t></t>
   
   <t hangText="TCP Session --">A TCP Session refers to the connection
      using the TCP network transport. XXX cite something from the TCP
      RFC.
   </t>
   <t></t>
   
   <t hangText="Connection --">A connection is a TCPCL communication
      session between two bundle nodes. The lifetime of a connection
      is one-to-one with the lifetime of an underlying TCP session.
      Therefore a TCPCL connection is initated when a bundle node
      initiates a TCP session to be initiated for the purposes of
      bundle communication. A connection is terminated when the TCP
      session ends, due either to one or both nodes actively
      terminating the connection or due to network errors causing a
      failure of the session.
   </t>
   <t></t>

   <t hangText="Connection parameters --">The connection parameters
      are a set of values used to affect the operation of the TCPCL
      for a given connection. The manner in which these parameters are
      conveyed to the bundle node and thereby to the TCPCL is
      implementation dependant. However, the mechanism by which two
      bundle nodes exchange and negotiate the values to be used for a
      given connection is described in Secion <xref
      target="sec:negotiation"/>.
   </t>
   <t></t>

   <t hangText="Connection initiator --">The connection initiator is
      the bundle node that causes the establishment of a new
      connection by creating a new TCP session (for example, by using
      the connect() call in the BSD sockets API) and then following
      the procedures described in <xref
      target="sec:connection_establishment"/>.
   </t>
   <t></t>

   <t hangText="Connection acceptor --">The connection acceptor is the
      bundle node that establishes a connection in response to an
      active connection attempt by another bundle node (for example,
      by using the listen() and accept() calls of the BSD sockets API)
      and then following the procedures described in <xref
      target="sec:connection_establishment"/>.
   </t>
   <t></t>

   <t hangText="Transmission --">Transmission refers to the procedures
      and mechanisms (described below) for conveyance of a bundle from
      one node to another.
   </t>
   <t></t>

   <t></t>
</list>

</section> <!-- TCPCL Definitions -->

</section> <!-- Definitions -->

<section title="General Protocol Description" anchor="sec:general_description">

<t>
   This protocol provides bundle conveyance over a TCP connection. The
   general operation of the protocol is as follows:
</t>

<t>
   First one node establishes a connection to the other by initiating
   a TCP session. At the beginning of the connection, an initial
   contact header is exchanged in both directions to set parameters of
   the connection. In addition, a single AnnounceBundle is transmitted
   by each party (preceded by an SDNV containing the total length of
   the bundle). The source endpoint identifier of this bundle is used
   to identify the local identity of each DTN node.
</t>

<t>
   Once the connection is established, bundles can be transmitted in
   either direction. Each bundle is transmitted in one or more logical
   segments of formatted bundle data. To transmit a bundle, a node
   first sends a START_BUNDLE message code, followed by one or more
   logical data segments, and then finally an END_BUNDLE code. Each
   logical data segment is comprised of a DATA_SEGMENT code, an SDNV
   containing the length of the segment, and finally the byte range of
   the bundle data. The choice of the length to use for segments is an
   implementation manner.
</t>
<t>
   An optional feature of the protocol is for the receiving node to
   send acknowledgements as bundle data segments arrive. The rationale
   behind these acknowledgements is to enable the sender node to
   determine how much of the bundle has been received, so that in case
   the connection is interrupted, it can perform reactive
   fragmentation to avoid re-sending the already transmitted part of
   the bundle.
</t>
<t>
   When acknowledgements are enabled, then for each data segment that
   is received, the receiving node sends an ACK_SEGMENT code followed
   by an SDNV containing the cumulative length of the bundle that has
   been received. Note that in the case of concurrent bidirectional
   transmission, then ack segments may be interleaved with data
   segments.
</t>
<t>
   For connections that are idle, a KEEPALIVE code may optionally be
   sent at a negotiated interval. Finally, before connections close, a
   SHUTDOWN code is sent on the channel.
</t>

<section title="Example Data Flow">
   
<figure anchor="fig:example_flow"
        title="A simple visual example of the flow of protocol
        messages on a single TCP session between two nodes (A and B)">

   <preamble>
      The following figure visually depicts the protocol exchange for
      a simple session, showing the connection establishment, and the
      transmission of a single bundle split into two data segments (of
      lengths L1 and L2) from Node A to Node B. 
   </preamble>

<artwork>
             Node A                              Node B
             ======                              ======

   +-------------------------+         +-------------------------+
   |     Contact Header      | -&gt;   &lt;- |     Contact Header      |
   +-------------------------+         +-------------------------+
                                      
   +-------------------------+         +-------------------------+
   |     Announce Bundle     | -&gt;   &lt;- |     Announce Bundle     |
   +-------------------------+         +-------------------------+
                                       
   +-------------------------+         
   |      START_BUNDLE       | -&gt;              
   +-------------------------+         
   |      DATA_SEGMENT       | -&gt;              
   +-------------------------+         
   |      SDNV length [L1]   | -&gt;              
   +-------------------------+         
   |     Bundle Data 0..L1   | -&gt;              
   +-------------------------+         
                                       +-------------------------+
                                    &lt;- |       ACK_SEGMENT       |
   +-------------------------+         +-------------------------+
   |      DATA_SEGMENT       | -&gt;   &lt;- |     SDNV Length [L1]    |
   +-------------------------+         +-------------------------+
   |      SDNV length [L2]   | -&gt;
   +-------------------------+   
   |     Bundle Data L1..L2  | -&gt;
   +-------------------------+   
                                       +-------------------------+
                                    &lt;- |       ACK_SEGMENT       |
                                       +-------------------------+
   +-------------------------+      &lt;- |    SDNV Length [L1+L2]  |
   |       END_BUNDLE        | -&gt;      +-------------------------+
   +-------------------------+   

   +-------------------------+         +-------------------------+
   |       SHUTDOWN          | -&gt;   &lt;- |         SHUTDOWN        |
   +-------------------------+         +-------------------------+

</artwork>
</figure>

</section> <!-- Example Data Flow -->
</section> <!-- General Protocol Description -->

<section title="Connection Establishment" anchor="sec:connection_establishment">

<t>
   For bundle transmissions to occur using the TCPCL, a connection
   must first be established between communicating nodes. The manner
   in which a bundle node makes the decision to establish such a
   connection is implementation dependant. For example, some
   connections may be opened proactively and maintained for as long as
   is possible given the network conditions, while other connections
   may be opened only when there is a bundle that is queued for
   transmission over it.
</t>

<t>
   To establish a TCPCL connection, a node must first establish a TCP
   session with the intended peer node, typically by using the
   services provided by the operating system. If the node is unable to
   establish a connection for any reason, then it is an implementation
   manner to determine how to handle the failed connection. For
   example, a node may decide to re-attempt to establish the
   connection, perhaps after some delay or it may attempt to find an
   alternate route for bundle data.
</t>

<t>
   Once a TCP session is established, both the connection initiator
   and the connection acceptor should immediately transmit a contact
   header over the session. The format of the contact header is
   described in <xref target="sec:contact_header"/>.
</t>

<t>
   Upon receipt of the contact header, both nodes perform the
   validation and negotiation procedures defined in
   <xref target="sec:negotiation"/>
</t>

<t>
   After negotiation, both nodes transmit an announcement bundle
   (AnnounceBundle). This exchange is used to inform the Bundle
   Protocol Agent running at each end of the connection of the
   Endpoint Identifier (EID) of the other party, as well as any
   additional capabilities that may be communicated. The format of the
   AnnounceBundle is described in <xref target="sec:announce_bundle"/>
   </t>

<section title="Contact Header" anchor="sec:contact_header">

<t>
Once a TCP session is established, both parties exchange a contact
header. This section describes the format of the contact header and
the meaning of its fields.
</t>
   
<figure anchor="fig:contact_header"
   title="Contact Header Format">
   <preamble>
      The format for the Contact Header is as follows:
   </preamble>
   
   <artwork>
                     1                   2                   3  
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|                          magic='dtn!'                         |
+---------------+---------------+---------------+---------------+
|     version   |     flags     |      keepalive_interval       |
+---------------+---------------+---------------+---------------+
   </artwork>
</figure>

<t>
The fields of the contact header are:
</t>

<t>
<list style="hanging" hangIndent="5">
   <t hangText="magic:"> A four byte field that always contains the
      byte sequence 0x64 0x76 0x6e 0x21, i.e. the ASCII string "dtn!".
   </t>
   <t></t>
   
   <t hangText="version:"> A one byte field value containing the
      current version of the protocol.
   </t>
   <t></t>

   <t hangText="flags:"> A one byte field containing optional
      connection flags. The first six bits are unused and must be set
      to zero. The last two bits are interpreted as follows:
   </t>
</list>
</t>

<texttable anchor="contact:flags"
           title="Contact Header Flags">
   <ttcol align="center">Value</ttcol>
   <ttcol align="center">Meaning</ttcol>

   <c>00000001</c>
   <c>Request acknowledgement of bundle segments.</c>

   <c>00000010</c>
   <c>Request enabling of reactive fragmentation.</c>

</texttable>

<t>
<list style="hanging" hangIndent="5">

   <t hangText="keepalive_interval:"> A two byte integer field
      containing the number of seconds between exchanges of keepalive
      messages on the connection (see <xref target="sec:keepalive"/>).
      This value is in network byte order, as are all other multi-byte
      fields described in this protocol.
   </t>
   <t></t>

</list>

<t>
   The manner in which values are configured and chosen for the
   various flags and parameters in the contact header is
   implementation dependent.
</t>

</t>
</section> <!-- Contact header -->

<section title="Validation and parameter negotiation" anchor="sec:negotiation">

<t>
Upon reception of the contact header, both the connection initiator
and the connection acceptor follow the following procedures for
ensuring the validity of the connection and to negotiate values for
the connection parameters.
</t>

<t>
If the magic string is not present or is not valid, the connection
must be terminated. The intent of the magic string is to provide a
some protection against an inadvertent TCP connection by a different
protocol than the one described in this document. To prevent a flood
of repeated connections from a misconfigured application, a node may
elect to hold an invalid connection open and idle for some time before
closing it.
</t>

<t>
If a node receives a contact header containing a version that is
greater than the current version of the protocol that the node
implements, then the node should interpret all fields and messages as
it would normally. If a node receives a contact header with a version
that is lower than the version of the protocol that the node
implements, the node may either terminate the connection due to the
version mismatch, or may adapt its operation to conform to the older
version of the protocol. This decision is an implementation manner.
</t>

<t>
A node calculates the parameters for a connection by negotiating the
values from its own preferences (conveyed by the contact header it
sent) with the preferences of the peer node (expressed in the contact
header that it received). This negotiation should proceed in the
following manner:
</t>

<list style="hanging" hangIndent="5">
   <t></t>
   
   <t>The segment acknowledgements enabled parameter is set to true
      iff the corresponding flag is set in both contact headers.
   </t>
   <t></t>

   <t>The reactive fragmentation enabled parameter is set to true iff
      the corresponding flag is set in both contact headers.
   </t>
   <t></t>

   <t>The keealive_interval parameter should be set to the minimum
      value from both contact headers. If one or both contact headers
      contains the value zero, then the keepalive feature (described
      in <xref target="sec:keepalive"/>) is disabled.
   </t>
   <t></t>
   
</list>

<t>
Once this process of parameter negotiation is completed, the protocol
defines no additional mechanism to change the parameters of an
established connection; to effect such a change, the connection must
be terminated and a new connection established.
</t>

</section> <!-- Negotiation -->

<section title="Announcement Bundle Exchange" anchor="sec:announce_bundle">

<t>
   IMPLEMENTATION NOTE: The format of this announcement bundle is
   likely to change before the eventual publication of this document
   as an RFC. In particular, its format should be described in an
   external document that is referenced by this specification.
</t>

<t>
   Immediately following the contact header exchange, a single bundle
   is always transmitted over the link. The contents of the bundle are
   defined as follows:
</t>

<t>
   The source endpoint identifier is set to an endpoint identifier
   (EID) for some singleton endpoint that the node is a member. In the
   case that a node is a member of multilple singleton endpoints, it
   is an implementation manner to determine which identifier is used
   in the announcement bundle. The destination, report-to, and
   custodian endpoint identifiers shall be set to the null endpoint ID
   ("dtn:none").
</t>

<t>
   The Announcement Bundle is defined as a new type of Administrative
   record with a type code of 0x05. As such, the payload of the bundle
   is a single byte long, with the value 0x05 in the high-order four
   bits of the byte, and the lower four bits used for administrative
   record flags. As none of the defined flags apply to this bundle,
   the lower-order four bits shall be set to zero.
</t>
   
<t>
   Based on these values, the format of the bundle is determined by
   the current version of the bundle protocol specification.
</t>

</section> <!-- Announcement Bundle Exchange -->

</section> <!-- Connection Establishment -->

<section title="Established Connection Operation">

<t>
This section describes the protocol operation for the duration of an
established connection, including the mechanisms for transmitting
bundles over the connection.
</t>

<section title="Message Type Codes" anchor="sec:types">

<t>
After the initial exchange of a contact header, all messages
transmitted over the connection are denoted by a one byte message type
code.
</t>

<texttable anchor="types:codes"
           title="TCPCL Header Types">

   <preamble>
      The types and values for the message type code are as follows.
   </preamble>
   <ttcol align="center" valign="top" width="25%">Type</ttcol>
   <ttcol align="center" valign="top" width="10%">Code</ttcol>
   <ttcol align="left"   valign="top" width="65%">Comment</ttcol>
   
   <c>START_BUNDLE</c>
   <c>0x01</c>
   <c>Commences the transmission of a new bundle,
      described in section <xref target="sec:bundle_data"/>.
   </c>
   <c>&nbsp;</c><c></c><c></c>

   <c>END_BUNDLE</c>
   <c>0x02</c>
   <c>Indicates the completion of transmission of a bundle,
      described in section <xref target="sec:bundle_data"/>.
   </c>
   <c>&nbsp;</c><c></c><c></c>

   <c>DATA_SEGMENT</c>
   <c>0x03</c>
   <c>Indicates the transmission of a segment of bundle data,
      described in section <xref target="sec:bundle_data"/>.
   </c>
   <c>&nbsp;</c><c></c><c></c>

   <c>ACK_SEGMENT</c>
   <c>0x04</c>
   <c>Acknowledges reception of a data segment. Following this type
      code, a node transmits an SDNV denoting the cumulative length of
      all received segments.</c>
   <c>&nbsp;</c><c></c><c></c>

   <c>KEEPALIVE</c>
   <c>0x05</c>
   <c>Keepalive message for the connection, described in
      <xref target="sec:keepalive"/>.</c>
   <c>&nbsp;</c><c></c><c></c>
   
   <c>SHUTDOWN</c>
   <c>0x06</c>
   <c>Indicates that one of the nodes participating in the connection
      wishes to cleanly terminate the connection, described in
      <xref target="sec:termination"/>.
   </c>
</texttable>
</section> <!-- Message type codes -->

   
<section title="Bundle Data Transmission" anchor="sec:bundle_data">

<t>
   Each bundle is transmitted in one or more data segments; to begin
   this sequence, a node sends a START_BUNDLE message, then sends the
   segments (each preceded by a DATA_SEGMENT type code), then
   completes the transmission by sending an END_BUNDLE message.
</t>
<t>
   Determining the segment size is an implementation manner. In
   particular, a node may, based on local policy or configuration,
   only ever transmit bundle data in a single segment. However a node
   must be able to receive a bundle that has been tranmsmitted in any
   segment size.
</t>
<t>
   In the bundle protocol specification, a single bundle is comprised
   of a primary bundle block, plus zero or more additional bundle
   blocks. The relationship between the protocol blocks and the
   convergence layer segments is underfined. In particular, a segment
   may contain more than one protocol block; alternatively, a single
   protocol block (such as the payload) may be split into multiple
   segments.
</t>
<t>
   Once a transmission of a bundle has commenced, the node must only
   send segments related to that bundle until it sends an END_BUNDLE
   message. However, the node need not transmit the entire bundle
   before sending the END_BUNDLE message. Once any data segment of the
   bundle is complete, the node may send an END_BUNDLE message and
   then cease transmission of the bundle.
</t>
<t>
   Each segment transmission is preceded by a DATA_SEGMENT type code
   and an SDNV containing the length of that segment.
</t>
</section> <!-- Bundle Data -->

<section title="Bundle Acknowledgements" anchor="sec:acks">

<t>
   Although the TCP transport provides reliable transfer of data
   between hosts, the typical BSD sockets interface provides no means
   to inform a sending application of when the receiving application
   has processed some amount of transmitted data. Thus after
   transmitting some data, a bundle protocol agent needs an additional
   mechanism to determine whether the receiving agent has successfully
   received the transmitted data.
</t>

<t>
   To this end, the TCPCL protocol offers an optional feature whereby
   a receiving node transmits acknowledgements of reception of data
   segments. This feature is enabled if and only if during the
   exchange of contact headers, both parties set the flag to indicate
   that segment acknowledgements are enabled (see
   <xref target="sec:contact_header"/>). If so, then the receiver must
   transmit a bundle acknowledgement header when it successfully
   receives each data segment.
</t>

<t>
   To transmit a data segment acknowledgement header, a node first
   transmits a ACK_SEGMENT message type code, then transmits an SDNV
   containing the cumulative length of the received segment(s) of the
   current bundle. For example, suppose the sending node transmits
   four segments of bundle data with lengths 100, 200, 500, and 1000
   respectively. After receiving the first segment, the node sends an
   acknowledgement of length 100. After the second segment is
   received, the node sends an acknowledgement of length 300. The
   third and fourth acknowledgements are of length 800 and 1800
   respectively.
</t>

</section>

<section title="Keepalive Messages" anchor="sec:keepalive">
<t>
   The protocol includes a provision for transmission of keepalive
   messages over the TCP connection to help determine if the
   connection has been disrupted.
</t>

<t>
   As described in <xref target="sec:contact_header"/>, one of the
   parameters in the contact header is the keepalive_interval. Both
   sides populate this field with their requested intervals (in
   seconds) between keepalive messages.
</t>

<t>
   The format of a keepalive message is a one byte message type code
   of KEEPALIVE (as described in <xref target="types:codes"/>, with no
   additional data. Both sides should send a keepalive message
   whenever the negotiated interval has elapsed with no transmission
   of any message (keepalive or other).
</t>

<t>
   If no message (keepalive or other) has been received for at least
   twice the keepalive interval, then either party may terminate the
   session by transmitting a one byte message type code of SHUTDOWN
   (as described in <xref target="types:codes"/>) and closing the TCP
   connection.
</t>
</section> <!-- Keepalives -->

</section> <!-- Established session -->

<section title="Connection Termination" anchor="sec:termination">

<t>
   This section describes the procedures for ending a TCPCL connection.
</t>

<section title="Shutdown Message" anchor="sec:shutdown">
<t>
   To cleanly shut down a connection, a one byte message type code of
   SHUTDOWN may be transmitted at any time by either the sender or the
   receiver. When a node receives a SHUTDOWN message, it should send a
   SHUTDOWN message in return, then close the connection and clean up
   the TCP session.
</t>

<t>
   If a connection is terminated before another protocol message has
   completed, then the node must not transmit the SHUTDOWN message but
   still should close the TCP connection. In particular, if the
   connection is interrupted while a node is in the process of
   transmitting a bundle data segment, then the node may identify that
   the connection should be before it has completed the transmission
   of the data segment. Thus were the node to transmit the SHUTDOWN
   message, the receiving node might erroneously interpret the
   SHUTDOWN message to be part of the data segment.
</t>
</section>

<section title="Idle Connection Shutdown" anchor="sec:idle">
<t>
   The protocol includes a provision for clean shutdown of idle TCP
   connections. Determining the length of time to wait before closing
   idle connections, if they are to be closed at all, is an
   implementation and configuration matter.
</t>

<t>
   If there is a configured time to close idle links, then if no
   bundle data (other than keepalive messages) has been received for
   at least that amount of time, then either node may terminate the
   session by transmitting a one byte message type code of SHUTDOWN
   (as described in <xref target="types:codes"/>) and closing the TCP
   session.
</t>

</section> <!-- Idle shutdown -->
</section> <!-- Connection Termination -->

<section title="Requirements notation">
   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119"/>.</t> </section>

<section title="Security Considerations">
   <t>XXX something about DOS and peer identification</t>
</section>

<section title="IANA Considerations">
   <t>XXX something about a well-known port</t>
</section>

</middle>

<back>
<references>
   <reference anchor="RFC2119">
      <front>
         <title>XXX</title>
         <author initials="X." surname="YZ" fullname="XYZ">
            <organization abbrev="XXX">XXX</organization>
         </author>
      </front>
   </reference>

   <reference anchor="refs.dtnarch">
      <front>
         <title>Delay-Tolerant Network Architecture</title>
         <author initials="V." surname="Cerf et al" fullname="Vinton Cerf">
            <organization abbrev="MCI/Jet Propulsion Laboratory">
               MCI/Jet Propulsion Laboratory
            </organization>
         </author>
      </front>
      <format type='TXT' octets='0'
              target='http://somewhere'/>
   </reference>
   
   <reference anchor="refs.bundleproto">
      <front>
         <title>Bundle Protocol Specification</title>
         <author initials="K." surname="Scott" fullname="Keith Scott">
            <organization abbrev="The MITRE Corporation">
               The MITRE Corporation
            </organization>
         </author>
         
         <author initials="S." surname="Burleigh" fullname="Scott Burleigh">
            <organization abbrev="Jet Propulsion Laboratory">
               Jet Propulsion Laboratory
            </organization>
         </author>
      </front>
      <format type='TXT' octets='0'
              target='http://somewhere'/>
   </reference>
   
   <reference anchor="refs.dtnimpl">
      <front>
         <title>Implementing Delay Tolerant Networking</title>
         <author initials="M." surname="Demmer et al"
                 fullname="Michael Demmer et al">
            <organization abbrev="UC Berkeley / Intel Research">
               University of California, Berkeley
               Intel Research Berkeley
            </organization>
         </author>
      </front>
      <format type='TXT' octets='0'
              target='http://somewhere'/>
   </reference>

   <reference anchor="refs.tcprfc">
      <front>
         <title>XXX TCP RFC</title>
      </front>
   </reference>
   
</references>
</back>

</rfc>
